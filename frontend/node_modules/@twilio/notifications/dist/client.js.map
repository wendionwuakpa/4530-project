{"version":3,"file":"client.js","sources":["../src/client.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport { TwilsockClient, ConnectionState } from \"twilsock\";\nimport { Connector, ChannelType } from \"./connector\";\nimport { RegistrarConnector } from \"./RegistrarConnector\";\nimport { TwilsockConnector } from \"./TwilsockConnector\";\nimport { log } from \"./logger\";\nimport {\n  validateTypesAsync,\n  validateTypes,\n  literal,\n  nonEmptyString,\n  validateConstructorTypes,\n  pureObject,\n} from \"@twilio/declarative-type-validator\";\nimport { LogLevelDesc } from \"loglevel\";\n\n// For validating Connector.ChannelType - keep synchronized!\nconst channelTypeRule = literal(\"apn\", \"fcm\", \"twilsock\");\n\ninterface PushNotification {\n  messageType: string;\n  payload: any;\n}\n\ninterface NotificationOptions {\n  region?: string;\n  ersUrl?: string;\n}\n\ninterface ClientOptions {\n  logLevel?: LogLevelDesc;\n  minTokenRefreshInterval?: number;\n  productId?: string;\n  twilsockClient?: TwilsockClient;\n  notifications?: NotificationOptions;\n  region?: string;\n}\n\n/**\n * @class\n * @alias Notifications\n * @classdesc The helper library for the notification service.\n * Provides high level api for creating and managing notification subscriptions and receiving messages\n * Creates the instance of Notification helper library\n *\n * @constructor\n * @param {string} token - Twilio access token\n * @param {Notifications#ClientOptions} options - Options to customize client behavior\n *\n * @event stateChanged channelType (registered|unregistered) -- coming from connector, i.e. it's per-connector type!\n * @event transportState Forwarded from Twilsock's stateChanged event.\n * @event message Routed from twilsock as a notification event.\n */\n@validateConstructorTypes(nonEmptyString, [\n  pureObject,\n  \"undefined\",\n  literal(null),\n])\nclass Client extends EventEmitter {\n  private readonly twilsock?: TwilsockClient;\n  private readonly connectors: Map<ChannelType, Connector>;\n\n  constructor(token: string, options: ClientOptions = {}) {\n    super();\n\n    options.logLevel = options.logLevel ?? \"error\";\n    log.setLevel(options.logLevel);\n\n    const productId = options.productId ?? \"notifications\";\n\n    const startTwilsock = !options.twilsockClient;\n\n    const twilsock = (options.twilsockClient =\n      options.twilsockClient ?? new TwilsockClient(token, productId, options));\n\n    const config = options.notifications ?? {};\n    const region = config.region ?? options.region ?? \"us1\";\n    const defaultUrl = `https://ers.${region}.twilio.com/v1/registrations`;\n    const registrarUrl = config.ersUrl || defaultUrl;\n\n    this.connectors = new Map<ChannelType, Connector>();\n\n    const platform = Client._detectPlatform();\n\n    this.connectors.set(\n      \"apn\",\n      new RegistrarConnector(\n        \"apn\",\n        { protocolVersion: 4, productId, platform },\n        twilsock,\n        registrarUrl\n      )\n    );\n    this.connectors.set(\n      \"fcm\",\n      new RegistrarConnector(\n        \"fcm\",\n        { protocolVersion: 3, productId, platform },\n        twilsock,\n        registrarUrl\n      )\n    );\n    this.connectors.set(\n      \"twilsock\",\n      new TwilsockConnector(productId, platform, twilsock)\n    );\n\n    twilsock.on(\"stateChanged\", (state) => this.emit(\"transportState\", state));\n\n    this._connector(\"twilsock\").on(\"stateChanged\", (type, value, state) =>\n      this.emit(\"stateChanged\", type, value, state)\n    );\n    this._connector(\"apn\").on(\"stateChanged\", (type, value, state) =>\n      this.emit(\"stateChanged\", type, value, state)\n    );\n    this._connector(\"fcm\").on(\"stateChanged\", (type, value, state) =>\n      this.emit(\"stateChanged\", type, value, state)\n    );\n\n    // Router\n    twilsock.on(\"message\", (type, message) =>\n      this._routeMessage(type, message)\n    );\n\n    this.updateToken(token);\n\n    // Start only if we created twilsock locally,\n    // otherwise it's the responsibility of whoever created the Twilsock client.\n    if (startTwilsock) {\n      twilsock.connect();\n      this.twilsock = twilsock;\n    }\n  }\n\n  public async shutdown(): Promise<void> {\n    this.connectors.clear();\n    if (this.twilsock) {\n      await this.twilsock.disconnect();\n    }\n  }\n\n  /**\n   * Set OS-provided APNS/FCM registration binding for the given channel type. Not used for 'twilsock'.\n   *\n   * You must call this function once you've received the ID of your device from the underlying OS.\n   *\n   * @param {ChannelType} channelType Channel type ('apn'/'fcm').\n   * @param {string} pushRegistrationId Token received from FCM/APNS system on device.\n   */\n  @validateTypes(channelTypeRule, nonEmptyString)\n  public setPushRegistrationId(\n    channelType: ChannelType,\n    pushRegistrationId: string\n  ): void {\n    log.debug(\n      `Set ${channelType} push registration id '${pushRegistrationId}'`\n    );\n    this._connector(channelType).setNotificationId(pushRegistrationId);\n  }\n\n  /**\n   * Subscribe to a given message type for a given channel type.\n   *\n   * Creates a subscriptions to receive incoming messages according to message type.\n   * Subscription establishes a binding and you will receive a signal when a notification\n   * of this type has been received by the library.\n   *\n   * Subscribed binding is preserved for 1 year, after which time it needs to be re-subscribed.\n   * This is the responsibility of the client SDK.\n   *\n   * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'\n   * @param {string} messageType The type of message that you want to receive\n   */\n  @validateTypes(channelTypeRule, nonEmptyString)\n  public subscribe(channelType: ChannelType, messageType: string): void {\n    log.debug(\n      `Add ${channelType} subscriptions for message type ${messageType}`\n    );\n    this._connector(channelType).subscribe(messageType);\n  }\n\n  /**\n   * Unsubscribe from a given message type.\n   *\n   * Unsubscribing breaks a binding and you will not receive more notifications for this message type.\n   * Please note that you have to call commitChanges() and receive a successful result before\n   * the subscription is actually removed.\n   *\n   * @param {ChannelType} channelType Supported are 'twilsock', 'apn' and 'fcm'\n   * @param {string} messageType The type of message that you don't want to receive anymore\n   */\n  @validateTypes(channelTypeRule, nonEmptyString)\n  public unsubscribe(channelType: ChannelType, messageType: string): void {\n    log.debug(\n      `Remove ${channelType} subscriptions for message type ${messageType}`\n    );\n    this._connector(channelType).unsubscribe(messageType);\n  }\n\n  /**\n   * Update subscription token. You must update the token when the old one expires.\n   *\n   * When you receive onTokenWillExpire event from twilsock, call this function with the new refreshed\n   * token _after_ you have updated twilsock and other associated objects with the new token.\n   *\n   * @param {string} token Authentication token for registrations\n   */\n  @validateTypes(nonEmptyString)\n  public updateToken(token: string): void {\n    this.connectors.forEach((connector) => connector.updateToken(token));\n  }\n\n  /**\n   * Commit all collected subscription changes as a batched update. This function tries to reduce\n   * number of network calls necessary to update bindings status.\n   */\n  public async commitChanges(): Promise<void> {\n    const promises: Promise<void>[] = [];\n    this.connectors.forEach((connector) => {\n      if (connector.isActive()) {\n        promises.push(connector.commitChanges());\n      }\n    });\n    await Promise.all(promises);\n  }\n\n  /**\n   * Clear existing registrations directly using provided device token.\n   * This is useful to ensure stopped subscriptions without resubscribing.\n   *\n   * This function goes completely beside the state machine and removes all registrations.\n   * Use with caution: if it races with current state machine operations, madness will ensue.\n   *\n   * @param {ChannelType} channelType Channel type ('apn'/'fcm').\n   * @param {string} registrationId Token received from FCM/APNS system on device.\n   */\n  @validateTypesAsync(channelTypeRule, nonEmptyString)\n  public async removeRegistrations(\n    channelType: ChannelType,\n    registrationId: string\n  ): Promise<void> {\n    await this._connector(channelType).sendDeviceRemoveRequest(registrationId);\n  }\n\n  /**\n   * Handle incoming push notification.\n   * Client application should call this method when it receives push notifications and pass the received data.\n   * @param {Object} message push message\n   * @return {PushNotification} A reformatted payload with extracted message type.\n   */\n  public handlePushNotification(message: any): PushNotification {\n    return {\n      messageType: message.twi_message_type,\n      payload: message.payload,\n    };\n  }\n\n  /**\n   * Routes messages to the external subscribers\n   */\n  private _routeMessage(type: string | undefined, message: string): void {\n    log.debug(\"Notification message arrived: \", type, message);\n    this.emit(\"message\", type, message);\n  }\n\n  /**\n   * @param {String} type Channel type\n   * @throws {Error} Error with description\n   */\n  private _connector(type: ChannelType): Connector {\n    const connector = this.connectors.get(type);\n    if (!connector) {\n      throw new Error(`Unknown channel type: ${type}`);\n    }\n    return connector;\n  }\n\n  /**\n   * Returns platform string limited to max 128 chars\n   */\n  private static _detectPlatform(): string {\n    let platform = \"\";\n    if (typeof navigator !== \"undefined\") {\n      platform = \"unknown\";\n      if (typeof navigator.product !== \"undefined\") {\n        platform = navigator.product;\n      }\n      if (typeof navigator.userAgent !== \"undefined\") {\n        platform = navigator.userAgent;\n      }\n    } else {\n      platform = \"web\";\n    }\n\n    return platform.substring(0, 128);\n  }\n}\n\n/**\n * @event Client#message\n * Fired when a new notification message arrives.\n * @param {string} type Message type\n * @param {Object} message Message payload\n */\n\n/**\n * @event Client#stateChanged\n * Fired when the registration state changes.\n * @param {ChannelType} type Type of channel\n * @param {string} status Status of registration (registered/unregistered)\n * @param {Object} state Registration state details\n *                       (token, notificationId, currently subscribed types)\n */\n\n/**\n * @event Client#transportState\n * Fired when the twilsock connection state changes.\n * @param {string} state New transport state. Coming directly from Twilsock#ConnectionState.\n */\n\n/**\n * These options can be passed to Client constructor\n * @typedef {Object} Notifications#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n */\n\nexport { ChannelType, ConnectionState, PushNotification, Client };\n"],"names":["literal","Client","EventEmitter","log","twilsock","TwilsockClient","RegistrarConnector","TwilsockConnector","__decorate","validateTypes","nonEmptyString","validateTypesAsync","validateConstructorTypes","pureObject"],"mappings":"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"}
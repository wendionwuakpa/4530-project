/*
@license
The following license applies to all parts of this software except as
documented below.

    Copyright (c) 2019, Twilio, inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.

      3. Neither the name of Twilio nor the names of its contributors may
         be used to endorse or promote products derived from this software
         without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This software includes javascript-state-machine under the following license.

    Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

This software includes loglevel under the following license.

    Copyright (c) 2013 Tim Perry

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

This software includes q under the following license.

    Copyright 2009â€“2014 Kristopher Michael Kowal. All rights reserved.
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.

This software includes platform.js under the following license.

    Copyright 2014 Benjamin Tan <https://d10.github.io/>
    Copyright 2011-2015 John-David Dalton <http://allyoucanleet.com/>

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
'use strict';

var global =
  typeof global !== "undefined"
    ? global
    : typeof self !== "undefined"
    ? self
    : typeof window !== "undefined"
    ? window
    : {};

Object.defineProperty(exports, '__esModule', { value: true });

var tslib_es6 = require('./node_modules/tslib/tslib.es6.js');
require('isomorphic-form-data');
var logger = require('./logger.js');
var participants = require('./data/participants.js');
var participant = require('./participant.js');
var messages = require('./data/messages.js');
var index = require('./util/index.js');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');
var rules = require('./interfaces/rules.js');
var messageBuilder = require('./message-builder.js');
var replayEventEmitter = require('@twilio/replay-event-emitter');
var isEqual = require('lodash.isequal');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);

/**
 * Map of the fields that will be processed with update messages.
 */
const fieldMappings = {
    lastMessage: "lastMessage",
    attributes: "attributes",
    createdBy: "createdBy",
    dateCreated: "dateCreated",
    dateUpdated: "dateUpdated",
    friendlyName: "friendlyName",
    lastConsumedMessageIndex: "lastConsumedMessageIndex",
    notificationLevel: "notificationLevel",
    sid: "sid",
    status: "status",
    uniqueName: "uniqueName",
    state: "state",
    bindings: "bindings",
};
/**
 * A conversation represents communication between multiple Conversations
 * clients.
 */
class Conversation extends replayEventEmitter.ReplayEventEmitter {
    /**
     * @param descriptor Conversation descriptor.
     * @param sid Conversation SID.
     * @param links Conversation links for REST requests.
     * @param configuration Client configuration.
     * @param services Conversation services.
     * @internal
     */
    constructor(descriptor, sid, links, configuration, services) {
        var _a, _b;
        super();
        this.sid = sid;
        this._links = links;
        this._configuration = configuration;
        this._services = services;
        this._entityName = descriptor.channel;
        this._internalState = {
            uniqueName: descriptor.uniqueName || null,
            status: "notParticipating",
            attributes: (_a = descriptor.attributes) !== null && _a !== void 0 ? _a : {},
            createdBy: descriptor.createdBy,
            dateCreated: index.parseTime(descriptor.dateCreated),
            dateUpdated: index.parseTime(descriptor.dateUpdated),
            friendlyName: descriptor.friendlyName || null,
            lastReadMessageIndex: Number.isInteger(descriptor.lastConsumedMessageIndex)
                ? descriptor.lastConsumedMessageIndex
                : null,
            bindings: (_b = descriptor.bindings) !== null && _b !== void 0 ? _b : {},
        };
        if (descriptor.notificationLevel) {
            this._internalState.notificationLevel = descriptor.notificationLevel;
        }
        const participantsLinks = {
            participants: this._links.participants,
        };
        this._participants = new Map();
        this._participantsEntity = new participants.Participants(this, this._participants, participantsLinks, this._configuration, this._services);
        this._participantsEntity.on("participantJoined", (participant) => this.emit("participantJoined", participant));
        this._participantsEntity.on("participantLeft", (participant) => this.emit("participantLeft", participant));
        this._participantsEntity.on("participantUpdated", (args) => this.emit("participantUpdated", args));
        this._messagesEntity = new messages.Messages(this, configuration, services);
        this._messagesEntity.on("messageAdded", (message) => this._onMessageAdded(message));
        this._messagesEntity.on("messageUpdated", (args) => this.emit("messageUpdated", args));
        this._messagesEntity.on("messageRemoved", (message) => this.emit("messageRemoved", message));
    }
    /**
     * Unique name of the conversation.
     */
    get uniqueName() {
        return this._internalState.uniqueName;
    }
    /**
     * Status of the conversation.
     */
    get status() {
        return this._internalState.status;
    }
    /**
     * Name of the conversation.
     */
    get friendlyName() {
        return this._internalState.friendlyName;
    }
    /**
     * Date this conversation was last updated on.
     */
    get dateUpdated() {
        return this._internalState.dateUpdated;
    }
    /**
     * Date this conversation was created on.
     */
    get dateCreated() {
        return this._internalState.dateCreated;
    }
    /**
     * Identity of the user that created this conversation.
     */
    get createdBy() {
        var _a;
        return (_a = this._internalState.createdBy) !== null && _a !== void 0 ? _a : "";
    }
    /**
     * Custom attributes of the conversation.
     */
    get attributes() {
        return this._internalState.attributes;
    }
    /**
     * Index of the last message the user has read in this conversation.
     */
    get lastReadMessageIndex() {
        return this._internalState.lastReadMessageIndex;
    }
    /**
     * Last message sent to this conversation.
     */
    get lastMessage() {
        var _a;
        return (_a = this._internalState.lastMessage) !== null && _a !== void 0 ? _a : undefined;
    }
    /**
     * User notification level for this conversation.
     */
    get notificationLevel() {
        var _a;
        return (_a = this._internalState.notificationLevel) !== null && _a !== void 0 ? _a : "default";
    }
    /**
     * Conversation bindings. Undocumented feature (for now).
     * @internal
     */
    get bindings() {
        return this._internalState.bindings;
    }
    /**
     * Current conversation limits.
     */
    get limits() {
        return this._configuration.limits;
    }
    /**
     * State of the conversation.
     */
    get state() {
        return this._internalState.state;
    }
    /**
     * Source of the conversation update.
     * @internal
     */
    get _statusSource() {
        return this._dataSource;
    }
    /**
     * Preprocess the update object.
     * @param update The update object received from Sync.
     * @param conversationSid The SID of the conversation in question.
     */
    static preprocessUpdate(update, conversationSid) {
        try {
            if (typeof update.attributes === "string") {
                update.attributes = JSON.parse(update.attributes);
            }
            else if (update.attributes) {
                JSON.stringify(update.attributes);
            }
        }
        catch (e) {
            Conversation._logger.warn("Retrieved malformed attributes from the server for conversation: " +
                conversationSid);
            update.attributes = {};
        }
        try {
            if (update.dateCreated) {
                update.dateCreated = new Date(update.dateCreated);
            }
        }
        catch (e) {
            Conversation._logger.warn("Retrieved malformed dateCreated from the server for conversation: " +
                conversationSid);
            delete update.dateCreated;
        }
        try {
            if (update.dateUpdated) {
                update.dateUpdated = new Date(update.dateUpdated);
            }
        }
        catch (e) {
            Conversation._logger.warn("Retrieved malformed dateUpdated from the server for conversation: " +
                conversationSid);
            delete update.dateUpdated;
        }
        try {
            if (update.lastMessage && update.lastMessage.timestamp) {
                update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);
            }
        }
        catch (e) {
            Conversation._logger.warn("Retrieved malformed lastMessage.timestamp from the server for conversation: " +
                conversationSid);
            delete update.lastMessage.timestamp;
        }
    }
    /**
     * Add a participant to the conversation by its identity.
     * @param identity Identity of the Client to add.
     * @param attributes Attributes to be attached to the participant.
     * @returns The added participant.
     */
    async add(identity, attributes) {
        return this._participantsEntity.add(identity, attributes !== null && attributes !== void 0 ? attributes : {});
    }
    /**
     * Add a non-chat participant to the conversation.
     * @param proxyAddress Proxy (Twilio) address of the participant.
     * @param address User address of the participant.
     * @param attributes Attributes to be attached to the participant.
     * @param bindingOptions Options for adding email participants - name and
     * CC/To level.
     * @returns The added participant.
     */
    async addNonChatParticipant(proxyAddress, address, attributes = {}, bindingOptions = {}) {
        return this._participantsEntity.addNonChatParticipant(proxyAddress, address, attributes !== null && attributes !== void 0 ? attributes : {}, bindingOptions !== null && bindingOptions !== void 0 ? bindingOptions : {});
    }
    /**
     * Advance the conversation's last read message index to the current read
     * horizon. Rejects if the user is not a participant of the conversation. Last
     * read message index is updated only if the new index value is higher than
     * the previous.
     * @param index Message index to advance to.
     * @return Resulting unread messages count in the conversation.
     */
    async advanceLastReadMessageIndex(index) {
        var _a;
        await this._subscribeStreams();
        if (index < ((_a = this.lastReadMessageIndex) !== null && _a !== void 0 ? _a : 0)) {
            return await this._setLastReadMessageIndex(this.lastReadMessageIndex);
        }
        return await this._setLastReadMessageIndex(index);
    }
    /**
     * Delete the conversation and unsubscribe from its events.
     */
    async delete() {
        await this._services.commandExecutor.mutateResource("delete", this._links.self);
        return this;
    }
    /**
     * Get the custom attributes of this Conversation.
     */
    async getAttributes() {
        await this._subscribe();
        return this.attributes;
    }
    /**
     * Returns messages from the conversation using the paginator interface.
     * @param pageSize Number of messages to return in a single chunk. Default is
     * 30.
     * @param anchor Index of the newest message to fetch. Default is from the
     * end.
     * @param direction Query direction. By default, it queries backwards
     * from newer to older. The `"forward"` value will query in the opposite
     * direction.
     * @return A page of messages.
     */
    async getMessages(pageSize, anchor, direction) {
        await this._subscribeStreams();
        return this._messagesEntity.getMessages(pageSize, anchor, direction);
    }
    /**
     * Get a list of all the participants who are joined to this conversation.
     */
    async getParticipants() {
        await this._subscribeStreams();
        return this._participantsEntity.getParticipants();
    }
    /**
     * Get conversation participants count.
     *
     * This method is semi-realtime. This means that this data will be eventually
     * correct, but will also be possibly incorrect for a few seconds. The
     * Conversations system does not provide real time events for counter values
     * changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any
     * core application logic based on these counters being accurate in real time.
     */
    async getParticipantsCount() {
        var _a;
        const url = new index.UriBuilder(this._configuration.links.conversations)
            .path(this.sid)
            .build();
        const response = await this._services.network.get(url);
        return (_a = response.body.participants_count) !== null && _a !== void 0 ? _a : 0;
    }
    /**
     * Get a participant by its SID.
     * @param participantSid Participant SID.
     */
    async getParticipantBySid(participantSid) {
        return this._participantsEntity.getParticipantBySid(participantSid);
    }
    /**
     * Get a participant by its identity.
     * @param identity Participant identity.
     */
    async getParticipantByIdentity(identity = "") {
        return this._participantsEntity.getParticipantByIdentity(identity !== null && identity !== void 0 ? identity : "");
    }
    /**
     * Get the total message count in the conversation.
     *
     * This method is semi-realtime. This means that this data will be eventually
     * correct, but will also be possibly incorrect for a few seconds. The
     * Conversations system does not provide real time events for counter values
     * changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any
     * core application logic based on these counters being accurate in real time.
     */
    async getMessagesCount() {
        var _a;
        const url = new index.UriBuilder(this._configuration.links.conversations)
            .path(this.sid)
            .build();
        const response = await this._services.network.get(url);
        return (_a = response.body.messages_count) !== null && _a !== void 0 ? _a : 0;
    }
    /**
     * Get count of unread messages for the user if they are a participant of this
     * conversation. Rejects if the user is not a participant of the conversation.
     *
     * Use this method to obtain the number of unread messages together with
     * {@link Conversation.updateLastReadMessageIndex} instead of relying on the
     * message indices which may have gaps. See {@link Message.index} for details.
     *
     * This method is semi-realtime. This means that this data will be eventually
     * correct, but it will also be possibly incorrect for a few seconds. The
     * Conversations system does not provide real time events for counter values
     * changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any
     * core application logic based on these counters being accurate in real time.
     *
     * If the read horizon is not set, this function will return null. This could mean
     * that all messages in the conversation are unread, or that the read horizon system
     * is not being used. How to interpret this `null` value is up to the customer application.
     *
     * @return Number of unread messages based on the current read horizon set for
     * the user or `null` if the read horizon is not set.
     */
    async getUnreadMessagesCount() {
        const url = new index.UriBuilder(this._configuration.links.myConversations)
            .path(this.sid)
            .build();
        const response = await this._services.network.get(url);
        if (response.body.conversation_sid !== this.sid) {
            throw new Error("Conversation was not found in the user conversations list");
        }
        const unreadMessageCount = response.body.unread_messages_count;
        if (typeof unreadMessageCount === "number") {
            return unreadMessageCount;
        }
        return null;
    }
    /**
     * Join the conversation and subscribe to its events.
     */
    async join() {
        await this._services.commandExecutor.mutateResource("post", this._links.participants, {
            identity: this._configuration.userIdentity,
        });
        return this;
    }
    /**
     * Leave the conversation.
     */
    async leave() {
        if (this._internalState.status === "joined") {
            await this._services.commandExecutor.mutateResource("delete", `${this._links.participants}/${encodeURIComponent(this._configuration.userIdentity)}`);
        }
        return this;
    }
    /**
     * Remove a participant from the conversation. When a string is passed as the
     * argument, it will assume that the string is an identity or SID.
     * @param participant Identity, SID or the participant object to remove.
     */
    async removeParticipant(participant) {
        await this._participantsEntity.remove(typeof participant === "string" ? participant : participant.sid);
    }
    /**
     * Send a message to the conversation.
     * @param message Message body for the text message,
     * `FormData` or {@link SendMediaOptions} for media content. Sending FormData
     * is supported only with the browser engine.
     * @param messageAttributes Attributes for the message.
     * @param emailOptions Email options for the message.
     * @return Index of the new message.
     */
    async sendMessage(message, messageAttributes, emailOptions) {
        var _a, _b;
        if (typeof message === "string" || message === null) {
            const response = await this._messagesEntity.send(message, messageAttributes, emailOptions);
            return (_a = index.parseToNumber(response.index)) !== null && _a !== void 0 ? _a : 0;
        }
        const response = await this._messagesEntity.sendMedia(message, messageAttributes, emailOptions);
        return (_b = index.parseToNumber(response.index)) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * New interface to prepare for sending a message.
     * Use this instead of {@link Conversation.sendMessage}.
     * @return A MessageBuilder to help set all message sending options.
     */
    prepareMessage() {
        return new messageBuilder.MessageBuilder(this.limits, this._messagesEntity);
    }
    /**
     * Set last read message index of the conversation to the index of the last
     * known message.
     * @return Resulting unread messages count in the conversation.
     */
    async setAllMessagesRead() {
        await this._subscribeStreams();
        const messagesPage = await this.getMessages(1);
        if (messagesPage.items.length > 0) {
            return this.advanceLastReadMessageIndex(messagesPage.items[0].index);
        }
        return 0;
    }
    /**
     * Set all messages in the conversation unread.
     * @returns New count of unread messages after this update.
     */
    async setAllMessagesUnread() {
        await this._subscribeStreams();
        return await this._setLastReadMessageIndex(null);
    }
    /**
     * Set user notification level for this conversation.
     * @param notificationLevel New user notification level.
     */
    async setUserNotificationLevel(notificationLevel) {
        await this._services.commandExecutor.mutateResource("post", `${this._configuration.links.myConversations}/${this.sid}`, {
            notification_level: notificationLevel,
        });
    }
    /**
     * Send a notification to the server indicating that this client is currently
     * typing in this conversation. Typing ended notification is sent after a
     * while automatically, but by calling this method again you ensure that
     * typing ended is not received.
     */
    typing() {
        return this._services.typingIndicator.send(this.sid);
    }
    /**
     * Update the attributes of the conversation.
     * @param attributes New attributes.
     */
    async updateAttributes(attributes) {
        await this._services.commandExecutor.mutateResource("post", this._links.self, {
            attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined,
        });
        return this;
    }
    /**
     * Update the friendly name of the conversation.
     * @param friendlyName New friendly name.
     */
    async updateFriendlyName(friendlyName) {
        if (this._internalState.friendlyName !== friendlyName) {
            await this._services.commandExecutor.mutateResource("post", this._links.self, { friendly_name: friendlyName });
        }
        return this;
    }
    /**
     * Set the last read message index to the current read horizon.
     * @param index Message index to set as last read. If null is provided, then
     * the behavior is identical to {@link Conversation.setAllMessagesUnread}.
     * @returns New count of unread messages after this update.
     */
    async updateLastReadMessageIndex(index) {
        await this._subscribeStreams();
        return this._setLastReadMessageIndex(index);
    }
    /**
     * Update the unique name of the conversation.
     * @param uniqueName New unique name for the conversation. Setting unique name
     * to null removes it.
     */
    async updateUniqueName(uniqueName) {
        if (this._internalState.uniqueName !== uniqueName) {
            uniqueName || (uniqueName = "");
            await this._services.commandExecutor.mutateResource("post", this._links.self, {
                unique_name: uniqueName,
            });
        }
        return this;
    }
    /**
     * Load and subscribe to this conversation and do not subscribe to its
     * participants and messages. This or _subscribeStreams will need to be called
     * before any events on conversation will fire.
     * @internal
     */
    async _subscribe() {
        if (this._entityPromise) {
            return this._entityPromise;
        }
        this._entityPromise = this._services.syncClient.document({
            id: this._entityName,
            mode: "open_existing",
        });
        try {
            this._entity = await this._entityPromise;
            this._entity.on("updated", (args) => this._update(args.data));
            this._entity.on("removed", () => this.emit("removed", this));
            this._update(this._entity.data);
            return this._entity;
        }
        catch (err) {
            this._entity = null;
            this._entityPromise = null;
            if (this._services.syncClient.connectionState != "disconnected") {
                Conversation._logger.error("Failed to get conversation object", err);
            }
            Conversation._logger.debug("ERROR: Failed to get conversation object", err);
            throw err;
        }
    }
    /**
     * Fetch participants and messages of the conversation. This method needs to
     * be called during conversation initialization to catch broken conversations
     * (broken conversations are conversations that have essential Sync entities
     * missing, i.e. the conversation document, the messages list or the
     * participant map). In case of this conversation being broken, the method
     * will throw an exception that will be caught and handled gracefully.
     * @internal
     */
    async _fetchStreams() {
        var _a, _b;
        await this._subscribe();
        Conversation._logger.trace("_streamsAvailable, this.entity.data=", (_a = this._entity) === null || _a === void 0 ? void 0 : _a.data);
        const data = (_b = this._entity) === null || _b === void 0 ? void 0 : _b.data;
        this._messagesList = await this._services.syncClient.list({
            id: data.messages,
            mode: "open_existing",
        });
        this._participantsMap = await this._services.syncClient.map({
            id: data.roster,
            mode: "open_existing",
        });
    }
    /**
     * Load the attributes of this conversation and instantiate its participants
     * and messages. This or _subscribe will need to be called before any events
     * on the conversation will fire. This will need to be called before any
     * events on participants or messages will fire
     * @internal
     */
    async _subscribeStreams() {
        var _a, _b, _c, _d;
        try {
            await this._subscribe();
            Conversation._logger.trace("_subscribeStreams, this.entity.data=", (_a = this._entity) === null || _a === void 0 ? void 0 : _a.data);
            const data = (_b = this._entity) === null || _b === void 0 ? void 0 : _b.data;
            const messagesObjectName = data.messages;
            const rosterObjectName = data.roster;
            await Promise.all([
                this._messagesEntity.subscribe((_c = this._messagesList) !== null && _c !== void 0 ? _c : messagesObjectName),
                this._participantsEntity.subscribe((_d = this._participantsMap) !== null && _d !== void 0 ? _d : rosterObjectName),
            ]);
        }
        catch (err) {
            if (this._services.syncClient.connectionState !== "disconnected") {
                Conversation._logger.error("Failed to subscribe on conversation objects", this.sid, err);
            }
            Conversation._logger.debug("ERROR: Failed to subscribe on conversation objects", this.sid, err);
            throw err;
        }
    }
    /**
     * Stop listening for and firing events on this conversation.
     * @internal
     */
    async _unsubscribe() {
        if (this._entity) {
            await this._entity.close();
            this._entity = null;
            this._entityPromise = null;
        }
        return Promise.all([
            this._participantsEntity.unsubscribe(),
            this._messagesEntity.unsubscribe(),
        ]);
    }
    /**
     * Set conversation status.
     * @internal
     */
    _setStatus(status, source) {
        this._dataSource = source;
        if (this._internalState.status === status) {
            return;
        }
        this._internalState.status = status;
        if (status === "joined") {
            this._subscribeStreams().catch((err) => {
                Conversation._logger.debug("ERROR while setting conversation status " + status, err);
                if (this._services.syncClient.connectionState !== "disconnected") {
                    throw err;
                }
            });
            return;
        }
        if (this._entityPromise) {
            this._unsubscribe().catch((err) => {
                Conversation._logger.debug("ERROR while setting conversation status " + status, err);
                if (this._services.syncClient.connectionState !== "disconnected") {
                    throw err;
                }
            });
        }
    }
    /**
     * Update the local conversation object with new values.
     * @internal
     */
    _update(update) {
        var _a, _b, _c, _d, _e;
        Conversation._logger.trace("_update", update);
        Conversation.preprocessUpdate(update, this.sid);
        const updateReasons = new Set();
        for (const key of Object.keys(update)) {
            const localKey = fieldMappings[key];
            if (!localKey) {
                continue;
            }
            switch (localKey) {
                case fieldMappings.status:
                    if (!update.status ||
                        update.status === "unknown" ||
                        this._internalState.status === update.status) {
                        break;
                    }
                    this._internalState.status = update.status;
                    updateReasons.add(localKey);
                    break;
                case fieldMappings.attributes:
                    if (isEqual__default["default"](this._internalState.attributes, update.attributes)) {
                        break;
                    }
                    this._internalState.attributes = update.attributes;
                    updateReasons.add(localKey);
                    break;
                case fieldMappings.lastConsumedMessageIndex:
                    if (update.lastConsumedMessageIndex === undefined ||
                        update.lastConsumedMessageIndex ===
                            this._internalState.lastReadMessageIndex) {
                        break;
                    }
                    this._internalState.lastReadMessageIndex =
                        update.lastConsumedMessageIndex;
                    updateReasons.add("lastReadMessageIndex");
                    break;
                case fieldMappings.lastMessage:
                    if (this._internalState.lastMessage && !update.lastMessage) {
                        delete this._internalState.lastMessage;
                        updateReasons.add(localKey);
                        break;
                    }
                    this._internalState.lastMessage =
                        this._internalState.lastMessage || {};
                    if (((_a = update.lastMessage) === null || _a === void 0 ? void 0 : _a.index) !== undefined &&
                        update.lastMessage.index !== this._internalState.lastMessage.index) {
                        this._internalState.lastMessage.index = update.lastMessage.index;
                        updateReasons.add(localKey);
                    }
                    if (((_b = update.lastMessage) === null || _b === void 0 ? void 0 : _b.timestamp) !== undefined &&
                        ((_d = (_c = this._internalState.lastMessage) === null || _c === void 0 ? void 0 : _c.dateCreated) === null || _d === void 0 ? void 0 : _d.getTime()) !==
                            update.lastMessage.timestamp.getTime()) {
                        this._internalState.lastMessage.dateCreated =
                            update.lastMessage.timestamp;
                        updateReasons.add(localKey);
                    }
                    if (isEqual__default["default"](this._internalState.lastMessage, {})) {
                        delete this._internalState.lastMessage;
                    }
                    break;
                case fieldMappings.state:
                    const state = update.state || undefined;
                    if (state !== undefined) {
                        state.dateUpdated = new Date(state.dateUpdated);
                    }
                    if (isEqual__default["default"](this._internalState.state, state)) {
                        break;
                    }
                    this._internalState.state = state;
                    updateReasons.add(localKey);
                    break;
                case fieldMappings.bindings:
                    if (isEqual__default["default"](this._internalState.bindings, update.bindings)) {
                        break;
                    }
                    this._internalState.bindings = update.bindings;
                    updateReasons.add(localKey);
                    break;
                default:
                    const isDate = update[key] instanceof Date;
                    const keysMatchAsDates = isDate &&
                        ((_e = this._internalState[localKey]) === null || _e === void 0 ? void 0 : _e.getTime()) === update[key].getTime();
                    const keysMatchAsNonDates = !isDate && this[localKey] === update[key];
                    if (keysMatchAsDates || keysMatchAsNonDates) {
                        break;
                    }
                    this._internalState[localKey] = update[key];
                    updateReasons.add(localKey);
            }
        }
        if (updateReasons.size > 0) {
            this.emit("updated", {
                conversation: this,
                updateReasons: [...updateReasons],
            });
        }
    }
    /**
     * Handle onMessageAdded event.
     */
    _onMessageAdded(message) {
        for (const participant of this._participants.values()) {
            if (participant.identity === message.author) {
                participant._endTyping();
                break;
            }
        }
        this.emit("messageAdded", message);
    }
    /**
     * Set last read message index.
     * @param index New index to set.
     */
    async _setLastReadMessageIndex(index) {
        const result = await this._services.commandExecutor.mutateResource("post", `${this._configuration.links.myConversations}/${this.sid}`, {
            last_read_message_index: index,
        });
        return result.unread_messages_count;
    }
}
/**
 * Fired when a participant has joined the conversation.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - participant that joined the
 * conversation
 * @event
 */
Conversation.participantJoined = "participantJoined";
/**
 * Fired when a participant has left the conversation.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - participant that left the
 * conversation
 * @event
 */
Conversation.participantLeft = "participantLeft";
/**
 * Fired when data of a participant has been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the
 * following properties:
 *     * {@link Participant} `participant` - participant that has received the
 *     update
 *     * {@link ParticipantUpdateReason}[] `updateReasons` - array of reasons
 *     for the update
 * @event
 */
Conversation.participantUpdated = "participantUpdated";
/**
 * Fired when a new message has been added to the conversation.
 *
 * Parameters:
 * 1. {@link Message} `message` - message that has been added
 * @event
 */
Conversation.messageAdded = "messageAdded";
/**
 * Fired when message is removed from the conversation's message list.
 *
 * Parameters:
 * 1. {@link Message} `message` - message that has been removed
 * @event
 */
Conversation.messageRemoved = "messageRemoved";
/**
 * Fired when data of a message has been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the
 * following properties:
 *     * {@link Message} `message` - message that has received the update
 *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for
 *     the update
 * @event
 */
Conversation.messageUpdated = "messageUpdated";
/**
 * Fired when a participant has stopped typing.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - the participant that has stopped
 * typing
 * @event
 */
Conversation.typingEnded = "typingEnded";
/**
 * Fired when a participant has started typing.
 *
 * Parameters:
 * 1. {@link Participant} `participant` - the participant that has started
 * typing
 * @event
 */
Conversation.typingStarted = "typingStarted";
/**
 * Fired when the data of the conversation has been updated.
 *
 * Parameters:
 * 1. object `data` - info object provided with the event. It has the
 * following properties:
 *     * {@link Conversation} `conversation` - conversation that has received
 *     the update
 *     * {@link ConversationUpdateReason}[] `updateReasons` - array of reasons
 *     for the update
 * @event
 */
Conversation.updated = "updated";
/**
 * Fired when the conversation was destroyed or the currently-logged-in user
 * has left private conversation.
 *
 * Parameters:
 * 1. {@link Conversation} `conversation` - conversation that has been removed
 * @event
 */
Conversation.removed = "removed";
/**
 * Logger instance.
 */
Conversation._logger = logger.Logger.scope("Conversation");
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString, rules.optionalJson),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String, Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], Conversation.prototype, "add", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.nonEmptyString, rules.optionalJson),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String, String, Object, Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], Conversation.prototype, "addNonChatParticipant", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Number]),
    tslib_es6.__metadata("design:returntype", Promise)
], Conversation.prototype, "advanceLastReadMessageIndex", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(["undefined", declarativeTypeValidator.nonNegativeInteger], ["undefined", declarativeTypeValidator.nonNegativeInteger], ["undefined", declarativeTypeValidator.literal("backwards", "forward")]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Number, Number, String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Conversation.prototype, "getMessages", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Conversation.prototype, "getParticipantBySid", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Conversation.prototype, "getParticipantByIdentity", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync([declarativeTypeValidator.nonEmptyString, participant.Participant]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], Conversation.prototype, "removeParticipant", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync([
        "string",
        FormData,
        declarativeTypeValidator.literal(null),
        declarativeTypeValidator.objectSchema("media options", {
            contentType: declarativeTypeValidator.nonEmptyString,
            media: declarativeTypeValidator.custom((value) => {
                let isValid = (typeof value === "string" && value.length > 0) ||
                    value instanceof Uint8Array ||
                    value instanceof ArrayBuffer;
                if (typeof Blob === "function") {
                    isValid = isValid || value instanceof Blob;
                }
                return [
                    isValid,
                    "a non-empty string, an instance of Buffer or an instance of Blob",
                ];
            }),
        }),
    ], rules.optionalJson, [
        "undefined",
        declarativeTypeValidator.literal(null),
        declarativeTypeValidator.objectSchema("email attributes", {
            subject: [declarativeTypeValidator.nonEmptyString, "undefined"],
        }),
    ]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object, Object, Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], Conversation.prototype, "sendMessage", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal("default", "muted")),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Conversation.prototype, "setUserNotificationLevel", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(rules.json),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], Conversation.prototype, "updateAttributes", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync("string"),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Conversation.prototype, "updateFriendlyName", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync([declarativeTypeValidator.literal(null), declarativeTypeValidator.nonNegativeInteger]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Number]),
    tslib_es6.__metadata("design:returntype", Promise)
], Conversation.prototype, "updateLastReadMessageIndex", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(["string", declarativeTypeValidator.literal(null)]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Conversation.prototype, "updateUniqueName", null);

exports.Conversation = Conversation;
//# sourceMappingURL=conversation.js.map

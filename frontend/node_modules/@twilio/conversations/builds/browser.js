/*
@license
The following license applies to all parts of this software except as
documented below.

    Copyright (c) 2019, Twilio, inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.

      3. Neither the name of Twilio nor the names of its contributors may
         be used to endorse or promote products derived from this software
         without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This software includes javascript-state-machine under the following license.

    Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

This software includes loglevel under the following license.

    Copyright (c) 2013 Tim Perry

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

This software includes q under the following license.

    Copyright 2009â€“2014 Kristopher Michael Kowal. All rights reserved.
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.

This software includes platform.js under the following license.

    Copyright 2014 Benjamin Tan <https://d10.github.io/>
    Copyright 2011-2015 John-David Dalton <http://allyoucanleet.com/>

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
    WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
'use strict';

var global =
  typeof global !== "undefined"
    ? global
    : typeof self !== "undefined"
    ? self
    : typeof window !== "undefined"
    ? window
    : {};

Object.defineProperty(exports, '__esModule', { value: true });

require('core-js/modules/es.reflect.to-string-tag.js');
require('core-js/modules/es.reflect.construct.js');
require('core-js/modules/es.object.keys.js');
require('core-js/modules/es.symbol.js');
require('core-js/modules/es.array.filter.js');
require('core-js/modules/es.object.get-own-property-descriptor.js');
require('core-js/modules/es.object.get-own-property-descriptors.js');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');
var _inherits = require('@babel/runtime/helpers/inherits');
var _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _createClass = require('@babel/runtime/helpers/createClass');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
require('core-js/modules/es.object.to-string.js');
require('core-js/modules/es.promise.js');
require('core-js/modules/es.array.map.js');
require('core-js/modules/web.dom-collections.for-each.js');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var _typeof = require('@babel/runtime/helpers/typeof');
require('core-js/modules/es.array.concat.js');
require('core-js/modules/es.array.from.js');
require('core-js/modules/es.string.iterator.js');
var loglevelLog = require('loglevel');
var iso8601Duration = require('iso8601-duration');
require('core-js/modules/es.array.iterator.js');
require('core-js/modules/web.dom-collections.iterator.js');
require('core-js/modules/es.json.stringify.js');
require('core-js/modules/es.number.constructor.js');
require('core-js/modules/es.regexp.exec.js');
require('core-js/modules/es.string.replace.js');
require('core-js/modules/es.array.join.js');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
require('core-js/modules/es.array.includes.js');
var replayEventEmitter = require('@twilio/replay-event-emitter');
var isEqual = require('lodash.isequal');
require('core-js/modules/es.array.slice.js');
require('core-js/modules/es.function.name.js');
require('core-js/modules/es.regexp.test.js');
require('core-js/modules/es.symbol.description.js');
require('core-js/modules/es.symbol.iterator.js');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
require('core-js/modules/es.map.js');
var operationRetrier = require('@twilio/operation-retrier');
var twilsock = require('twilsock');
var notifications = require('@twilio/notifications');
var twilioSync = require('twilio-sync');
var mcsClient = require('@twilio/mcs-client');
require('core-js/modules/es.set.js');
require('core-js/modules/es.number.is-integer.js');
require('core-js/modules/es.typed-array.uint8-array.js');
require('core-js/modules/es.typed-array.at.js');
require('core-js/modules/es.typed-array.copy-within.js');
require('core-js/modules/es.typed-array.every.js');
require('core-js/modules/es.typed-array.fill.js');
require('core-js/modules/es.typed-array.filter.js');
require('core-js/modules/es.typed-array.find.js');
require('core-js/modules/es.typed-array.find-index.js');
require('core-js/modules/es.typed-array.for-each.js');
require('core-js/modules/es.typed-array.includes.js');
require('core-js/modules/es.typed-array.index-of.js');
require('core-js/modules/es.typed-array.iterator.js');
require('core-js/modules/es.typed-array.join.js');
require('core-js/modules/es.typed-array.last-index-of.js');
require('core-js/modules/es.typed-array.map.js');
require('core-js/modules/es.typed-array.reduce.js');
require('core-js/modules/es.typed-array.reduce-right.js');
require('core-js/modules/es.typed-array.reverse.js');
require('core-js/modules/es.typed-array.set.js');
require('core-js/modules/es.typed-array.slice.js');
require('core-js/modules/es.typed-array.some.js');
require('core-js/modules/es.typed-array.sort.js');
require('core-js/modules/es.typed-array.subarray.js');
require('core-js/modules/es.typed-array.to-locale-string.js');
require('core-js/modules/es.typed-array.to-string.js');
require('core-js/modules/es.array-buffer.constructor.js');
require('isomorphic-form-data');
require('core-js/modules/es.array.sort.js');
require('core-js/modules/es.string.includes.js');
require('core-js/modules/es.string.starts-with.js');
var deprecationDecorator = require('@twilio/deprecation-decorator');
require('core-js/modules/es.object.entries.js');
require('core-js/modules/es.array.find.js');
require('core-js/modules/es.array.splice.js');
var _wrapNativeSuper = require('@babel/runtime/helpers/wrapNativeSuper');
var uuid = require('uuid');
require('core-js/modules/es.object.freeze.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);
var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var loglevelLog__namespace = /*#__PURE__*/_interopNamespace(loglevelLog);
var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);
var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var _wrapNativeSuper__default = /*#__PURE__*/_interopDefaultLegacy(_wrapNativeSuper);

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default["default"](Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __metadata(metadataKey, metadataValue) {
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default["default"](Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function prepareLine(prefix, args) {
  return ["".concat(new Date().toISOString(), " Conversations ").concat(prefix, ":")].concat(Array.from(args));
}

var log$7 = loglevelLog__namespace.getLogger("twilio-conversations"); // twilio-conversations is used by Flex SDK. Please DO NOT change

var Logger = /*#__PURE__*/function () {
  function Logger(prefix) {
    _classCallCheck__default["default"](this, Logger);

    _defineProperty__default["default"](this, "prefix", "");

    this.prefix = prefix !== null && prefix !== undefined && prefix.length > 0 ? prefix + " " : "";
  }

  _createClass__default["default"](Logger, [{
    key: "setLevel",
    value: function setLevel(level) {
      log$7.setLevel(level);
    }
  }, {
    key: "trace",
    value: function trace() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      log$7.trace.apply(null, prepareLine(this.prefix + "T", args));
    }
  }, {
    key: "debug",
    value: function debug() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      log$7.debug.apply(null, prepareLine(this.prefix + "D", args));
    }
  }, {
    key: "info",
    value: function info() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      log$7.info.apply(null, prepareLine(this.prefix + "I", args));
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      log$7.warn.apply(null, prepareLine(this.prefix + "W", args));
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      log$7.error.apply(null, prepareLine(this.prefix + "E", args));
    }
  }], [{
    key: "scope",
    value: function scope(prefix) {
      return new Logger(prefix);
    }
  }, {
    key: "setLevel",
    value: function setLevel(level) {
      log$7.setLevel(level);
    }
  }, {
    key: "trace",
    value: function trace() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      log$7.trace.apply(null, prepareLine("T", args));
    }
  }, {
    key: "debug",
    value: function debug() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      log$7.debug.apply(null, prepareLine("D", args));
    }
  }, {
    key: "info",
    value: function info() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      log$7.info.apply(null, prepareLine("I", args));
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      log$7.warn.apply(null, prepareLine("W", args));
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }

      log$7.error.apply(null, prepareLine("E", args));
    }
  }]);

  return Logger;
}();

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var TYPING_TIMEOUT = 5;
var HTTP_CACHE_LIFETIME = "PT5S";
var CONSUMPTION_HORIZON_SENDING_INTERVAL = "PT5S";
var USER_INFOS_TO_SUBSCRIBE = 100;
var MINIMUM_RETRY_DELAY = 1000;
var MAXIMUM_RETRY_DELAY = 4000;
var MAXIMUM_ATTEMPTS_COUNT = 3;
var RETRY_WHEN_THROTTLED = true;

var Configuration = /*#__PURE__*/_createClass__default["default"](function Configuration() {
  var _ref, _constructorOptions$u, _ref2, _constructorOptions$h, _ref3, _constructorOptions$c, _options$channelMetad;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var configurationResponse = arguments.length > 1 ? arguments[1] : undefined;
  var logger = arguments.length > 2 ? arguments[2] : undefined;

  _classCallCheck__default["default"](this, Configuration);

  _defineProperty__default["default"](this, "typingIndicatorTimeoutDefault", TYPING_TIMEOUT * 1000);

  var constructorOptions = options.Chat || options.IPMessaging || options || {};
  this.productId = constructorOptions.productId;
  this.links = {
    myConversations: configurationResponse.links.my_conversations,
    conversations: configurationResponse.links.conversations,
    users: configurationResponse.links.users,
    currentUser: configurationResponse.links.current_user,
    typing: configurationResponse.links.typing,
    mediaService: configurationResponse.links.media_service,
    mediaSetService: configurationResponse.links.media_set_service,
    messagesReceipts: configurationResponse.links.messages_receipts
  };
  this.limits = {
    mediaAttachmentsCountLimit: configurationResponse.options.media_attachments_count_limit,
    mediaAttachmentSizeLimitInMb: configurationResponse.options.media_attachment_size_limit_in_mb,
    mediaAttachmentsTotalSizeLimitInMb: configurationResponse.options.media_attachments_total_size_limit_in_mb,
    emailHistoriesAllowedContentTypes: configurationResponse.options.email_histories_allowed_mime_types,
    emailBodiesAllowedContentTypes: configurationResponse.options.email_bodies_allowed_mime_types
  };
  this.typingIndicatorTimeoutOverride = constructorOptions.typingIndicatorTimeoutOverride;
  this.backoffConfiguration = _objectSpread$5({
    min: MINIMUM_RETRY_DELAY,
    max: MAXIMUM_RETRY_DELAY,
    maxAttemptsCount: MAXIMUM_ATTEMPTS_COUNT
  }, constructorOptions.backoffConfigOverride);
  this.retryWhenThrottled = constructorOptions.retryWhenThrottledOverride !== undefined ? constructorOptions.retryWhenThrottledOverride : RETRY_WHEN_THROTTLED;
  this.userInfosToSubscribe = (_ref = (_constructorOptions$u = constructorOptions.userInfosToSubscribeOverride) !== null && _constructorOptions$u !== void 0 ? _constructorOptions$u : configurationResponse.options.user_infos_to_subscribe) !== null && _ref !== void 0 ? _ref : USER_INFOS_TO_SUBSCRIBE;
  this.reachabilityEnabled = configurationResponse.options.reachability_enabled;
  this.userIdentity = configurationResponse.identity;
  this.userInfo = configurationResponse.sync_objects.my_user_info;
  this.myConversations = configurationResponse.sync_objects.my_conversations;
  var httpCacheInterval = (_ref2 = (_constructorOptions$h = constructorOptions.httpCacheIntervalOverride) !== null && _constructorOptions$h !== void 0 ? _constructorOptions$h : configurationResponse.options.http_cache_interval) !== null && _ref2 !== void 0 ? _ref2 : HTTP_CACHE_LIFETIME;

  try {
    this.httpCacheInterval = iso8601Duration.toSeconds(iso8601Duration.parse(httpCacheInterval));
  } catch (_unused) {
    logger.error("Failed to parse http cache interval ".concat(httpCacheInterval, ", using default value ").concat(HTTP_CACHE_LIFETIME));
    this.httpCacheInterval = iso8601Duration.toSeconds(iso8601Duration.parse(HTTP_CACHE_LIFETIME));
  }

  var consumptionReportInterval = (_ref3 = (_constructorOptions$c = constructorOptions.consumptionReportIntervalOverride) !== null && _constructorOptions$c !== void 0 ? _constructorOptions$c : configurationResponse.options.consumption_report_interval) !== null && _ref3 !== void 0 ? _ref3 : CONSUMPTION_HORIZON_SENDING_INTERVAL;

  try {
    this.consumptionReportInterval = iso8601Duration.toSeconds(iso8601Duration.parse(consumptionReportInterval));
  } catch (_unused2) {
    logger.error("Failed to parse consumption report interval ".concat(consumptionReportInterval, ", using default value ").concat(CONSUMPTION_HORIZON_SENDING_INTERVAL));
    this.consumptionReportInterval = iso8601Duration.toSeconds(iso8601Duration.parse(CONSUMPTION_HORIZON_SENDING_INTERVAL));
  }

  this.channelMetadataCacheCapacity = (_options$channelMetad = options.channelMetadataCacheCapacity) !== null && _options$channelMetad !== void 0 ? _options$channelMetad : 100;
});

/**
 * Deep-clone an object. Note that this does not work on object containing
 * functions.
 * @param {object} obj - the object to deep-clone
 * @returns {object}
 */
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

function parseToNumber(value) {
  if (typeof value !== "undefined" && !isNaN(Number(value))) {
    return Number(value);
  }

  return null;
} // timeString cannot be typed `string` because in member.ts
// call to parseTime(data.lastReadTimestamp) uses number not a string for timestamp.


function parseTime(timeString) {
  try {
    return new Date(timeString);
  } catch (e) {
    return null;
  }
}

function parseAttributes(rawAttributes, warningMessage, log) {
  var attributes = {};

  if (rawAttributes) {
    try {
      attributes = JSON.parse(rawAttributes);
    } catch (e) {
      log.warn(warningMessage, e);
    }
  }

  return attributes;
}
/**
 * Construct URI with query parameters
 */


var UriBuilder = /*#__PURE__*/function () {
  function UriBuilder(base) {
    _classCallCheck__default["default"](this, UriBuilder);

    this.base = base.replace(/\/$/, "");
    this.args = [];
    this.paths = [];
  }

  _createClass__default["default"](UriBuilder, [{
    key: "arg",
    value: function arg(name, value) {
      if (typeof value !== "undefined") {
        this.args.push(encodeURIComponent(name) + "=" + encodeURIComponent(value));
      }

      return this;
    }
  }, {
    key: "path",
    value: function path(name) {
      this.paths.push(encodeURIComponent(name));
      return this;
    }
  }, {
    key: "build",
    value: function build() {
      var result = this.base;

      if (this.paths.length) {
        result += "/" + this.paths.join("/");
      }

      if (this.args.length) {
        result += "?" + this.args.join("&");
      }

      return result;
    }
  }]);

  return UriBuilder;
}();

var json = declarativeTypeValidator.custom(function (value) {
  return [["string", "number", "boolean", "object"].includes(_typeof__default["default"](value)), "a JSON type"];
});
var optionalJson = declarativeTypeValidator.custom(function (value) {
  return [["undefined", "string", "number", "boolean", "object"].includes(_typeof__default["default"](value)), "an optional JSON type"];
});
var sendMediaOptions = declarativeTypeValidator.objectSchema("send media options", {
  contentType: [declarativeTypeValidator.literal(null), "string"],
  filename: ["string", "undefined"],
  media: [declarativeTypeValidator.literal("null"), "string"].concat(_toConsumableArray__default["default"](typeof Buffer === "function" ? [Buffer] : []), _toConsumableArray__default["default"](typeof Blob === "function" ? [Blob] : []))
});

function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf__default["default"](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default["default"](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default["default"](this, result); }; }

function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var log$6 = Logger.scope("User");
/**
 * Extended user information.
 * Note that `isOnline` and `isNotifiable` properties are eligible
 * for use only if the reachability function is enabled.
 * You may check if it is enabled by reading the value of {@link Client.reachabilityEnabled}.
 */

var User = /*#__PURE__*/function (_ReplayEventEmitter) {
  _inherits__default["default"](User, _ReplayEventEmitter);

  var _super = _createSuper$9(User);

  /**
   * @internal
   */
  function User(identity, entityName, configuration, services) {
    var _this;

    _classCallCheck__default["default"](this, User);

    _this = _super.call(this);

    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "promiseToFetch", null);

    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "updated", "updated");

    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "userSubscribed", "userSubscribed");

    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "userUnsubscribed", "userUnsubscribed");

    _this.services = services;
    _this.subscribed = "initializing";

    _this.setMaxListeners(0);

    _this.state = {
      identity: identity,
      entityName: entityName,
      friendlyName: null,
      attributes: {},
      online: null,
      notifiable: null
    };
    _this._initializationPromise = new Promise(function (resolve) {
      _this._resolveInitializationPromise = resolve;
    });

    if (configuration !== null) {
      _this._resolveInitialization(configuration, identity, entityName, false);
    }

    return _this;
  }
  /**
   * Fired when the properties or the reachability status of the message has been updated.
   *
   * Parameters:
   * 1. object `data` - info object provided with the event. It has the following properties:
   *     * {@link User} `user` - the user in question
   *     * {@link UserUpdateReason}[] `updateReasons` - array of reasons for the update
   * @event
   */


  _createClass__default["default"](User, [{
    key: "identity",
    get:
    /**
     * User identity.
     */
    function get() {
      return this.state.identity;
    },
    set: function set(identity) {
      this.state.identity = identity;
    }
  }, {
    key: "entityName",
    set: function set(name) {
      this.state.entityName = name;
    }
    /**
     * Custom attributes of the user.
     */

  }, {
    key: "attributes",
    get: function get() {
      return this.state.attributes;
    }
    /**
     * Friendly name of the user, null if not set.
     */

  }, {
    key: "friendlyName",
    get: function get() {
      return this.state.friendlyName;
    }
    /**
     * Status of the real-time conversation connection of the user.
     */

  }, {
    key: "isOnline",
    get: function get() {
      return this.state.online;
    }
    /**
     * User push notification registration status.
     */

  }, {
    key: "isNotifiable",
    get: function get() {
      return this.state.notifiable;
    }
    /**
     * True if this user is receiving real-time status updates.
     */

  }, {
    key: "isSubscribed",
    get: function get() {
      return this.subscribed == "subscribed";
    } // Handles service updates

  }, {
    key: "_update",
    value: function () {
      var _update2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(key, value) {
        var updateReasons, updateAttributes;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._initializationPromise;

              case 2:
                updateReasons = [];
                log$6.debug("User for", this.state.identity, "updated:", key, value);
                _context.t0 = key;
                _context.next = _context.t0 === "friendlyName" ? 7 : _context.t0 === "attributes" ? 9 : _context.t0 === "reachability" ? 12 : 15;
                break;

              case 7:
                if (this.state.friendlyName !== value.value) {
                  updateReasons.push("friendlyName");
                  this.state.friendlyName = value.value;
                }

                return _context.abrupt("break", 16);

              case 9:
                updateAttributes = parseAttributes(value.value, "Retrieved malformed attributes from the server for user: ".concat(this.state.identity), log$6);

                if (!isEqual__default["default"](this.state.attributes, updateAttributes)) {
                  this.state.attributes = updateAttributes;
                  updateReasons.push("attributes");
                }

                return _context.abrupt("break", 16);

              case 12:
                if (this.state.online !== value.online) {
                  this.state.online = value.online;
                  updateReasons.push("reachabilityOnline");
                }

                if (this.state.notifiable !== value.notifiable) {
                  this.state.notifiable = value.notifiable;
                  updateReasons.push("reachabilityNotifiable");
                }

                return _context.abrupt("break", 16);

              case 15:
                return _context.abrupt("return");

              case 16:
                if (updateReasons.length > 0) {
                  this.emit("updated", {
                    user: this,
                    updateReasons: updateReasons
                  });
                }

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _update(_x, _x2) {
        return _update2.apply(this, arguments);
      }

      return _update;
    }() // Fetch reachability info

  }, {
    key: "_updateReachabilityInfo",
    value: function () {
      var _updateReachabilityInfo2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(map, update) {
        var _this2 = this;

        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._initializationPromise;

              case 2:
                if (this.configuration.reachabilityEnabled) {
                  _context2.next = 4;
                  break;
                }

                return _context2.abrupt("return", Promise.resolve());

              case 4:
                return _context2.abrupt("return", map.get("reachability").then(update).catch(function (err) {
                  log$6.warn("Failed to get reachability info for ", _this2.state.identity, err);
                }));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _updateReachabilityInfo(_x3, _x4) {
        return _updateReachabilityInfo2.apply(this, arguments);
      }

      return _updateReachabilityInfo;
    }() // Fetch user

  }, {
    key: "_fetch",
    value: function () {
      var _fetch2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3() {
        var _this3 = this;

        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._initializationPromise;

              case 2:
                if (this.state.entityName) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return", this);

              case 4:
                this.promiseToFetch = this.services.syncClient.map({
                  id: this.state.entityName,
                  mode: "open_existing",
                  includeItems: true
                }).then(function (map) {
                  _this3.entity = map;
                  map.on("itemUpdated", function (args) {
                    log$6.debug(_this3.state.entityName + " (" + _this3.state.identity + ") itemUpdated: " + args.item.key);
                    return _this3._update(args.item.key, args.item.data);
                  });
                  map.on("itemAdded", function (args) {
                    log$6.debug(_this3.state.entityName + " (" + _this3.state.identity + ") itemAdded: " + args.item.key);
                    return _this3._update(args.item.key, args.item.data);
                  });
                  return Promise.all([map.get("friendlyName").then(function (item) {
                    return _this3._update(item.key, item.data);
                  }), map.get("attributes").then(function (item) {
                    return _this3._update(item.key, item.data);
                  }), _this3._updateReachabilityInfo(map, function (item) {
                    return _this3._update(item.key, item.data);
                  })]);
                }).then(function () {
                  log$6.debug("Fetched for", _this3.identity);
                  _this3.subscribed = "subscribed";

                  _this3.emit("userSubscribed", _this3);

                  return _this3;
                }).catch(function (err) {
                  _this3.promiseToFetch = null;
                  throw err;
                });
                return _context3.abrupt("return", this.promiseToFetch);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _fetch() {
        return _fetch2.apply(this, arguments);
      }

      return _fetch;
    }()
  }, {
    key: "_ensureFetched",
    value: function () {
      var _ensureFetched2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee4() {
        return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._initializationPromise;

              case 2:
                return _context4.abrupt("return", this.promiseToFetch || this._fetch());

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _ensureFetched() {
        return _ensureFetched2.apply(this, arguments);
      }

      return _ensureFetched;
    }()
    /**
     * Edit user attributes.
     * @param attributes New attributes.
     */

  }, {
    key: "updateAttributes",
    value: function () {
      var _updateAttributes = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee5(attributes) {
        return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._initializationPromise;

              case 2:
                if (!(this.subscribed == "unsubscribed")) {
                  _context5.next = 4;
                  break;
                }

                throw new Error("Can't modify unsubscribed object");

              case 4:
                _context5.next = 6;
                return this.services.commandExecutor.mutateResource("post", this.links.self, {
                  attributes: JSON.stringify(attributes)
                });

              case 6:
                return _context5.abrupt("return", this);

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function updateAttributes(_x5) {
        return _updateAttributes.apply(this, arguments);
      }

      return updateAttributes;
    }()
    /**
     * Update the friendly name of the user.
     * @param friendlyName New friendly name.
     */

  }, {
    key: "updateFriendlyName",
    value: function () {
      var _updateFriendlyName = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee6(friendlyName) {
        return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._initializationPromise;

              case 2:
                if (!(this.subscribed == "unsubscribed")) {
                  _context6.next = 4;
                  break;
                }

                throw new Error("Can't modify unsubscribed object");

              case 4:
                _context6.next = 6;
                return this.services.commandExecutor.mutateResource("post", this.links.self, {
                  friendly_name: friendlyName
                });

              case 6:
                return _context6.abrupt("return", this);

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function updateFriendlyName(_x6) {
        return _updateFriendlyName.apply(this, arguments);
      }

      return updateFriendlyName;
    }()
    /**
     * Remove the user from the subscription list.
     * @return A promise of completion.
     */

  }, {
    key: "unsubscribe",
    value: function () {
      var _unsubscribe = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee7() {
        return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._initializationPromise;

              case 2:
                if (!this.promiseToFetch) {
                  _context7.next = 9;
                  break;
                }

                _context7.next = 5;
                return this.promiseToFetch;

              case 5:
                this.entity.close();
                this.promiseToFetch = null;
                this.subscribed = "unsubscribed";
                this.emit("userUnsubscribed", this);

              case 9:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function unsubscribe() {
        return _unsubscribe.apply(this, arguments);
      }

      return unsubscribe;
    }()
  }, {
    key: "_resolveInitialization",
    value: function _resolveInitialization(configuration, identity, entityName, emitUpdated) {
      this.configuration = configuration;
      this.identity = identity;
      this.entityName = entityName;
      this.links = {
        self: "".concat(this.configuration.links.users, "/").concat(encodeURIComponent(this.identity))
      };

      this._resolveInitializationPromise();

      if (emitUpdated) {
        this.emit("updated", {
          user: this,
          updateReasons: ["friendlyName", "attributes", "reachabilityOnline", "reachabilityNotifiable"]
        });
      }
    }
  }]);

  return User;
}(replayEventEmitter.ReplayEventEmitter);

__decorate([declarativeTypeValidator.validateTypesAsync(json), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], User.prototype, "updateAttributes", null);

__decorate([declarativeTypeValidator.validateTypesAsync(["string"]), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], User.prototype, "updateFriendlyName", null);

function _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var Network = /*#__PURE__*/function () {
  function Network(configuration, services) {
    _classCallCheck__default["default"](this, Network);

    this.configuration = configuration;
    this.services = services;
    this.cache = new Map();
    this.cacheLifetime = this.configuration.httpCacheInterval * 100;
    this.cleanupCache();
  }

  _createClass__default["default"](Network, [{
    key: "isExpired",
    value: function isExpired(timestamp) {
      return !this.cacheLifetime || Date.now() - timestamp > this.cacheLifetime;
    }
  }, {
    key: "cleanupCache",
    value: function cleanupCache() {
      var _iterator = _createForOfIteratorHelper$4(this.cache),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray__default["default"](_step.value, 2),
              k = _step$value[0],
              v = _step$value[1];

          if (this.isExpired(v.timestamp)) {
            this.cache.delete(k);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (this.cache.size === 0) {
        clearInterval(this.timer);
      }
    }
  }, {
    key: "pokeTimer",
    value: function pokeTimer() {
      var _this = this;

      this.timer = this.timer || setInterval(function () {
        return _this.cleanupCache();
      }, this.cacheLifetime * 2);
    }
  }, {
    key: "executeWithRetry",
    value: function executeWithRetry(request) {
      var _this2 = this;

      var retryWhenThrottled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return new Promise(function (resolve, reject) {
        var codesToRetryOn = [502, 503, 504];

        if (retryWhenThrottled) {
          codesToRetryOn.push(429);
        }

        var retrier = new operationRetrier.Retrier(_this2.configuration.backoffConfiguration);
        retrier.on("attempt", function () {
          request().then(function (result) {
            return retrier.succeeded(result);
          }).catch(function (err) {
            if (codesToRetryOn.indexOf(err.status) > -1) {
              retrier.failed(err);
            } else if (err.message === "Twilsock disconnected") {
              // Ugly hack. We must make a proper exceptions for twilsock
              retrier.failed(err);
            } else {
              // Fatal error
              retrier.removeAllListeners();
              retrier.cancel();
              reject(err);
            }
          });
        });
        retrier.on("succeeded", function (result) {
          resolve(result);
        });
        retrier.on("cancelled", function (err) {
          return reject(err);
        });
        retrier.on("failed", function (err) {
          return reject(err);
        });
        retrier.start();
      });
    }
  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(url) {
        var _this3 = this;

        var cacheEntry, headers, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cacheEntry = this.cache.get(url);

                if (!(cacheEntry && !this.isExpired(cacheEntry.timestamp))) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return", cacheEntry.response);

              case 3:
                headers = {};
                _context.next = 6;
                return this.executeWithRetry(function () {
                  return _this3.services.transport.get(url, headers, _this3.configuration.productId);
                }, this.configuration.retryWhenThrottled);

              case 6:
                response = _context.sent;
                this.cache.set(url, {
                  response: response,
                  timestamp: Date.now()
                });
                this.pokeTimer();
                return _context.abrupt("return", response);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function get(_x) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
  }]);

  return Network;
}();

var NotificationTypes = /*#__PURE__*/_createClass__default["default"](function NotificationTypes() {
  _classCallCheck__default["default"](this, NotificationTypes);
});

_defineProperty__default["default"](NotificationTypes, "TYPING_INDICATOR", "twilio.ipmsg.typing_indicator");

_defineProperty__default["default"](NotificationTypes, "NEW_MESSAGE", "twilio.conversations.new_message");

_defineProperty__default["default"](NotificationTypes, "ADDED_TO_CONVERSATION", "twilio.conversations.added_to_conversation");

_defineProperty__default["default"](NotificationTypes, "REMOVED_FROM_CONVERSATION", "twilio.conversations.removed_from_conversation");

_defineProperty__default["default"](NotificationTypes, "CONSUMPTION_UPDATE", "twilio.channel.consumption_update");

function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf__default["default"](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default["default"](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default["default"](this, result); }; }

function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var log$5 = Logger.scope("Participant");
/**
 * A participant represents a remote client in a conversation.
 */

var Participant = /*#__PURE__*/function (_ReplayEventEmitter) {
  _inherits__default["default"](Participant, _ReplayEventEmitter);

  var _super = _createSuper$8(Participant);

  /**
   * @internal
   */
  function Participant(data, sid, conversation, links, services) {
    var _data$roleSid, _data$bindings;

    var _this;

    _classCallCheck__default["default"](this, Participant);

    _this = _super.call(this);
    _this.conversation = conversation;
    _this.links = links;
    _this.services = services;
    _this.state = {
      attributes: parseAttributes(data.attributes, "Retrieved malformed attributes from the server for participant: " + sid, log$5),
      dateCreated: data.dateCreated ? parseTime(data.dateCreated) : null,
      dateUpdated: data.dateCreated ? parseTime(data.dateUpdated) : null,
      sid: sid,
      typingTimeout: null,
      isTyping: false,
      identity: data.identity,
      roleSid: (_data$roleSid = data.roleSid) !== null && _data$roleSid !== void 0 ? _data$roleSid : "",
      lastReadMessageIndex: Number.isInteger(data.lastConsumedMessageIndex) ? data.lastConsumedMessageIndex : null,
      lastReadTimestamp: data.lastConsumptionTimestamp ? parseTime(data.lastConsumptionTimestamp) : null,
      type: data.type || "chat",
      userInfo: data.userInfo,
      bindings: (_data$bindings = data.bindings) !== null && _data$bindings !== void 0 ? _data$bindings : {}
    };

    if (!data.identity && !data.type) {
      throw new Error("Received invalid Participant object from server: Missing identity or type of Participant.");
    }

    return _this;
  }
  /**
   * Fired when the participant has started typing.
   *
   * Parameters:
   * 1. {@link Participant} `participant` - the participant in question
   * @event
   */


  _createClass__default["default"](Participant, [{
    key: "sid",
    get:
    /**
     * Conversation that the remote client is a participant of.
     */

    /**
     * The server-assigned unique identifier for the participant.
     */
    function get() {
      return this.state.sid;
    }
    /**
     * Custom attributes of the participant.
     */

  }, {
    key: "attributes",
    get: function get() {
      return this.state.attributes;
    }
    /**
     * Date this participant was created on.
     */

  }, {
    key: "dateCreated",
    get: function get() {
      return this.state.dateCreated;
    }
    /**
     * Date this participant was last updated on.
     */

  }, {
    key: "dateUpdated",
    get: function get() {
      return this.state.dateUpdated;
    }
    /**
     * Identity of the participant.
     */

  }, {
    key: "identity",
    get: function get() {
      return this.state.identity;
    }
    /**
     * Indicates whether the participant is currently typing.
     */

  }, {
    key: "isTyping",
    get: function get() {
      return this.state.isTyping;
    }
    /**
     * The index of the last read message by the participant.
     * Note that retrieving messages on a client endpoint does not mean that messages are read,
     * please consider reading about the [Read Horizon feature](https://www.twilio.com/docs/api/chat/guides/consumption-horizon)
     * to find out about the proper way to mark messages as read.
     */

  }, {
    key: "lastReadMessageIndex",
    get: function get() {
      return this.state.lastReadMessageIndex;
    }
    /**
     * Date of the most recent read horizon update.
     */

  }, {
    key: "lastReadTimestamp",
    get: function get() {
      return this.state.lastReadTimestamp;
    }
  }, {
    key: "roleSid",
    get: function get() {
      return this.state.roleSid;
    }
    /**
     * Type of the participant.
     */

  }, {
    key: "type",
    get: function get() {
      return this.state.type;
    }
    /**
     * Get the bindings mapping for the current participant.
     * Available binding depends on the participant type.
     * You could access it as `participant.bindings.sms?.address` or
     * using the type dynamically `participant.bindings[participant.type]`
     * just be aware that the binding information has different structure for
     * each participant type.
     * See also {ParticipantEmailBinding}, the only available currently binding descriptor.
     */

  }, {
    key: "bindings",
    get: function get() {
      var _this$state$bindings;

      return (_this$state$bindings = this.state.bindings) !== null && _this$state$bindings !== void 0 ? _this$state$bindings : {};
    }
  }, {
    key: "_startTyping",
    value:
    /**
     * Internal method used to start or reset the typing indicator timeout (with event emitting).
     * @internal
     */
    function _startTyping(timeout) {
      var _this2 = this;

      if (this.state.typingTimeout) {
        clearTimeout(this.state.typingTimeout);
      }

      this.state.isTyping = true;
      this.emit("typingStarted", this);
      this.conversation.emit("typingStarted", this);
      this.state.typingTimeout = Number(setTimeout(function () {
        return _this2._endTyping();
      }, timeout));
      return this;
    }
    /**
     * Internal method function used to stop the typing indicator timeout (with event emitting).
     * @internal
     */

  }, {
    key: "_endTyping",
    value: function _endTyping() {
      if (!this.state.typingTimeout) {
        return;
      }

      this.state.isTyping = false;
      this.emit("typingEnded", this);
      this.conversation.emit("typingEnded", this);
      clearInterval(this.state.typingTimeout);
      this.state.typingTimeout = null;
    }
    /**
     * Internal method function used update local object's property roleSid with a new value.
     * @internal
     */

  }, {
    key: "_update",
    value: function _update(data) {
      var updateReasons = [];
      var updateAttributes = parseAttributes(data.attributes, "Retrieved malformed attributes from the server for participant: " + this.state.sid, log$5);

      if (data.attributes && !isEqual__default["default"](this.state.attributes, updateAttributes)) {
        this.state.attributes = updateAttributes;
        updateReasons.push("attributes");
      }

      var updatedDateUpdated = parseTime(data.dateUpdated);

      if (data.dateUpdated && (updatedDateUpdated === null || updatedDateUpdated === void 0 ? void 0 : updatedDateUpdated.getTime()) !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {
        this.state.dateUpdated = updatedDateUpdated;
        updateReasons.push("dateUpdated");
      }

      var updatedDateCreated = parseTime(data.dateCreated);

      if (data.dateCreated && (updatedDateCreated === null || updatedDateCreated === void 0 ? void 0 : updatedDateCreated.getTime()) !== (this.state.dateCreated && this.state.dateCreated.getTime())) {
        this.state.dateCreated = updatedDateCreated;
        updateReasons.push("dateCreated");
      }

      if (data.roleSid && this.state.roleSid !== data.roleSid) {
        this.state.roleSid = data.roleSid;
        updateReasons.push("roleSid");
      }

      if ((Number.isInteger(data.lastConsumedMessageIndex) || data.lastConsumedMessageIndex === null) && this.state.lastReadMessageIndex !== data.lastConsumedMessageIndex) {
        this.state.lastReadMessageIndex = data.lastConsumedMessageIndex;
        updateReasons.push("lastReadMessageIndex");
      }

      if (data.lastConsumptionTimestamp) {
        var lastReadTimestamp = new Date(data.lastConsumptionTimestamp);

        if (!this.state.lastReadTimestamp || this.state.lastReadTimestamp.getTime() !== lastReadTimestamp.getTime()) {
          this.state.lastReadTimestamp = lastReadTimestamp;
          updateReasons.push("lastReadTimestamp");
        }
      }

      if (data.bindings && !isEqual__default["default"](this.state.bindings, data.bindings)) {
        this.state.bindings = data.bindings;
        updateReasons.push("bindings");
      }

      if (updateReasons.length > 0) {
        this.emit("updated", {
          participant: this,
          updateReasons: updateReasons
        });
      }

      return this;
    }
    /**
     * Get the user for this participant and subscribes to it. Supported only for participants of type `chat`.
     */

  }, {
    key: "getUser",
    value: function () {
      var _getUser = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee() {
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this.type != "chat")) {
                  _context.next = 2;
                  break;
                }

                throw new Error("Getting User is not supported for this Participant type: " + this.type);

              case 2:
                return _context.abrupt("return", this.services.users.getUser(this.state.identity, this.state.userInfo));

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getUser() {
        return _getUser.apply(this, arguments);
      }

      return getUser;
    }()
    /**
     * Remove the participant from the conversation.
     */

  }, {
    key: "remove",
    value: function () {
      var _remove = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2() {
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.conversation.removeParticipant(this));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function remove() {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
    /**
     * Update the attributes of the participant.
     * @param attributes New attributes.
     */

  }, {
    key: "updateAttributes",
    value: function () {
      var _updateAttributes = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3(attributes) {
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.services.commandExecutor.mutateResource("post", this.links.self, {
                  attributes: JSON.stringify(attributes)
                });

              case 2:
                return _context3.abrupt("return", this);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function updateAttributes(_x) {
        return _updateAttributes.apply(this, arguments);
      }

      return updateAttributes;
    }()
  }]);

  return Participant;
}(replayEventEmitter.ReplayEventEmitter);

_defineProperty__default["default"](Participant, "typingStarted", "typingStarted");

_defineProperty__default["default"](Participant, "typingEnded", "typingEnded");

_defineProperty__default["default"](Participant, "updated", "updated");

__decorate([declarativeTypeValidator.validateTypesAsync(json), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Participant.prototype, "updateAttributes", null);

function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf__default["default"](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default["default"](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default["default"](this, result); }; }

function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var log$4 = Logger.scope("Participants");
/**
 * @classdesc Represents the collection of participants for the conversation
 * @fires Participants#participantJoined
 * @fires Participants#participantLeft
 * @fires Participants#participantUpdated
 */

var Participants = /*#__PURE__*/function (_ReplayEventEmitter) {
  _inherits__default["default"](Participants, _ReplayEventEmitter);

  var _super = _createSuper$7(Participants);

  function Participants(conversation, participants, links, configuration, services) {
    var _this;

    _classCallCheck__default["default"](this, Participants);

    _this = _super.call(this);

    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "rosterEntityPromise", null);

    _this.conversation = conversation;
    _this.participants = participants;
    _this.links = links;
    _this.configuration = configuration;
    _this.services = services;
    return _this;
  }

  _createClass__default["default"](Participants, [{
    key: "unsubscribe",
    value: function () {
      var _unsubscribe = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee() {
        var entity;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.rosterEntityPromise) {
                  _context.next = 6;
                  break;
                }

                _context.next = 3;
                return this.rosterEntityPromise;

              case 3:
                entity = _context.sent;
                entity.close();
                this.rosterEntityPromise = null;

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function unsubscribe() {
        return _unsubscribe.apply(this, arguments);
      }

      return unsubscribe;
    }()
  }, {
    key: "subscribe",
    value: function subscribe(arg) {
      var _this2 = this;

      var participantsMapPromise = typeof arg === "string" ? this.services.syncClient.map({
        id: arg,
        mode: "open_existing"
      }) : Promise.resolve(arg);
      return this.rosterEntityPromise = this.rosterEntityPromise || participantsMapPromise.then(function (rosterMap) {
        rosterMap.on("itemAdded", function (args) {
          log$4.debug(_this2.conversation.sid + " itemAdded: " + args.item.key);

          _this2.upsertParticipant(args.item.key, args.item.data).then(function (participant) {
            _this2.emit("participantJoined", participant);
          });
        });
        rosterMap.on("itemRemoved", function (args) {
          log$4.debug(_this2.conversation.sid + " itemRemoved: " + args.key);
          var participantSid = args.key;

          if (!_this2.participants.has(participantSid)) {
            return;
          }

          var leftParticipant = _this2.participants.get(participantSid);

          _this2.participants.delete(participantSid);

          if (!leftParticipant) {
            return;
          }

          _this2.emit("participantLeft", leftParticipant);
        });
        rosterMap.on("itemUpdated", function (args) {
          log$4.debug(_this2.conversation.sid + " itemUpdated: " + args.item.key);

          _this2.upsertParticipant(args.item.key, args.item.data);
        });
        var participantsPromises = [];

        var rosterMapHandler = function rosterMapHandler(paginator) {
          paginator.items.forEach(function (item) {
            participantsPromises.push(_this2.upsertParticipant(item.key, item.data));
          });
          return paginator.hasNextPage ? paginator.nextPage().then(rosterMapHandler) : null;
        };

        return rosterMap.getItems().then(rosterMapHandler).then(function () {
          return Promise.all(participantsPromises);
        }).then(function () {
          return rosterMap;
        });
      }).catch(function (err) {
        _this2.rosterEntityPromise = null;

        if (_this2.services.syncClient.connectionState != "disconnected") {
          log$4.error("Failed to get roster object for conversation", _this2.conversation.sid, err);
        }

        log$4.debug("ERROR: Failed to get roster object for conversation", _this2.conversation.sid, err);
        throw err;
      });
    }
  }, {
    key: "upsertParticipantFromResponse",
    value: function () {
      var _upsertParticipantFromResponse = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(data) {
        var _messagingBinding$typ;

        var sid, responseAttributes, dateCreated, dateUpdated, responseIdentity, roleSid, messagingBinding;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                sid = data.sid, responseAttributes = data.attributes, dateCreated = data.date_created, dateUpdated = data.date_updated, responseIdentity = data.identity, roleSid = data.role_sid, messagingBinding = data.messaging_binding;
                _context2.next = 3;
                return this.upsertParticipant(sid, {
                  attributes: responseAttributes,
                  dateCreated: new Date(dateCreated),
                  dateUpdated: new Date(dateUpdated),
                  identity: responseIdentity,
                  roleSid: roleSid,
                  lastConsumedMessageIndex: null,
                  lastConsumptionTimestamp: null,
                  type: (_messagingBinding$typ = messagingBinding === null || messagingBinding === void 0 ? void 0 : messagingBinding.type) !== null && _messagingBinding$typ !== void 0 ? _messagingBinding$typ : "chat"
                });

              case 3:
                return _context2.abrupt("return", _context2.sent);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function upsertParticipantFromResponse(_x) {
        return _upsertParticipantFromResponse.apply(this, arguments);
      }

      return upsertParticipantFromResponse;
    }()
  }, {
    key: "upsertParticipant",
    value: function () {
      var _upsertParticipant = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3(participantSid, data) {
        var _this3 = this;

        var participant, links;
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                participant = this.participants.get(participantSid);

                if (!participant) {
                  _context3.next = 3;
                  break;
                }

                return _context3.abrupt("return", participant._update(data));

              case 3:
                links = {
                  self: "".concat(this.links.participants, "/").concat(participantSid)
                };
                participant = new Participant(data, participantSid, this.conversation, links, this.services);
                this.participants.set(participantSid, participant);
                participant.on("updated", function (args) {
                  return _this3.emit("participantUpdated", args);
                });
                return _context3.abrupt("return", participant);

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function upsertParticipant(_x2, _x3) {
        return _upsertParticipant.apply(this, arguments);
      }

      return upsertParticipant;
    }()
    /**
     * @returns {Promise<Array<Participant>>} returns list of participants {@see Participant}
     */

  }, {
    key: "getParticipants",
    value: function () {
      var _getParticipants = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee4() {
        var _this4 = this;

        return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", this.rosterEntityPromise ? this.rosterEntityPromise.then(function () {
                  var participants = [];

                  _this4.participants.forEach(function (participant) {
                    return participants.push(participant);
                  });

                  return participants;
                }) : []);

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getParticipants() {
        return _getParticipants.apply(this, arguments);
      }

      return getParticipants;
    }()
    /**
     * Get participant by SID from conversation
     * @returns {Promise<Participant>}
     */

  }, {
    key: "getParticipantBySid",
    value: function () {
      var _getParticipantBySid = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee5(participantSid) {
        var _this5 = this;

        return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this.rosterEntityPromise ? this.rosterEntityPromise.then(function () {
                  var participant = _this5.participants.get(participantSid);

                  if (!participant) {
                    throw new Error("Participant with SID " + participantSid + " was not found");
                  }

                  return participant;
                }) : null);

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getParticipantBySid(_x4) {
        return _getParticipantBySid.apply(this, arguments);
      }

      return getParticipantBySid;
    }()
    /**
     * Get participant by identity from conversation
     * @returns {Promise<Participant>}
     */

  }, {
    key: "getParticipantByIdentity",
    value: function () {
      var _getParticipantByIdentity = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee6(identity) {
        var _this6 = this;

        var foundParticipant;
        return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                foundParticipant = null;
                return _context6.abrupt("return", this.rosterEntityPromise ? this.rosterEntityPromise.then(function () {
                  _this6.participants.forEach(function (participant) {
                    if (participant.identity === identity) {
                      foundParticipant = participant;
                    }
                  });

                  if (!foundParticipant) {
                    throw new Error("Participant with identity " + identity + " was not found");
                  }

                  return foundParticipant;
                }) : null);

              case 2:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getParticipantByIdentity(_x5) {
        return _getParticipantByIdentity.apply(this, arguments);
      }

      return getParticipantByIdentity;
    }()
    /**
     * Add a chat participant to the conversation
     */

  }, {
    key: "add",
    value: function () {
      var _add = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee7(identity, attributes) {
        return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.services.commandExecutor.mutateResource("post", this.links.participants, {
                  identity: identity,
                  attributes: typeof attributes !== "undefined" ? JSON.stringify(attributes) : undefined
                });

              case 2:
                return _context7.abrupt("return", _context7.sent);

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function add(_x6, _x7) {
        return _add.apply(this, arguments);
      }

      return add;
    }()
    /**
     * Add a non-chat participant to the conversation.
     */

  }, {
    key: "addNonChatParticipant",
    value: function () {
      var _addNonChatParticipant = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee8(proxyAddress, address) {
        var _bindingOptions$email, _bindingOptions$email2;

        var attributes,
            bindingOptions,
            _args8 = arguments;
        return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                attributes = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : {};
                bindingOptions = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : {};
                _context8.next = 4;
                return this.services.commandExecutor.mutateResource("post", this.links.participants, {
                  attributes: typeof attributes !== "undefined" ? JSON.stringify(attributes) : undefined,
                  messaging_binding: {
                    address: address,
                    proxy_address: proxyAddress,
                    name: bindingOptions === null || bindingOptions === void 0 ? void 0 : (_bindingOptions$email = bindingOptions.email) === null || _bindingOptions$email === void 0 ? void 0 : _bindingOptions$email.name,
                    level: bindingOptions === null || bindingOptions === void 0 ? void 0 : (_bindingOptions$email2 = bindingOptions.email) === null || _bindingOptions$email2 === void 0 ? void 0 : _bindingOptions$email2.level
                  }
                });

              case 4:
                return _context8.abrupt("return", _context8.sent);

              case 5:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function addNonChatParticipant(_x8, _x9) {
        return _addNonChatParticipant.apply(this, arguments);
      }

      return addNonChatParticipant;
    }()
    /**
     * Remove the participant with a given identity from a conversation.
     */

  }, {
    key: "remove",
    value: function remove(identity) {
      return this.services.commandExecutor.mutateResource("delete", "".concat(this.links.participants, "/").concat(encodeURIComponent(identity)));
    }
  }]);

  return Participants;
}(replayEventEmitter.ReplayEventEmitter);
/**
 * Fired when participant joined conversation
 * @event Participants#participantJoined
 * @type {Participant}
 */

/**
 * Fired when participant left conversation
 * @event Participants#participantLeft
 * @type {Participant}
 */

/**
 * Fired when participant updated
 * @event Participants#participantUpdated
 * @type {Object}
 * @property {Participant} participant - Updated Participant
 * @property {Participant#UpdateReason[]} updateReasons - Array of Participant's updated event reasons
 */

/**
 * Represents a media information for a message in a conversation.
 */

var Media = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function Media(data, services) {
    _classCallCheck__default["default"](this, Media);

    _defineProperty__default["default"](this, "mcsMedia", null);

    this.services = services;

    if (data instanceof mcsClient.McsMedia) {
      this.mcsMedia = data;
    }

    this.state = {
      sid: data.sid,
      category: data.category,
      filename: data.filename,
      contentType: data.contentType,
      size: data.size
    };
  }
  /**
   * Server-assigned unique identifier for the media.
   */


  _createClass__default["default"](Media, [{
    key: "sid",
    get: function get() {
      return this.state.sid;
    }
    /**
     * File name. Null if absent.
     */

  }, {
    key: "filename",
    get: function get() {
      return this.state.filename;
    }
    /**
     * Content type of the media.
     */

  }, {
    key: "contentType",
    get: function get() {
      return this.state.contentType;
    }
    /**
     * Size of the media in bytes.
     */

  }, {
    key: "size",
    get: function get() {
      return this.state.size;
    }
    /**
     * Media category, can be one of the {@link MediaCategory} values.
     */

  }, {
    key: "category",
    get: function get() {
      return this.state.category;
    }
    /**
     * Returns the direct content URL for the media.
     *
     * This URL is impermanent, it will expire in several minutes and cannot be cached.
     * If the URL becomes expired, you need to request a new one.
     * Each call to this function produces a new temporary URL.
     */

  }, {
    key: "getContentTemporaryUrl",
    value: function getContentTemporaryUrl() {
      var _this = this;

      return new mcsClient.CancellablePromise( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(resolve, reject, onCancel) {
          var _this$mcsMedia;

          var fetchMediaRequest, contentUrlRequest, mcsMedia;
          return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  fetchMediaRequest = _this._fetchMcsMedia();
                  contentUrlRequest = (_this$mcsMedia = _this.mcsMedia) === null || _this$mcsMedia === void 0 ? void 0 : _this$mcsMedia.getContentUrl();
                  onCancel(function () {
                    fetchMediaRequest.cancel();

                    if (contentUrlRequest) {
                      contentUrlRequest.cancel();
                    }
                  });
                  _context.prev = 3;

                  if (_this.mcsMedia) {
                    _context.next = 9;
                    break;
                  }

                  _context.next = 7;
                  return fetchMediaRequest;

                case 7:
                  mcsMedia = _context.sent;
                  contentUrlRequest = mcsMedia.getContentUrl();

                case 9:
                  _context.t0 = resolve;

                  if (!contentUrlRequest) {
                    _context.next = 16;
                    break;
                  }

                  _context.next = 13;
                  return contentUrlRequest;

                case 13:
                  _context.t1 = _context.sent;
                  _context.next = 17;
                  break;

                case 16:
                  _context.t1 = null;

                case 17:
                  _context.t2 = _context.t1;
                  (0, _context.t0)(_context.t2);
                  _context.next = 24;
                  break;

                case 21:
                  _context.prev = 21;
                  _context.t3 = _context["catch"](3);
                  reject(_context.t3);

                case 24:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[3, 21]]);
        }));

        return function (_x, _x2, _x3) {
          return _ref.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "_fetchMcsMedia",
    value: function _fetchMcsMedia() {
      var _this2 = this;

      return new mcsClient.CancellablePromise( /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(resolve, reject, onCancel) {
          var request;
          return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  request = _this2.services.mcsClient.get(_this2.state.sid);

                  if (!_this2.services.mcsClient) {
                    _context2.next = 14;
                    break;
                  }

                  onCancel(function () {
                    return request.cancel();
                  });
                  _context2.prev = 3;
                  _context2.next = 6;
                  return request;

                case 6:
                  _this2.mcsMedia = _context2.sent;
                  resolve(_this2.mcsMedia);
                  _context2.next = 13;
                  break;

                case 10:
                  _context2.prev = 10;
                  _context2.t0 = _context2["catch"](3);
                  reject(_context2.t0);

                case 13:
                  return _context2.abrupt("return");

                case 14:
                  reject(new Error("Media Content Service is unavailable"));

                case 15:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[3, 10]]);
        }));

        return function (_x4, _x5, _x6) {
          return _ref2.apply(this, arguments);
        };
      }());
    }
  }]);

  return Media;
}();

/**
 * Contains aggregated information about delivery statuses of a message across all participants
 * of a conversation.
 *
 * At any moment during the message delivery to a participant, the message can have zero or more of the following
 * delivery statuses:
 * * Message is considered as **sent** to a participant if the nearest upstream carrier accepted the message.
 * * Message is considered as **delivered** to a participant if Twilio has received confirmation of message
 * delivery from the upstream carrier, and, where available, the destination handset.
 * * Message considered as **undelivered** to a participant if Twilio has received a delivery receipt
 * indicating that the message was not delivered. This can happen for many reasons including carrier content
 * filtering and the availability of the destination handset.
 * * Message considered as **read** by a participant if the message has been delivered and opened by the
 * recipient in a conversation. The recipient must have enabled the read receipts.
 * * Message considered as **failed** to be delivered to a participant if the message could not be sent.
 * This can happen for various reasons including queue overflows, account suspensions and media
 * errors (in the case of MMS for instance).
 *
 * {@link AggregatedDeliveryReceipt} class contains an aggregated value {@link DeliveryAmount} for each delivery status.
 */
var AggregatedDeliveryReceipt = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function AggregatedDeliveryReceipt(data) {
    _classCallCheck__default["default"](this, AggregatedDeliveryReceipt);

    this.state = data;
  }
  /**
   * Maximum number of delivery events expected for the message.
   */


  _createClass__default["default"](AggregatedDeliveryReceipt, [{
    key: "total",
    get: function get() {
      return this.state.total;
    }
    /**
     * Message is considered as **sent** to a participant if the nearest upstream carrier accepted the message.
     *
     * @return Amount of participants that have the **sent** delivery status for the message.
     */

  }, {
    key: "sent",
    get: function get() {
      return this.state.sent;
    }
    /**
     * Message is considered as **delivered** to a participant if Twilio has received confirmation of message
     * delivery from the upstream carrier, and, where available, the destination handset.
     *
     * @return Amount of participants that have the **delivered** delivery status for the message.
     */

  }, {
    key: "delivered",
    get: function get() {
      return this.state.delivered;
    }
    /**
     * Message is considered as **read** by a participant, if the message has been delivered and opened by the
     * recipient in a conversation. The recipient must have enabled the read receipts.
     *
     * @return Amount of participants that have the **read** delivery status for the message.
     */

  }, {
    key: "read",
    get: function get() {
      return this.state.read;
    }
    /**
     * Message is considered as **undelivered** to a participant if Twilio has received a delivery receipt
     * indicating that the message was not delivered. This can happen for many reasons including carrier content
     * filtering and the availability of the destination handset.
     *
     * @return Ammount of participants that have the **undelivered** delivery status for the message.
     */

  }, {
    key: "undelivered",
    get: function get() {
      return this.state.undelivered;
    }
    /**
     * Message is considered as **failed** to be delivered to a participant if the message could not be sent.
     * This can happen for various reasons including queue overflows, account suspensions and media
     * errors (in the case of MMS for instance). Twilio does not charge you for failed messages.
     *
     * @return Amount of participants that have the **failed** delivery status for the message.
     */

  }, {
    key: "failed",
    get: function get() {
      return this.state.failed;
    }
  }, {
    key: "_update",
    value: function _update(data) {
      this.state = data;
    }
  }, {
    key: "_isEquals",
    value: function _isEquals(data) {
      var isTotalSame = this.total === data.total;
      var isSentSame = this.sent === data.sent;
      var isDeliveredSame = this.delivered === data.delivered;
      var isReadSame = this.read === data.read;
      var isUndeliveredSame = this.undelivered === data.undelivered;
      var isFailedSame = this.failed === data.failed;
      return isTotalSame && isSentSame && isDeliveredSame && isReadSame && isUndeliveredSame && isFailedSame;
    }
  }]);

  return AggregatedDeliveryReceipt;
}();

/**
 * Pagination helper class.
 */
var RestPaginator = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function RestPaginator(items, source, prevToken, nextToken) {
    _classCallCheck__default["default"](this, RestPaginator);

    this.state = {
      prevToken: prevToken,
      nextToken: nextToken,
      source: source,
      items: items
    };
  }
  /**
   * Request the next page. Does not modify the existing object.
   */


  _createClass__default["default"](RestPaginator, [{
    key: "hasNextPage",
    get:
    /**
     * Indicates the existence of the next page.
     */
    function get() {
      return !!this.state.nextToken;
    }
    /**
     * Indicates the existence of the previous page
     */

  }, {
    key: "hasPrevPage",
    get: function get() {
      return !!this.state.prevToken;
    }
    /**
     * Array of elements on the current page.
     */

  }, {
    key: "items",
    get: function get() {
      return this.state.items;
    }
  }, {
    key: "nextPage",
    value: function nextPage() {
      return this.hasNextPage ? this.state.source(this.state.nextToken) : Promise.reject(new Error("No next page"));
    }
    /**
     * Request the previous page. Does not modify the existing object.
     */

  }, {
    key: "prevPage",
    value: function prevPage() {
      return this.hasPrevPage ? this.state.source(this.state.prevToken) : Promise.reject(new Error("No previous page"));
    }
  }]);

  return RestPaginator;
}();

/**
 * Represents a delivery receipt of a message.
 */
var DetailedDeliveryReceipt = /*#__PURE__*/_createClass__default["default"](
/**
 * Unique identifier for the delivery receipt.
 */

/**
 * Unique identifier for the message in the conversation.
 */

/**
 * Unique identifier for the conversation.
 */

/**
 * Unique identifier for the `â€˜channelâ€™` message (e.g., `WAxx` for WhatsApp, `SMxx` for SMS).
 */

/**
 * Unique identifier for the participant.
 */

/**
 * Status of the message delivery.
 */

/**
 * Numeric error code mapped from Status callback code. Information about the error codes can be found
 * [here](https://www.twilio.com/docs/sms/api/message-resource#delivery-related-errors).
 */

/**
 * Date this delivery receipt was created on.
 */

/**
 * Date this delivery receipt was last updated on.
 */

/**
 * @internal
 */
function DetailedDeliveryReceipt(descriptor) {
  _classCallCheck__default["default"](this, DetailedDeliveryReceipt);

  this.sid = descriptor.sid;
  this.messageSid = descriptor.message_sid;
  this.conversationSid = descriptor.conversation_sid;
  this.channelMessageSid = descriptor.channel_message_sid;
  this.participantSid = descriptor.participant_sid;
  this.status = descriptor.status || "queued";
  this.errorCode = descriptor.error_code || 0;
  this.dateCreated = descriptor.date_created;
  this.dateUpdated = descriptor.date_updated;
});

var collectActions = function collectActions(actions) {
  return actions.map(function (action) {
    var _action$id, _action$index, _action$phone, _action$url;

    var rawData = JSON.stringify(action);

    switch (action.type) {
      case "QUICK_REPLY":
        return {
          type: "reply",
          title: action.title,
          id: (_action$id = action.id) !== null && _action$id !== void 0 ? _action$id : "",
          index: (_action$index = action.index) !== null && _action$index !== void 0 ? _action$index : 0,
          rawData: rawData
        };

      case "PHONE_NUMBER":
        return {
          type: "phone",
          title: action.title,
          phone: (_action$phone = action.phone) !== null && _action$phone !== void 0 ? _action$phone : "",
          rawData: rawData
        };

      case "URL":
        return {
          type: "url",
          title: action.title,
          url: (_action$url = action.url) !== null && _action$url !== void 0 ? _action$url : "",
          rawData: rawData
        };

      default:
        return {
          type: "other",
          rawData: rawData
        };
    }
  });
};

var parseVariant = function parseVariant(type, data) {
  var rawData = JSON.stringify(data);

  switch (type) {
    case "twilio/text":
      {
        var variant = data;
        return {
          type: "text",
          body: variant.body,
          rawData: rawData
        };
      }

    case "twilio/media":
      {
        var _variant = data;
        return {
          type: "media",
          body: _variant.body,
          media: _variant.media,
          rawData: rawData
        };
      }

    case "twilio/location":
      {
        var _variant2 = data;
        return {
          type: "location",
          longitude: _variant2.longitude,
          latitude: _variant2.latitude,
          label: _variant2.label,
          rawData: rawData
        };
      }

    case "twilio/quick-reply":
      {
        var _variant3 = data;
        return {
          type: "quickReply",
          body: _variant3.body,
          replies: _variant3.actions,
          rawData: rawData
        };
      }

    case "twilio/call-to-action":
      {
        var _variant4 = data;
        return {
          type: "callToAction",
          body: _variant4.body,
          actions: collectActions(_variant4.actions),
          rawData: rawData
        };
      }

    case "twilio/list-picker":
      {
        var _variant5 = data;
        return {
          type: "listPicker",
          body: _variant5.body,
          button: _variant5.button,
          items: _variant5.items,
          rawData: rawData
        };
      }

    case "twilio/card":
      {
        var _variant6$media, _variant6$actions;

        var _variant6 = data;
        return {
          type: "card",
          title: _variant6.title,
          subtitle: _variant6.subtitle,
          media: (_variant6$media = _variant6.media) !== null && _variant6$media !== void 0 ? _variant6$media : [],
          actions: collectActions((_variant6$actions = _variant6.actions) !== null && _variant6$actions !== void 0 ? _variant6$actions : []),
          rawData: rawData
        };
      }

    default:
      return {
        type: "other",
        rawData: rawData
      };
  }
};

var collectVariants = function collectVariants(variants) {
  var variantsMap = new Map();

  for (var _i = 0, _Object$entries = Object.entries(variants); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray__default["default"](_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];

    variantsMap.set(key, parseVariant(key, value));
  }

  return variantsMap;
};
/**
 * Represents a variable for a content template. See
 * {@link ContentTemplate.variables}.
 */


var ContentTemplateVariable = /*#__PURE__*/function () {
  function ContentTemplateVariable(
  /**
   * Name of the variable.
   */
  name,
  /**
   * Key of the variable
   */
  value) {
    _classCallCheck__default["default"](this, ContentTemplateVariable);

    this.name = name;
    this.value = value;
  }
  /**
   * Copies the variable with a new value.
   *
   * @param value The new value for the variable.
   */


  _createClass__default["default"](ContentTemplateVariable, [{
    key: "copyWithValue",
    value: function copyWithValue(value) {
      return new ContentTemplateVariable(this.name, value);
    }
  }]);

  return ContentTemplateVariable;
}();
/**
 * A rich content template.
 *
 * Use {@Link Client.getContentTemplates} to request all the templates available
 * for the current account.
 */


var ContentTemplate = /*#__PURE__*/_createClass__default["default"](
/**
 * The server-assigned unique identifier for the template.
 */

/**
 * Friendly name used to describe the content. Not visible to the recipient.
 */

/**
 * Variables used by this template.
 */

/**
 * Variants of the content. See {@link ContentData}.
 */

/**
 * Date of creation.
 */

/**
 * Date of the last update.
 */

/**
 * @internal
 */
function ContentTemplate(contentTemplateResponse) {
  _classCallCheck__default["default"](this, ContentTemplate);

  this.sid = contentTemplateResponse.sid;
  this.friendlyName = contentTemplateResponse.friendly_name;
  this.variables = Object.entries(JSON.parse(contentTemplateResponse.variables)).map(function (_ref) {
    var _ref2 = _slicedToArray__default["default"](_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    return new ContentTemplateVariable(key, value);
  });
  this.variants = collectVariants(contentTemplateResponse.variants);
  this.dateCreated = new Date(contentTemplateResponse.date_created);
  this.dateUpdated = new Date(contentTemplateResponse.date_updated);
});

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf__default["default"](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default["default"](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default["default"](this, result); }; }

function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var log$3 = Logger.scope("Message");

var XHR = // eslint-disable-next-line @typescript-eslint/no-var-requires
global["XMLHttpRequest"] || {};
/**
 * A message in a conversation.
 */


var Message = /*#__PURE__*/function (_ReplayEventEmitter) {
  _inherits__default["default"](Message, _ReplayEventEmitter);

  var _super = _createSuper$6(Message);

  /**
   * Conversation that the message is in.
   */

  /**
   * @internal
   */
  function Message(index, data, conversation, links, configuration, services) {
    var _data$text, _data$lastUpdatedBy, _data$type, _data$memberSid, _data$channelMetadata;

    var _this;

    _classCallCheck__default["default"](this, Message);

    _this = _super.call(this);
    _this.conversation = conversation;
    _this.links = links;
    _this.configuration = configuration;
    _this.services = services;
    _this.state = {
      sid: data.sid,
      index: index,
      author: data.author,
      subject: data.subject,
      contentSid: data.contentSid,
      body: (_data$text = data.text) !== null && _data$text !== void 0 ? _data$text : null,
      timestamp: data.timestamp ? new Date(data.timestamp) : null,
      dateUpdated: data.dateUpdated ? new Date(data.dateUpdated) : null,
      lastUpdatedBy: (_data$lastUpdatedBy = data.lastUpdatedBy) !== null && _data$lastUpdatedBy !== void 0 ? _data$lastUpdatedBy : null,
      attributes: parseAttributes(data.attributes, "Got malformed attributes for the message ".concat(data.sid), log$3),
      type: (_data$type = data.type) !== null && _data$type !== void 0 ? _data$type : "text",
      media: data.type === "media" && data.media ? new Media(data.media, _this.services) : null,
      medias: data.type === "media" && data.medias ? data.medias.map(function (m) {
        return new Media(m, _this.services);
      }) : data.type === "media" && data.media && !data.medias ? [new Media(_objectSpread$4(_objectSpread$4({}, data.media), {}, {
        category: "media"
      }), _this.services)] : null,
      participantSid: (_data$memberSid = data.memberSid) !== null && _data$memberSid !== void 0 ? _data$memberSid : null,
      aggregatedDeliveryReceipt: data.delivery ? new AggregatedDeliveryReceipt(data.delivery) : null,
      hasChannelMetadata: (_data$channelMetadata = data.channelMetadata) !== null && _data$channelMetadata !== void 0 ? _data$channelMetadata : false
    };
    return _this;
  }
  /**
   * Fired when the properties or the body of the message has been updated.
   *
   * Parameters:
   * 1. object `data` - info object provided with the event. It has the following properties:
   *     * {@link Message} message - the message in question
   *     * {@link MessageUpdateReason}[] updateReasons - array of reasons for the update
   */


  _createClass__default["default"](Message, [{
    key: "sid",
    get:
    /**
     * The server-assigned unique identifier for the message.
     */
    function get() {
      return this.state.sid;
    }
    /**
     * Name of the user that sent the message.
     */

  }, {
    key: "author",
    get: function get() {
      return this.state.author;
    }
    /**
     * Message subject. Used only in email conversations.
     */

  }, {
    key: "subject",
    get: function get() {
      return this.state.subject;
    }
    /**
     * Unique identifier of {@link ContentTemplate} for this message.
     */

  }, {
    key: "contentSid",
    get: function get() {
      return this.state.contentSid;
    }
    /**
     * Body of the message.
     */

  }, {
    key: "body",
    get: function get() {
      return this.state.body;
    }
    /**
     * Date this message was last updated on.
     */

  }, {
    key: "dateUpdated",
    get: function get() {
      return this.state.dateUpdated;
    }
    /**
     * Index of this message in the conversation's list of messages.
     *
     * By design, the message indices may have arbitrary gaps between them,
     * that does not necessarily mean they were deleted or otherwise modified - just that
     * messages may have some non-contiguous indices even if they are being sent immediately one after another.
     *
     * Trying to use indices for some calculations is going to be unreliable.
     *
     * To calculate the number of unread messages, it is better to use the Read Horizon API.
     * See {@link Conversation.getUnreadMessagesCount} for details.
     */

  }, {
    key: "index",
    get: function get() {
      return this.state.index;
    }
    /**
     * Identity of the last user that updated the message.
     */

  }, {
    key: "lastUpdatedBy",
    get: function get() {
      return this.state.lastUpdatedBy;
    }
    /**
     * Date this message was created on.
     */

  }, {
    key: "dateCreated",
    get: function get() {
      return this.state.timestamp;
    }
    /**
     * Custom attributes of the message.
     */

  }, {
    key: "attributes",
    get: function get() {
      return this.state.attributes;
    }
    /**
     * Type of the message.
     */

  }, {
    key: "type",
    get: function get() {
      return this.state.type;
    }
    /**
     * One of the attached media (if present).
     * @deprecated Use attachedMedia instead. Note that the latter is now an array.
     */

  }, {
    key: "media",
    get: function get() {
      return this.state.media;
    }
    /**
     * Return all media attachments, except email body/history attachments, without temporary urls.
     */

  }, {
    key: "attachedMedia",
    get: function get() {
      return this.getMediaByCategories(["media"]);
    }
    /**
     * The server-assigned unique identifier of the authoring participant.
     */

  }, {
    key: "participantSid",
    get: function get() {
      return this.state.participantSid;
    }
    /**
     * Aggregated information about the message delivery statuses across all participants of a conversation..
     */

  }, {
    key: "aggregatedDeliveryReceipt",
    get: function get() {
      return this.state.aggregatedDeliveryReceipt;
    }
    /**
     * @deprecated
     * Return a (possibly empty) array of media matching a specific set of categories.
     * Allowed category is so far only 'media'.
     * @param categories Array of categories to match.
     * @returns Array of media descriptors matching given categories.
     */

  }, {
    key: "getMediaByCategory",
    value: function getMediaByCategory(categories) {
      return this.getMediaByCategories(categories);
    }
    /**
     * Return a (possibly empty) array of media matching a specific set of categories.
     * Allowed category is so far only 'media'.
     * @param categories Array of categories to match.
     * @returns Array of media descriptors matching given categories.
     */

  }, {
    key: "getMediaByCategories",
    value: function getMediaByCategories(categories) {
      var _this$state$medias;

      return ((_this$state$medias = this.state.medias) !== null && _this$state$medias !== void 0 ? _this$state$medias : []).filter(function (m) {
        return categories.includes(m.category);
      });
    }
    /**
     * Get a media descriptor for an email body attachment of a provided type.
     * Allowed body types are returned in the Conversation.limits().emailBodiesAllowedContentTypes array.
     * @param type Type of email body to request, defaults to `text/plain`.
     */

  }, {
    key: "getEmailBody",
    value: function getEmailBody() {
      var _this$getMediaByCateg, _this$getMediaByCateg2;

      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "text/plain";
      return (_this$getMediaByCateg = (_this$getMediaByCateg2 = this.getMediaByCategories(["body"])) === null || _this$getMediaByCateg2 === void 0 ? void 0 : _this$getMediaByCateg2.filter(function (m) {
        return m.contentType == type;
      }).shift()) !== null && _this$getMediaByCateg !== void 0 ? _this$getMediaByCateg : null;
    }
    /**
     * Get a media descriptor for an email history attachment of a provided type.
     * Allowed body types are returned in the Conversation.limits().emailHistoriesAllowedContentTypes array.
     * @param type Type of email history to request, defaults to `text/plain`.
     */

  }, {
    key: "getEmailHistory",
    value: function getEmailHistory() {
      var _this$getMediaByCateg3, _this$getMediaByCateg4;

      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "text/plain";
      return (_this$getMediaByCateg3 = (_this$getMediaByCateg4 = this.getMediaByCategories(["history"])) === null || _this$getMediaByCateg4 === void 0 ? void 0 : _this$getMediaByCateg4.filter(function (m) {
        return m.contentType == type;
      }).shift()) !== null && _this$getMediaByCateg3 !== void 0 ? _this$getMediaByCateg3 : null;
    }
  }, {
    key: "_update",
    value: function _update(data) {
      var updateReasons = [];

      if ((data.text || typeof data.text === "string") && data.text !== this.state.body) {
        this.state.body = data.text;
        updateReasons.push("body");
      }

      if (data.subject && data.subject !== this.state.subject) {
        this.state.subject = data.subject;
        updateReasons.push("subject");
      }

      if (data.lastUpdatedBy && data.lastUpdatedBy !== this.state.lastUpdatedBy) {
        this.state.lastUpdatedBy = data.lastUpdatedBy;
        updateReasons.push("lastUpdatedBy");
      }

      if (data.author && data.author !== this.state.author) {
        this.state.author = data.author;
        updateReasons.push("author");
      }

      if (data.dateUpdated && new Date(data.dateUpdated).getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {
        this.state.dateUpdated = new Date(data.dateUpdated);
        updateReasons.push("dateUpdated");
      }

      if (data.timestamp && new Date(data.timestamp).getTime() !== (this.state.timestamp && this.state.timestamp.getTime())) {
        this.state.timestamp = new Date(data.timestamp);
        updateReasons.push("dateCreated");
      }

      var updatedAttributes = parseAttributes(data.attributes, "Got malformed attributes for the message ".concat(this.sid), log$3);

      if (!isEqual__default["default"](this.state.attributes, updatedAttributes)) {
        this.state.attributes = updatedAttributes;
        updateReasons.push("attributes");
      }

      var updatedAggregatedDelivery = data.delivery;
      var currentAggregatedDelivery = this.state.aggregatedDeliveryReceipt;
      var isUpdatedAggregateDeliveryValid = !!updatedAggregatedDelivery && !!updatedAggregatedDelivery.total && !!updatedAggregatedDelivery.delivered && !!updatedAggregatedDelivery.failed && !!updatedAggregatedDelivery.read && !!updatedAggregatedDelivery.sent && !!updatedAggregatedDelivery.undelivered;

      if (isUpdatedAggregateDeliveryValid) {
        if (!currentAggregatedDelivery) {
          this.state.aggregatedDeliveryReceipt = new AggregatedDeliveryReceipt(updatedAggregatedDelivery);
          updateReasons.push("deliveryReceipt");
        } else if (!currentAggregatedDelivery._isEquals(updatedAggregatedDelivery)) {
          currentAggregatedDelivery._update(updatedAggregatedDelivery);

          updateReasons.push("deliveryReceipt");
        }
      }

      if (updateReasons.length > 0) {
        this.emit("updated", {
          message: this,
          updateReasons: updateReasons
        });
      }
    }
    /**
     * Get the participant who is the author of the message.
     */

  }, {
    key: "getParticipant",
    value: function () {
      var _getParticipant = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee() {
        var _this2 = this;

        var participant, errorMesage;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                participant = null;

                if (!this.state.participantSid) {
                  _context.next = 5;
                  break;
                }

                _context.next = 4;
                return this.conversation.getParticipantBySid(this.state.participantSid).catch(function () {
                  log$3.debug("Participant with sid \"".concat(_this2.participantSid, "\" not found for message ").concat(_this2.sid));
                  return null;
                });

              case 4:
                participant = _context.sent;

              case 5:
                if (!(!participant && this.state.author)) {
                  _context.next = 9;
                  break;
                }

                _context.next = 8;
                return this.conversation.getParticipantByIdentity(this.state.author).catch(function () {
                  log$3.debug("Participant with identity \"".concat(_this2.author, "\" not found for message ").concat(_this2.sid));
                  return null;
                });

              case 8:
                participant = _context.sent;

              case 9:
                if (!participant) {
                  _context.next = 11;
                  break;
                }

                return _context.abrupt("return", participant);

              case 11:
                errorMesage = "Participant with ";

                if (this.state.participantSid) {
                  errorMesage += "SID '" + this.state.participantSid + "' ";
                }

                if (this.state.author) {
                  if (this.state.participantSid) {
                    errorMesage += "or ";
                  }

                  errorMesage += "identity '" + this.state.author + "' ";
                }

                if (errorMesage === "Participant with ") {
                  errorMesage = "Participant ";
                }

                errorMesage += "was not found";
                throw new Error(errorMesage);

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getParticipant() {
        return _getParticipant.apply(this, arguments);
      }

      return getParticipant;
    }()
    /**
     * Get the delivery receipts of the message.
     */

  }, {
    key: "getDetailedDeliveryReceipts",
    value: function () {
      var _getDetailedDeliveryReceipts = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2() {
        var paginator, detailedDeliveryReceipts;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._getDetailedDeliveryReceiptsPaginator();

              case 2:
                paginator = _context2.sent;
                detailedDeliveryReceipts = paginator.items;

              case 4:
                if (!paginator.hasNextPage) {
                  _context2.next = 11;
                  break;
                }

                _context2.next = 7;
                return paginator.nextPage();

              case 7:
                paginator = _context2.sent;
                detailedDeliveryReceipts = [].concat(_toConsumableArray__default["default"](detailedDeliveryReceipts), _toConsumableArray__default["default"](paginator.items));
                _context2.next = 4;
                break;

              case 11:
                return _context2.abrupt("return", detailedDeliveryReceipts);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getDetailedDeliveryReceipts() {
        return _getDetailedDeliveryReceipts.apply(this, arguments);
      }

      return getDetailedDeliveryReceipts;
    }()
    /**
     * Remove the message.
     */

  }, {
    key: "remove",
    value: function () {
      var _remove = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3() {
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.services.commandExecutor.mutateResource("delete", this.links.self);

              case 2:
                return _context3.abrupt("return", this);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function remove() {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
    /**
     * Edit the message body.
     * @param body New body of the message.
     */

  }, {
    key: "updateBody",
    value: function () {
      var _updateBody = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee4(body) {
        return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.services.commandExecutor.mutateResource("post", this.links.self, {
                  body: body
                });

              case 2:
                return _context4.abrupt("return", this);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function updateBody(_x) {
        return _updateBody.apply(this, arguments);
      }

      return updateBody;
    }()
    /**
     * Edit the message attributes.
     * @param attributes New attributes.
     */

  }, {
    key: "updateAttributes",
    value: function () {
      var _updateAttributes = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee5(attributes) {
        return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.services.commandExecutor.mutateResource("post", this.links.self, {
                  attributes: typeof attributes !== "undefined" ? JSON.stringify(attributes) : undefined
                });

              case 2:
                return _context5.abrupt("return", this);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function updateAttributes(_x2) {
        return _updateAttributes.apply(this, arguments);
      }

      return updateAttributes;
    }()
    /**
     * @deprecated
     * Get content URLs for all media attachments in the given set using a single operation.
     * @param contentSet Set of media attachments to query content URLs.
     */

  }, {
    key: "attachTemporaryUrlsFor",
    value: function () {
      var _attachTemporaryUrlsFor = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee6(contentSet) {
        var _this3 = this;

        var sids;
        return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                // We ignore existing mcsMedia members of each of the media entries.
                // Instead we just collect their sids and pull new descriptors from a mediaSet GET endpoint.
                sids = contentSet === null || contentSet === void 0 ? void 0 : contentSet.map(function (m) {
                  return m.sid;
                });

                if (!(this.services.mcsClient && sids)) {
                  _context6.next = 7;
                  break;
                }

                _context6.next = 4;
                return this.services.mcsClient.mediaSetGet(sids);

              case 4:
                return _context6.abrupt("return", _context6.sent.map(function (item) {
                  return new Media(item, _this3.services);
                }));

              case 7:
                throw new Error("Media Content Service is unavailable");

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function attachTemporaryUrlsFor(_x3) {
        return _attachTemporaryUrlsFor.apply(this, arguments);
      }

      return attachTemporaryUrlsFor;
    }()
    /**
     * Get content URLs for all media attachments in the given set using a single operation.
     * @param contentSet Set of media attachments to query content URLs.
     */

  }, {
    key: "getTemporaryContentUrlsForMedia",
    value: function getTemporaryContentUrlsForMedia(contentSet) {
      // We ignore existing mcsMedia members of each of the media entries.
      // Instead we just collect their sids and pull new descriptors from a mediaSet GET endpoint.
      var sids = contentSet.map(function (m) {
        return m.sid;
      });
      return this.getTemporaryContentUrlsForMediaSids(sids);
    }
    /**
     * Get content URLs for all media attachments in the given set of media sids using a single operation.
     * @param mediaSids Set of media sids to query for the content URL.
     */

  }, {
    key: "getTemporaryContentUrlsForMediaSids",
    value: function getTemporaryContentUrlsForMediaSids(mediaSids) {
      var _this4 = this;

      return new mcsClient.CancellablePromise( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee7(resolve, reject, onCancel) {
          var mediaGetRequest, urls;
          return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  mediaGetRequest = _this4.services.mcsClient.mediaSetGetContentUrls(mediaSids !== null && mediaSids !== void 0 ? mediaSids : []);

                  if (!(!_this4.services.mcsClient || !mediaSids)) {
                    _context7.next = 4;
                    break;
                  }

                  reject(new Error("Media Content Service is unavailable"));
                  return _context7.abrupt("return");

                case 4:
                  onCancel(function () {
                    mediaGetRequest.cancel();
                  });
                  _context7.prev = 5;
                  _context7.next = 8;
                  return mediaGetRequest;

                case 8:
                  urls = _context7.sent;
                  resolve(urls);
                  _context7.next = 15;
                  break;

                case 12:
                  _context7.prev = 12;
                  _context7.t0 = _context7["catch"](5);
                  reject(_context7.t0);

                case 15:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, null, [[5, 12]]);
        }));

        return function (_x4, _x5, _x6) {
          return _ref.apply(this, arguments);
        };
      }());
    }
    /**
     * Get content URLs for all media attached to the message.
     */

  }, {
    key: "getTemporaryContentUrlsForAttachedMedia",
    value: function getTemporaryContentUrlsForAttachedMedia() {
      var _media$map;

      var media = this.attachedMedia;
      var sids = (_media$map = media === null || media === void 0 ? void 0 : media.map(function (m) {
        return m.sid;
      })) !== null && _media$map !== void 0 ? _media$map : [];
      return this.getTemporaryContentUrlsForMediaSids(sids);
    }
  }, {
    key: "_getDetailedDeliveryReceiptsPaginator",
    value: function () {
      var _getDetailedDeliveryReceiptsPaginator2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee8(options) {
        var _this5 = this;

        var messagesReceiptsUrl, url, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                messagesReceiptsUrl = this.configuration.links.messagesReceipts.replace("%s", this.conversation.sid).replace("%s", this.sid);
                url = new UriBuilder(messagesReceiptsUrl).arg("PageToken", options === null || options === void 0 ? void 0 : options.pageToken).arg("PageSize", options === null || options === void 0 ? void 0 : options.pageSize).build();
                _context8.next = 4;
                return this.services.network.get(url);

              case 4:
                response = _context8.sent;
                return _context8.abrupt("return", new RestPaginator(response.body.delivery_receipts.map(function (x) {
                  return new DetailedDeliveryReceipt(x);
                }), function (pageToken, pageSize) {
                  return _this5._getDetailedDeliveryReceiptsPaginator({
                    pageToken: pageToken,
                    pageSize: pageSize
                  });
                }, response.body.meta.previous_token, response.body.meta.next_token));

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _getDetailedDeliveryReceiptsPaginator(_x7) {
        return _getDetailedDeliveryReceiptsPaginator2.apply(this, arguments);
      }

      return _getDetailedDeliveryReceiptsPaginator;
    }()
    /**
     * Get the {@link ContentData} for this message. Resolves to `null` when
     * {@link Message.contentSid} is null.
     */

  }, {
    key: "getContentData",
    value: function getContentData() {
      var _this6 = this;

      return new mcsClient.CancellablePromise( /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee9(resolve, reject, onCancel) {
          var bodies, twilioPrefix, filteredMedias, contentMedia, urlPromise, url, jsonStringPromise, json, jsonString, dataType;
          return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  if (!(_this6.state.contentSid === null)) {
                    _context9.next = 3;
                    break;
                  }

                  resolve(null);
                  return _context9.abrupt("return");

                case 3:
                  bodies = _this6.getMediaByCategories(["body"]);

                  if (!(bodies === null)) {
                    _context9.next = 7;
                    break;
                  }

                  resolve(null);
                  return _context9.abrupt("return");

                case 7:
                  twilioPrefix = "application/x-vnd.com.twilio.rich.";
                  filteredMedias = bodies.filter(function (media) {
                    return media.contentType.startsWith(twilioPrefix);
                  });

                  if (!(filteredMedias.length === 0)) {
                    _context9.next = 12;
                    break;
                  }

                  resolve(null);
                  return _context9.abrupt("return");

                case 12:
                  contentMedia = filteredMedias[0];
                  urlPromise = contentMedia.getContentTemporaryUrl();
                  onCancel(function () {
                    urlPromise.cancel();
                  });
                  _context9.prev = 15;
                  _context9.next = 18;
                  return urlPromise;

                case 18:
                  url = _context9.sent;
                  _context9.next = 25;
                  break;

                case 21:
                  _context9.prev = 21;
                  _context9.t0 = _context9["catch"](15);
                  reject(_context9.t0);
                  return _context9.abrupt("return");

                case 25:
                  if (!(url === null)) {
                    _context9.next = 28;
                    break;
                  }

                  resolve(null);
                  return _context9.abrupt("return");

                case 28:
                  jsonStringPromise = new Promise(function (resolve, reject) {
                    var _url;

                    var isCancelled = false;
                    var xhr = new XHR();
                    xhr.open("GET", (_url = url) !== null && _url !== void 0 ? _url : "", true);
                    xhr.responseType = "text";

                    xhr.onreadystatechange = function () {
                      if (xhr.readyState !== 4 || isCancelled) {
                        return;
                      }

                      resolve(xhr.responseText);
                    };

                    xhr.onerror = function () {
                      reject(xhr.statusText);
                    };

                    onCancel(function () {
                      isCancelled = true;
                      xhr.abort();
                      reject(new Error("XHR has been aborted"));
                    });
                    xhr.send();
                  });
                  _context9.prev = 29;
                  _context9.next = 32;
                  return jsonStringPromise;

                case 32:
                  jsonString = _context9.sent;
                  json = JSON.parse(jsonString);
                  _context9.next = 40;
                  break;

                case 36:
                  _context9.prev = 36;
                  _context9.t1 = _context9["catch"](29);
                  reject(_context9.t1);
                  return _context9.abrupt("return");

                case 40:
                  dataType = contentMedia.contentType.replace(twilioPrefix, "").replace(".", "/");
                  resolve(parseVariant(dataType, json.data));

                case 42:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9, null, [[15, 21], [29, 36]]);
        }));

        return function (_x8, _x9, _x10) {
          return _ref2.apply(this, arguments);
        };
      }());
    }
    /**
     * Get the {@link ChannelMetadata} for this message. Resolves to `null` if
     * the message doesn't have any channel metadata.
     */

  }, {
    key: "getChannelMetadata",
    value: function () {
      var _getChannelMetadata = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee10() {
        return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (this.state.hasChannelMetadata) {
                  _context10.next = 2;
                  break;
                }

                return _context10.abrupt("return", null);

              case 2:
                _context10.next = 4;
                return this.services.channelMetadataClient.getChannelMetadata(this.conversation.sid, this.sid);

              case 4:
                return _context10.abrupt("return", _context10.sent);

              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getChannelMetadata() {
        return _getChannelMetadata.apply(this, arguments);
      }

      return getChannelMetadata;
    }()
  }]);

  return Message;
}(replayEventEmitter.ReplayEventEmitter);

_defineProperty__default["default"](Message, "updated", "updated");

__decorate([deprecationDecorator.deprecated("getMediaByCategory", "getMediaByCategories"), __metadata("design:type", Function), __metadata("design:paramtypes", [Array]), __metadata("design:returntype", Array)], Message.prototype, "getMediaByCategory", null);

__decorate([declarativeTypeValidator.validateTypes([declarativeTypeValidator.nonEmptyString, "undefined"]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Media)], Message.prototype, "getEmailBody", null);

__decorate([declarativeTypeValidator.validateTypes([declarativeTypeValidator.nonEmptyString, "undefined"]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Media)], Message.prototype, "getEmailHistory", null);

__decorate([declarativeTypeValidator.validateTypesAsync("string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Message.prototype, "updateBody", null);

__decorate([declarativeTypeValidator.validateTypesAsync(json), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Message.prototype, "updateAttributes", null);

__decorate([deprecationDecorator.deprecated("attachTemporaryUrlsFor", "getTemporaryContentUrlsForMedia"), __metadata("design:type", Function), __metadata("design:paramtypes", [Array]), __metadata("design:returntype", Promise)], Message.prototype, "attachTemporaryUrlsFor", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyArray("media", Media)), __metadata("design:type", Function), __metadata("design:paramtypes", [Array]), __metadata("design:returntype", mcsClient.CancellablePromise)], Message.prototype, "getTemporaryContentUrlsForMedia", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyArray("strings", "string")), __metadata("design:type", Function), __metadata("design:paramtypes", [Array]), __metadata("design:returntype", mcsClient.CancellablePromise)], Message.prototype, "getTemporaryContentUrlsForMediaSids", null);

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf__default["default"](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default["default"](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default["default"](this, result); }; }

function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var log$2 = Logger.scope("Messages");
/**
 * Represents the collection of messages in a conversation
 */

var Messages = /*#__PURE__*/function (_ReplayEventEmitter) {
  _inherits__default["default"](Messages, _ReplayEventEmitter);

  var _super = _createSuper$5(Messages);

  function Messages(conversation, configuration, services) {
    var _this;

    _classCallCheck__default["default"](this, Messages);

    _this = _super.call(this);
    _this.conversation = conversation;
    _this.configuration = configuration;
    _this.services = services;
    _this.messagesByIndex = new Map();
    _this.messagesListPromise = null;
    return _this;
  }
  /**
   * Subscribe to the Messages Event Stream
   * @param arg - Name of the Sync object, or the SyncList itself, that
   * represents the Messages resource.
   */


  _createClass__default["default"](Messages, [{
    key: "subscribe",
    value: function () {
      var _subscribe = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(arg) {
        var _this2 = this;

        var list;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.messagesListPromise) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", this.messagesListPromise);

              case 2:
                this.messagesListPromise = typeof arg === "string" ? this.services.syncClient.list({
                  id: arg,
                  mode: "open_existing"
                }) : Promise.resolve(arg);
                _context.prev = 3;
                _context.next = 6;
                return this.messagesListPromise;

              case 6:
                list = _context.sent;
                list.on("itemAdded", function (args) {
                  log$2.debug("".concat(_this2.conversation.sid, " itemAdded: ").concat(args.item.index));
                  var links = {
                    self: "".concat(_this2.conversation._links.messages, "/").concat(args.item.data.sid),
                    conversation: _this2.conversation._links.self,
                    messages_receipts: "".concat(_this2.conversation._links.messages, "/").concat(args.item.data.sid, "/Receipts")
                  };
                  var message = new Message(args.item.index, args.item.data, _this2.conversation, links, _this2.configuration, _this2.services);

                  if (_this2.messagesByIndex.has(message.index)) {
                    log$2.debug("Message arrived, but is already known and ignored", _this2.conversation.sid, message.index);
                    return;
                  }

                  _this2.messagesByIndex.set(message.index, message);

                  message.on("updated", function (args) {
                    return _this2.emit("messageUpdated", args);
                  });

                  _this2.emit("messageAdded", message);
                });
                list.on("itemRemoved", function (args) {
                  log$2.debug("#{this.conversation.sid} itemRemoved: ".concat(args.index));
                  var index = args.index;

                  if (_this2.messagesByIndex.has(index)) {
                    var message = _this2.messagesByIndex.get(index);

                    if (!message) {
                      return;
                    }

                    _this2.messagesByIndex.delete(message.index);

                    message.removeAllListeners("updated");

                    _this2.emit("messageRemoved", message);
                  }
                });
                list.on("itemUpdated", function (args) {
                  log$2.debug("".concat(_this2.conversation.sid, " itemUpdated: ").concat(args.item.index));

                  var message = _this2.messagesByIndex.get(args.item.index);

                  if (message) {
                    message._update(args.item.data);
                  }
                });
                return _context.abrupt("return", list);

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](3);
                this.messagesListPromise = null;

                if (this.services.syncClient.connectionState !== "disconnected") {
                  log$2.error("Failed to get messages object for conversation", this.conversation.sid, _context.t0);
                }

                log$2.debug("ERROR: Failed to get messages object for conversation", this.conversation.sid, _context.t0);
                throw _context.t0;

              case 19:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[3, 13]]);
      }));

      function subscribe(_x) {
        return _subscribe.apply(this, arguments);
      }

      return subscribe;
    }()
  }, {
    key: "unsubscribe",
    value: function () {
      var _unsubscribe = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2() {
        var entity;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.messagesListPromise) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                _context2.next = 4;
                return this.messagesListPromise;

              case 4:
                entity = _context2.sent;
                entity.close();
                this.messagesListPromise = null;

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function unsubscribe() {
        return _unsubscribe.apply(this, arguments);
      }

      return unsubscribe;
    }()
    /**
     * Send a message to the conversation. The message could include text and multiple media attachments.
     * @param message Message to post
     */

  }, {
    key: "sendV2",
    value: function sendV2(message) {
      var _this3 = this;

      log$2.debug("Sending message V2", message.mediaContent, message.attributes, message.emailOptions);
      return new mcsClient.CancellablePromise( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3(resolve, reject, onCancel) {
          var _message$emailOptions;

          var media, requests, _iterator, _step, _step$value, category, mediaContent, _mediaContent$content, _mediaContent$media, request, messagesPostRequest;

          return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  media = [];
                  requests = [];
                  onCancel(function () {
                    requests.forEach(function (request) {
                      return request.cancel();
                    });
                  });
                  _iterator = _createForOfIteratorHelper$3(message.mediaContent);
                  _context3.prev = 4;

                  _iterator.s();

                case 6:
                  if ((_step = _iterator.n()).done) {
                    _context3.next = 25;
                    break;
                  }

                  _step$value = _slicedToArray__default["default"](_step.value, 2), category = _step$value[0], mediaContent = _step$value[1];
                  _context3.prev = 8;
                  log$2.debug("Adding media to a message as ".concat(mediaContent instanceof FormData ? "FormData" : "SendMediaOptions"), mediaContent);
                  request = mediaContent instanceof FormData ? _this3.services.mcsClient.postFormData(mediaContent, category) : _this3.services.mcsClient.post((_mediaContent$content = mediaContent.contentType) !== null && _mediaContent$content !== void 0 ? _mediaContent$content : "", (_mediaContent$media = mediaContent.media) !== null && _mediaContent$media !== void 0 ? _mediaContent$media : "", category, mediaContent.filename);
                  requests.push(request);
                  _context3.t0 = media;
                  _context3.next = 15;
                  return request;

                case 15:
                  _context3.t1 = _context3.sent;

                  _context3.t0.push.call(_context3.t0, _context3.t1);

                  _context3.next = 23;
                  break;

                case 19:
                  _context3.prev = 19;
                  _context3.t2 = _context3["catch"](8);
                  reject(_context3.t2);
                  return _context3.abrupt("return");

                case 23:
                  _context3.next = 6;
                  break;

                case 25:
                  _context3.next = 30;
                  break;

                case 27:
                  _context3.prev = 27;
                  _context3.t3 = _context3["catch"](4);

                  _iterator.e(_context3.t3);

                case 30:
                  _context3.prev = 30;

                  _iterator.f();

                  return _context3.finish(30);

                case 33:
                  messagesPostRequest = _this3.services.commandExecutor.mutateResource("post", _this3.conversation._links.messages, {
                    body: message.text,
                    subject: (_message$emailOptions = message.emailOptions) === null || _message$emailOptions === void 0 ? void 0 : _message$emailOptions.subject,
                    media_sids: media.map(function (m) {
                      return m.sid;
                    }),
                    attributes: typeof message.attributes !== "undefined" ? JSON.stringify(message.attributes) : undefined,
                    content_sid: message.contentSid,
                    content_variables: typeof message.contentVariables !== "undefined" ? JSON.stringify(message.contentVariables.reduce(function (accum, current) {
                      return _objectSpread$3(_objectSpread$3({}, accum), {}, _defineProperty__default["default"]({}, current.name, current.value));
                    }, {})) : undefined
                  });
                  _context3.prev = 34;
                  _context3.t4 = resolve;
                  _context3.next = 38;
                  return messagesPostRequest;

                case 38:
                  _context3.t5 = _context3.sent;
                  (0, _context3.t4)(_context3.t5);
                  _context3.next = 45;
                  break;

                case 42:
                  _context3.prev = 42;
                  _context3.t6 = _context3["catch"](34);
                  reject(_context3.t6);

                case 45:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, null, [[4, 27, 30, 33], [8, 19], [34, 42]]);
        }));

        return function (_x2, _x3, _x4) {
          return _ref.apply(this, arguments);
        };
      }());
    }
    /**
     * Send Message to the conversation
     * @param message Message to post
     * @param attributes Message attributes
     * @param emailOptions Options that modify E-mail integration behaviors.
     * @returns Returns promise which can fail
     */

  }, {
    key: "send",
    value: function () {
      var _send = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee4(message) {
        var attributes,
            emailOptions,
            _args4 = arguments;
        return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                attributes = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
                emailOptions = _args4.length > 2 ? _args4[2] : undefined;
                log$2.debug("Sending text message", message, attributes, emailOptions);
                return _context4.abrupt("return", this.services.commandExecutor.mutateResource("post", this.conversation._links.messages, {
                  body: message !== null && message !== void 0 ? message : "",
                  attributes: typeof attributes !== "undefined" ? JSON.stringify(attributes) : undefined,
                  subject: emailOptions === null || emailOptions === void 0 ? void 0 : emailOptions.subject
                }));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function send(_x5) {
        return _send.apply(this, arguments);
      }

      return send;
    }()
    /**
     * Send Media Message to the conversation
     * @param mediaContent Media content to post
     * @param attributes Message attributes
     * @param emailOptions Email options
     * @returns Returns promise which can fail
     */

  }, {
    key: "sendMedia",
    value: function () {
      var _sendMedia = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee5(mediaContent) {
        var _mediaContent$content2, _mediaContent$media2;

        var attributes,
            emailOptions,
            media,
            _args5 = arguments;
        return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                attributes = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};
                emailOptions = _args5.length > 2 ? _args5[2] : undefined;
                log$2.debug("Sending media message", mediaContent, attributes, emailOptions);
                log$2.debug("Sending media message as ".concat(mediaContent instanceof FormData ? "FormData" : "SendMediaOptions"), mediaContent, attributes);

                if (!(mediaContent instanceof FormData)) {
                  _context5.next = 10;
                  break;
                }

                _context5.next = 7;
                return this.services.mcsClient.postFormData(mediaContent);

              case 7:
                _context5.t0 = _context5.sent;
                _context5.next = 13;
                break;

              case 10:
                _context5.next = 12;
                return this.services.mcsClient.post((_mediaContent$content2 = mediaContent.contentType) !== null && _mediaContent$content2 !== void 0 ? _mediaContent$content2 : "", (_mediaContent$media2 = mediaContent.media) !== null && _mediaContent$media2 !== void 0 ? _mediaContent$media2 : "", "media", mediaContent.filename);

              case 12:
                _context5.t0 = _context5.sent;

              case 13:
                media = _context5.t0;
                _context5.next = 16;
                return this.services.commandExecutor.mutateResource("post", this.conversation._links.messages, {
                  media_sids: [media.sid],
                  attributes: typeof attributes !== "undefined" ? JSON.stringify(attributes) : undefined
                });

              case 16:
                return _context5.abrupt("return", _context5.sent);

              case 17:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function sendMedia(_x6) {
        return _sendMedia.apply(this, arguments);
      }

      return sendMedia;
    }()
    /**
     * Returns messages from conversation using paginator interface
     * @param pageSize Number of messages to return in single chunk. By default it's 30.
     * @param anchor Most early message id which is already known, or 'end' by default
     * @param direction Pagination order 'backwards' or 'forward', 'forward' by default
     * @returns Last page of messages by default
     */

  }, {
    key: "getMessages",
    value: function () {
      var _getMessages2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee6(pageSize, anchor) {
        var direction,
            _args6 = arguments;
        return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                direction = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : "backwards";
                return _context6.abrupt("return", this._getMessages(pageSize, anchor, direction));

              case 2:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getMessages(_x7, _x8) {
        return _getMessages2.apply(this, arguments);
      }

      return getMessages;
    }()
  }, {
    key: "_wrapPaginator",
    value: function _wrapPaginator(order, page, op) {
      var _this4 = this;

      // Due to an inconsistency between Sync and Chat conventions, next and
      // previous pages should be swapped.
      var shouldReverse = order === "desc";

      var nextPage = function nextPage() {
        return page.nextPage().then(function (page) {
          return _this4._wrapPaginator(order, page, op);
        });
      };

      var previousPage = function previousPage() {
        return page.prevPage().then(function (page) {
          return _this4._wrapPaginator(order, page, op);
        });
      };

      return op(page.items).then(function (items) {
        return {
          items: items.sort(function (x, y) {
            return x.index - y.index;
          }),
          hasPrevPage: shouldReverse ? page.hasNextPage : page.hasPrevPage,
          hasNextPage: shouldReverse ? page.hasPrevPage : page.hasNextPage,
          prevPage: shouldReverse ? nextPage : previousPage,
          nextPage: shouldReverse ? previousPage : nextPage
        };
      });
    }
  }, {
    key: "_upsertMessage",
    value: function _upsertMessage(index, value) {
      var _this5 = this;

      var cachedMessage = this.messagesByIndex.get(index);

      if (cachedMessage) {
        return cachedMessage;
      }

      var links = {
        self: "".concat(this.conversation._links.messages, "/").concat(value.sid),
        conversation: this.conversation._links.self,
        messages_receipts: "".concat(this.conversation._links.messages, "/").concat(value.sid, "/Receipts")
      };
      var message = new Message(index, value, this.conversation, links, this.configuration, this.services);
      this.messagesByIndex.set(message.index, message);
      message.on("updated", function (args) {
        return _this5.emit("messageUpdated", args);
      });
      return message;
    }
    /**
     * Returns last messages from conversation
     * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.
     * @param {String} [anchor] Most early message id which is already known, or 'end' by default
     * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default
     * @returns {Promise<SyncPaginator<Message>>} last page of messages by default
     * @private
     */

  }, {
    key: "_getMessages",
    value: function () {
      var _getMessages3 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee7() {
        var _this6 = this;

        var pageSize,
            anchor,
            direction,
            order,
            list,
            page,
            _args7 = arguments;
        return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                pageSize = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : 30;
                anchor = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : "end";
                direction = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : "forward";
                order = direction === "backwards" ? "desc" : "asc";
                _context7.next = 6;
                return this.messagesListPromise;

              case 6:
                list = _context7.sent;
                _context7.next = 9;
                return list === null || list === void 0 ? void 0 : list.getItems({
                  from: anchor !== "end" ? anchor : void 0,
                  pageSize: pageSize,
                  order: order,
                  limit: pageSize // @todo Limit equals pageSize by default in Sync. This is probably not ideal.

                });

              case 9:
                page = _context7.sent;
                _context7.next = 12;
                return this._wrapPaginator(order, page, function (items) {
                  return Promise.all(items.map(function (item) {
                    return _this6._upsertMessage(item.index, item.data);
                  }));
                });

              case 12:
                return _context7.abrupt("return", _context7.sent);

              case 13:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _getMessages() {
        return _getMessages3.apply(this, arguments);
      }

      return _getMessages;
    }()
  }]);

  return Messages;
}(replayEventEmitter.ReplayEventEmitter);

/**
 * An unsent message. Returned from {@link MessageBuilder.build}.
 */

var UnsentMessage = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function UnsentMessage(messagesEntity) {
    _classCallCheck__default["default"](this, UnsentMessage);

    _defineProperty__default["default"](this, "attributes", {});

    _defineProperty__default["default"](this, "mediaContent", []);

    _defineProperty__default["default"](this, "emailOptions", {});

    this.messagesEntity = messagesEntity;
  }
  /**
   * Send the prepared message to the conversation.
   * @returns Index of the new message in the conversation.
   */


  _createClass__default["default"](UnsentMessage, [{
    key: "send",
    value: function send() {
      var _this = this;

      return new mcsClient.CancellablePromise( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(resolve, reject, onCancel) {
          var request, response;
          return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  request = _this.messagesEntity.sendV2(_this);
                  onCancel(function () {
                    return request.cancel();
                  });
                  _context.prev = 2;
                  _context.next = 5;
                  return request;

                case 5:
                  response = _context.sent;
                  resolve(parseToNumber(response.index));
                  _context.next = 12;
                  break;

                case 9:
                  _context.prev = 9;
                  _context.t0 = _context["catch"](2);
                  reject(_context.t0);

                case 12:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[2, 9]]);
        }));

        return function (_x, _x2, _x3) {
          return _ref.apply(this, arguments);
        };
      }());
    }
  }]);

  return UnsentMessage;
}();

/**
 * Message builder. Allows the message to be built and sent via method chaining.
 *
 * Example:
 *
 * ```ts
 * await testConversation.prepareMessage()
 *   .setBody('Hello!')
 *   .setAttributes({foo: 'bar'})
 *   .addMedia(media1)
 *   .addMedia(media2)
 *   .build()
 *   .send();
 * ```
 */

var MessageBuilder = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function MessageBuilder(limits, messagesEntity) {
    _classCallCheck__default["default"](this, MessageBuilder);

    this.limits = limits;
    this.message = new UnsentMessage(messagesEntity);
    this.emailBodies = new Map();
    this.emailHistories = new Map();
  }
  /**
   * Sets the message body.
   * @param text Contents of the body.
   */


  _createClass__default["default"](MessageBuilder, [{
    key: "setBody",
    value: function setBody(text) {
      this.message.text = text;
      return this;
    }
    /**
     * Sets the message subject.
     * @param subject Contents of the subject.
     */

  }, {
    key: "setSubject",
    value: function setSubject(subject) {
      this.message.emailOptions.subject = subject;
      return this;
    }
    /**
     * Sets the message attributes.
     * @param attributes Message attributes.
     */

  }, {
    key: "setAttributes",
    value: function setAttributes(attributes) {
      this.message.attributes = attributes;
      return this;
    }
    /**
     * Set the email body with a given content type.
     * @param contentType Format of the body to set (text/plain or text/html).
     * @param body Body payload in the selected format.
     */

  }, {
    key: "setEmailBody",
    value: function setEmailBody(contentType, body) {
      this.emailBodies.set(contentType, body);
      return this;
    }
    /**
     * Set the email history with a given content type.
     * @param contentType Format of the history to set (text/plain or text/html).
     * @param history History payload in the selected format.
     */

  }, {
    key: "setEmailHistory",
    value: function setEmailHistory(contentType, history) {
      this.emailHistories.set(contentType, history);
      return this;
    }
    /**
     * Adds {@link ContentTemplate} SID for the message alongside optional
     * variables. When no variables provided, the default values will be used.
     *
     * Adding the content SID converts the message to a rich message. In this
     * case, other fields are ignored and the message is sent using the content
     * from the the {@link ContentTemplate}.
     *
     * Use {@link Client.getContentTemplates} to request all available
     * {@link ContentTemplate}s.
     *
     * @param contentSid SID of the {@link ContentTemplate}
     * @param variables Custom variables to resolve the template.
     */

  }, {
    key: "setContentTemplate",
    value: function setContentTemplate(contentSid) {
      var contentVariables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      this.message.contentSid = contentSid;
      this.message.contentVariables = contentVariables;
      return this;
    }
    /**
     * Adds media to the message.
     * @param payload Media to add.
     */

  }, {
    key: "addMedia",
    value: function addMedia(payload) {
      if (typeof FormData === "undefined" && payload instanceof FormData) {
        throw new Error("Could not add FormData content whilst not in a browser");
      }

      if (!(payload instanceof FormData)) {
        var mediaOptions = payload;

        if (!mediaOptions.contentType || !mediaOptions.media) {
          throw new Error("Media content in SendMediaOptions must contain non-empty contentType and media");
        }
      }

      this.message.mediaContent.push(["media", payload]);
      return this;
    }
    /**
     * Builds the message, making it ready to be sent.
     */

  }, {
    key: "build",
    value: function build() {
      var _this = this;

      this.emailBodies.forEach(function (_, key) {
        if (!_this.limits.emailBodiesAllowedContentTypes.includes(key)) {
          throw new Error("Unsupported email body content type ".concat(key));
        }
      });
      this.emailHistories.forEach(function (_, key) {
        if (!_this.limits.emailHistoriesAllowedContentTypes.includes(key)) {
          throw new Error("Unsupported email history content type ".concat(key));
        }
      });

      if (this.emailBodies.size > this.limits.emailBodiesAllowedContentTypes.length) {
        throw new Error("Too many email bodies attached to the message (".concat(this.emailBodies.size, " > ").concat(this.limits.emailBodiesAllowedContentTypes.length, ")"));
      }

      if (this.emailHistories.size > this.limits.emailHistoriesAllowedContentTypes.length) {
        throw new Error("Too many email histories attached to the message (".concat(this.emailHistories.size, " > ").concat(this.limits.emailHistoriesAllowedContentTypes.length, ")"));
      }

      if (this.message.mediaContent.length > this.limits.mediaAttachmentsCountLimit) {
        throw new Error("Too many media attachments in the message (".concat(this.message.mediaContent.length, " > ").concat(this.limits.mediaAttachmentsCountLimit, ")"));
      } // @todo we don't know the sizes of the attachments in FormData
      // @todo insertion below makes build() method non-repeatable - probably move to UnsentMessage.send() or even sendV2()?


      this.emailBodies.forEach(function (body) {
        _this.message.mediaContent.push(["body", body]);
      });
      this.emailHistories.forEach(function (history) {
        _this.message.mediaContent.push(["history", history]);
      });
      return this.message;
    }
    /**
     * Prepares a message and sends it to the conversation.
     */

  }, {
    key: "buildAndSend",
    value: function buildAndSend() {
      return this.build().send();
    }
  }]);

  return MessageBuilder;
}();

__decorate([declarativeTypeValidator.validateTypes("string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "setBody", null);

__decorate([declarativeTypeValidator.validateTypes("string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "setSubject", null);

__decorate([declarativeTypeValidator.validateTypes(json), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "setAttributes", null);

__decorate([declarativeTypeValidator.validateTypes("string", [FormData, sendMediaOptions]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "setEmailBody", null);

__decorate([declarativeTypeValidator.validateTypes("string", [FormData, sendMediaOptions]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "setEmailHistory", null);

__decorate([declarativeTypeValidator.validateTypes("string", [declarativeTypeValidator.array("content variables", ContentTemplateVariable), "undefined"]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Array]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "setContentTemplate", null);

__decorate([declarativeTypeValidator.validateTypes([FormData, sendMediaOptions]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", MessageBuilder)], MessageBuilder.prototype, "addMedia", null);

function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf__default["default"](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default["default"](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default["default"](this, result); }; }

function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Map of the fields that will be processed with update messages.
 */

var fieldMappings = {
  lastMessage: "lastMessage",
  attributes: "attributes",
  createdBy: "createdBy",
  dateCreated: "dateCreated",
  dateUpdated: "dateUpdated",
  friendlyName: "friendlyName",
  lastConsumedMessageIndex: "lastConsumedMessageIndex",
  notificationLevel: "notificationLevel",
  sid: "sid",
  status: "status",
  uniqueName: "uniqueName",
  state: "state",
  bindings: "bindings"
};
/**
 * A conversation represents communication between multiple Conversations
 * clients.
 */

var Conversation = /*#__PURE__*/function (_ReplayEventEmitter) {
  _inherits__default["default"](Conversation, _ReplayEventEmitter);

  var _super = _createSuper$4(Conversation);

  /**
   * Fired when a participant has joined the conversation.
   *
   * Parameters:
   * 1. {@link Participant} `participant` - participant that joined the
   * conversation
   * @event
   */

  /**
   * Fired when a participant has left the conversation.
   *
   * Parameters:
   * 1. {@link Participant} `participant` - participant that left the
   * conversation
   * @event
   */

  /**
   * Fired when data of a participant has been updated.
   *
   * Parameters:
   * 1. object `data` - info object provided with the event. It has the
   * following properties:
   *     * {@link Participant} `participant` - participant that has received the
   *     update
   *     * {@link ParticipantUpdateReason}[] `updateReasons` - array of reasons
   *     for the update
   * @event
   */

  /**
   * Fired when a new message has been added to the conversation.
   *
   * Parameters:
   * 1. {@link Message} `message` - message that has been added
   * @event
   */

  /**
   * Fired when message is removed from the conversation's message list.
   *
   * Parameters:
   * 1. {@link Message} `message` - message that has been removed
   * @event
   */

  /**
   * Fired when data of a message has been updated.
   *
   * Parameters:
   * 1. object `data` - info object provided with the event. It has the
   * following properties:
   *     * {@link Message} `message` - message that has received the update
   *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for
   *     the update
   * @event
   */

  /**
   * Fired when a participant has stopped typing.
   *
   * Parameters:
   * 1. {@link Participant} `participant` - the participant that has stopped
   * typing
   * @event
   */

  /**
   * Fired when a participant has started typing.
   *
   * Parameters:
   * 1. {@link Participant} `participant` - the participant that has started
   * typing
   * @event
   */

  /**
   * Fired when the data of the conversation has been updated.
   *
   * Parameters:
   * 1. object `data` - info object provided with the event. It has the
   * following properties:
   *     * {@link Conversation} `conversation` - conversation that has received
   *     the update
   *     * {@link ConversationUpdateReason}[] `updateReasons` - array of reasons
   *     for the update
   * @event
   */

  /**
   * Fired when the conversation was destroyed or the currently-logged-in user
   * has left private conversation.
   *
   * Parameters:
   * 1. {@link Conversation} `conversation` - conversation that has been removed
   * @event
   */

  /**
   * Logger instance.
   */

  /**
   * @param descriptor Conversation descriptor.
   * @param sid Conversation SID.
   * @param links Conversation links for REST requests.
   * @param configuration Client configuration.
   * @param services Conversation services.
   * @internal
   */
  function Conversation(descriptor, sid, links, configuration, services) {
    var _descriptor$attribute, _descriptor$bindings;

    var _this;

    _classCallCheck__default["default"](this, Conversation);

    _this = _super.call(this);
    _this.sid = sid;
    _this._links = links;
    _this._configuration = configuration;
    _this._services = services;
    _this._entityName = descriptor.channel;
    _this._internalState = {
      uniqueName: descriptor.uniqueName || null,
      status: "notParticipating",
      attributes: (_descriptor$attribute = descriptor.attributes) !== null && _descriptor$attribute !== void 0 ? _descriptor$attribute : {},
      createdBy: descriptor.createdBy,
      dateCreated: parseTime(descriptor.dateCreated),
      dateUpdated: parseTime(descriptor.dateUpdated),
      friendlyName: descriptor.friendlyName || null,
      lastReadMessageIndex: Number.isInteger(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null,
      bindings: (_descriptor$bindings = descriptor.bindings) !== null && _descriptor$bindings !== void 0 ? _descriptor$bindings : {}
    };

    if (descriptor.notificationLevel) {
      _this._internalState.notificationLevel = descriptor.notificationLevel;
    }

    var participantsLinks = {
      participants: _this._links.participants
    };
    _this._participants = new Map();
    _this._participantsEntity = new Participants(_assertThisInitialized__default["default"](_this), _this._participants, participantsLinks, _this._configuration, _this._services);

    _this._participantsEntity.on("participantJoined", function (participant) {
      return _this.emit("participantJoined", participant);
    });

    _this._participantsEntity.on("participantLeft", function (participant) {
      return _this.emit("participantLeft", participant);
    });

    _this._participantsEntity.on("participantUpdated", function (args) {
      return _this.emit("participantUpdated", args);
    });

    _this._messagesEntity = new Messages(_assertThisInitialized__default["default"](_this), configuration, services);

    _this._messagesEntity.on("messageAdded", function (message) {
      return _this._onMessageAdded(message);
    });

    _this._messagesEntity.on("messageUpdated", function (args) {
      return _this.emit("messageUpdated", args);
    });

    _this._messagesEntity.on("messageRemoved", function (message) {
      return _this.emit("messageRemoved", message);
    });

    return _this;
  }
  /**
   * Unique name of the conversation.
   */


  _createClass__default["default"](Conversation, [{
    key: "uniqueName",
    get: function get() {
      return this._internalState.uniqueName;
    }
    /**
     * Status of the conversation.
     */

  }, {
    key: "status",
    get: function get() {
      return this._internalState.status;
    }
    /**
     * Name of the conversation.
     */

  }, {
    key: "friendlyName",
    get: function get() {
      return this._internalState.friendlyName;
    }
    /**
     * Date this conversation was last updated on.
     */

  }, {
    key: "dateUpdated",
    get: function get() {
      return this._internalState.dateUpdated;
    }
    /**
     * Date this conversation was created on.
     */

  }, {
    key: "dateCreated",
    get: function get() {
      return this._internalState.dateCreated;
    }
    /**
     * Identity of the user that created this conversation.
     */

  }, {
    key: "createdBy",
    get: function get() {
      var _this$_internalState$;

      return (_this$_internalState$ = this._internalState.createdBy) !== null && _this$_internalState$ !== void 0 ? _this$_internalState$ : "";
    }
    /**
     * Custom attributes of the conversation.
     */

  }, {
    key: "attributes",
    get: function get() {
      return this._internalState.attributes;
    }
    /**
     * Index of the last message the user has read in this conversation.
     */

  }, {
    key: "lastReadMessageIndex",
    get: function get() {
      return this._internalState.lastReadMessageIndex;
    }
    /**
     * Last message sent to this conversation.
     */

  }, {
    key: "lastMessage",
    get: function get() {
      var _this$_internalState$2;

      return (_this$_internalState$2 = this._internalState.lastMessage) !== null && _this$_internalState$2 !== void 0 ? _this$_internalState$2 : undefined;
    }
    /**
     * User notification level for this conversation.
     */

  }, {
    key: "notificationLevel",
    get: function get() {
      var _this$_internalState$3;

      return (_this$_internalState$3 = this._internalState.notificationLevel) !== null && _this$_internalState$3 !== void 0 ? _this$_internalState$3 : "default";
    }
    /**
     * Conversation bindings. Undocumented feature (for now).
     * @internal
     */

  }, {
    key: "bindings",
    get: function get() {
      return this._internalState.bindings;
    }
    /**
     * Current conversation limits.
     */

  }, {
    key: "limits",
    get: function get() {
      return this._configuration.limits;
    }
    /**
     * State of the conversation.
     */

  }, {
    key: "state",
    get: function get() {
      return this._internalState.state;
    }
    /**
     * Source of the conversation update.
     * @internal
     */

  }, {
    key: "_statusSource",
    get: function get() {
      return this._dataSource;
    }
    /**
     * Preprocess the update object.
     * @param update The update object received from Sync.
     * @param conversationSid The SID of the conversation in question.
     */

  }, {
    key: "add",
    value:
    /**
     * Add a participant to the conversation by its identity.
     * @param identity Identity of the Client to add.
     * @param attributes Attributes to be attached to the participant.
     * @returns The added participant.
     */
    function () {
      var _add = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(identity, attributes) {
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this._participantsEntity.add(identity, attributes !== null && attributes !== void 0 ? attributes : {}));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function add(_x, _x2) {
        return _add.apply(this, arguments);
      }

      return add;
    }()
    /**
     * Add a non-chat participant to the conversation.
     * @param proxyAddress Proxy (Twilio) address of the participant.
     * @param address User address of the participant.
     * @param attributes Attributes to be attached to the participant.
     * @param bindingOptions Options for adding email participants - name and
     * CC/To level.
     * @returns The added participant.
     */

  }, {
    key: "addNonChatParticipant",
    value: function () {
      var _addNonChatParticipant = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(proxyAddress, address) {
        var attributes,
            bindingOptions,
            _args2 = arguments;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                attributes = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};
                bindingOptions = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};
                return _context2.abrupt("return", this._participantsEntity.addNonChatParticipant(proxyAddress, address, attributes !== null && attributes !== void 0 ? attributes : {}, bindingOptions !== null && bindingOptions !== void 0 ? bindingOptions : {}));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function addNonChatParticipant(_x3, _x4) {
        return _addNonChatParticipant.apply(this, arguments);
      }

      return addNonChatParticipant;
    }()
    /**
     * Advance the conversation's last read message index to the current read
     * horizon. Rejects if the user is not a participant of the conversation. Last
     * read message index is updated only if the new index value is higher than
     * the previous.
     * @param index Message index to advance to.
     * @return Resulting unread messages count in the conversation.
     */

  }, {
    key: "advanceLastReadMessageIndex",
    value: function () {
      var _advanceLastReadMessageIndex = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3(index) {
        var _this$lastReadMessage;

        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._subscribeStreams();

              case 2:
                if (!(index < ((_this$lastReadMessage = this.lastReadMessageIndex) !== null && _this$lastReadMessage !== void 0 ? _this$lastReadMessage : 0))) {
                  _context3.next = 6;
                  break;
                }

                _context3.next = 5;
                return this._setLastReadMessageIndex(this.lastReadMessageIndex);

              case 5:
                return _context3.abrupt("return", _context3.sent);

              case 6:
                _context3.next = 8;
                return this._setLastReadMessageIndex(index);

              case 8:
                return _context3.abrupt("return", _context3.sent);

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function advanceLastReadMessageIndex(_x5) {
        return _advanceLastReadMessageIndex.apply(this, arguments);
      }

      return advanceLastReadMessageIndex;
    }()
    /**
     * Delete the conversation and unsubscribe from its events.
     */

  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee4() {
        return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._services.commandExecutor.mutateResource("delete", this._links.self);

              case 2:
                return _context4.abrupt("return", this);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _delete() {
        return _delete2.apply(this, arguments);
      }

      return _delete;
    }()
    /**
     * Get the custom attributes of this Conversation.
     */

  }, {
    key: "getAttributes",
    value: function () {
      var _getAttributes = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee5() {
        return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._subscribe();

              case 2:
                return _context5.abrupt("return", this.attributes);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getAttributes() {
        return _getAttributes.apply(this, arguments);
      }

      return getAttributes;
    }()
    /**
     * Returns messages from the conversation using the paginator interface.
     * @param pageSize Number of messages to return in a single chunk. Default is
     * 30.
     * @param anchor Index of the newest message to fetch. Default is from the
     * end.
     * @param direction Query direction. By default, it queries backwards
     * from newer to older. The `"forward"` value will query in the opposite
     * direction.
     * @return A page of messages.
     */

  }, {
    key: "getMessages",
    value: function () {
      var _getMessages = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee6(pageSize, anchor, direction) {
        return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._subscribeStreams();

              case 2:
                return _context6.abrupt("return", this._messagesEntity.getMessages(pageSize, anchor, direction));

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getMessages(_x6, _x7, _x8) {
        return _getMessages.apply(this, arguments);
      }

      return getMessages;
    }()
    /**
     * Get a list of all the participants who are joined to this conversation.
     */

  }, {
    key: "getParticipants",
    value: function () {
      var _getParticipants = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee7() {
        return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._subscribeStreams();

              case 2:
                return _context7.abrupt("return", this._participantsEntity.getParticipants());

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getParticipants() {
        return _getParticipants.apply(this, arguments);
      }

      return getParticipants;
    }()
    /**
     * Get conversation participants count.
     *
     * This method is semi-realtime. This means that this data will be eventually
     * correct, but will also be possibly incorrect for a few seconds. The
     * Conversations system does not provide real time events for counter values
     * changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any
     * core application logic based on these counters being accurate in real time.
     */

  }, {
    key: "getParticipantsCount",
    value: function () {
      var _getParticipantsCount = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee8() {
        var _response$body$partic;

        var url, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                url = new UriBuilder(this._configuration.links.conversations).path(this.sid).build();
                _context8.next = 3;
                return this._services.network.get(url);

              case 3:
                response = _context8.sent;
                return _context8.abrupt("return", (_response$body$partic = response.body.participants_count) !== null && _response$body$partic !== void 0 ? _response$body$partic : 0);

              case 5:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getParticipantsCount() {
        return _getParticipantsCount.apply(this, arguments);
      }

      return getParticipantsCount;
    }()
    /**
     * Get a participant by its SID.
     * @param participantSid Participant SID.
     */

  }, {
    key: "getParticipantBySid",
    value: function () {
      var _getParticipantBySid = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee9(participantSid) {
        return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                return _context9.abrupt("return", this._participantsEntity.getParticipantBySid(participantSid));

              case 1:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getParticipantBySid(_x9) {
        return _getParticipantBySid.apply(this, arguments);
      }

      return getParticipantBySid;
    }()
    /**
     * Get a participant by its identity.
     * @param identity Participant identity.
     */

  }, {
    key: "getParticipantByIdentity",
    value: function () {
      var _getParticipantByIdentity = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee10() {
        var identity,
            _args10 = arguments;
        return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                identity = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : "";
                return _context10.abrupt("return", this._participantsEntity.getParticipantByIdentity(identity !== null && identity !== void 0 ? identity : ""));

              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getParticipantByIdentity() {
        return _getParticipantByIdentity.apply(this, arguments);
      }

      return getParticipantByIdentity;
    }()
    /**
     * Get the total message count in the conversation.
     *
     * This method is semi-realtime. This means that this data will be eventually
     * correct, but will also be possibly incorrect for a few seconds. The
     * Conversations system does not provide real time events for counter values
     * changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any
     * core application logic based on these counters being accurate in real time.
     */

  }, {
    key: "getMessagesCount",
    value: function () {
      var _getMessagesCount = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee11() {
        var _response$body$messag;

        var url, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                url = new UriBuilder(this._configuration.links.conversations).path(this.sid).build();
                _context11.next = 3;
                return this._services.network.get(url);

              case 3:
                response = _context11.sent;
                return _context11.abrupt("return", (_response$body$messag = response.body.messages_count) !== null && _response$body$messag !== void 0 ? _response$body$messag : 0);

              case 5:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getMessagesCount() {
        return _getMessagesCount.apply(this, arguments);
      }

      return getMessagesCount;
    }()
    /**
     * Get count of unread messages for the user if they are a participant of this
     * conversation. Rejects if the user is not a participant of the conversation.
     *
     * Use this method to obtain the number of unread messages together with
     * {@link Conversation.updateLastReadMessageIndex} instead of relying on the
     * message indices which may have gaps. See {@link Message.index} for details.
     *
     * This method is semi-realtime. This means that this data will be eventually
     * correct, but it will also be possibly incorrect for a few seconds. The
     * Conversations system does not provide real time events for counter values
     * changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any
     * core application logic based on these counters being accurate in real time.
     *
     * If the read horizon is not set, this function will return null. This could mean
     * that all messages in the conversation are unread, or that the read horizon system
     * is not being used. How to interpret this `null` value is up to the customer application.
     *
     * @return Number of unread messages based on the current read horizon set for
     * the user or `null` if the read horizon is not set.
     */

  }, {
    key: "getUnreadMessagesCount",
    value: function () {
      var _getUnreadMessagesCount = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee12() {
        var url, response, unreadMessageCount;
        return _regeneratorRuntime__default["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                url = new UriBuilder(this._configuration.links.myConversations).path(this.sid).build();
                _context12.next = 3;
                return this._services.network.get(url);

              case 3:
                response = _context12.sent;

                if (!(response.body.conversation_sid !== this.sid)) {
                  _context12.next = 6;
                  break;
                }

                throw new Error("Conversation was not found in the user conversations list");

              case 6:
                unreadMessageCount = response.body.unread_messages_count;

                if (!(typeof unreadMessageCount === "number")) {
                  _context12.next = 9;
                  break;
                }

                return _context12.abrupt("return", unreadMessageCount);

              case 9:
                return _context12.abrupt("return", null);

              case 10:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getUnreadMessagesCount() {
        return _getUnreadMessagesCount.apply(this, arguments);
      }

      return getUnreadMessagesCount;
    }()
    /**
     * Join the conversation and subscribe to its events.
     */

  }, {
    key: "join",
    value: function () {
      var _join = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee13() {
        return _regeneratorRuntime__default["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this._services.commandExecutor.mutateResource("post", this._links.participants, {
                  identity: this._configuration.userIdentity
                });

              case 2:
                return _context13.abrupt("return", this);

              case 3:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function join() {
        return _join.apply(this, arguments);
      }

      return join;
    }()
    /**
     * Leave the conversation.
     */

  }, {
    key: "leave",
    value: function () {
      var _leave = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee14() {
        return _regeneratorRuntime__default["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                if (!(this._internalState.status === "joined")) {
                  _context14.next = 3;
                  break;
                }

                _context14.next = 3;
                return this._services.commandExecutor.mutateResource("delete", "".concat(this._links.participants, "/").concat(encodeURIComponent(this._configuration.userIdentity)));

              case 3:
                return _context14.abrupt("return", this);

              case 4:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function leave() {
        return _leave.apply(this, arguments);
      }

      return leave;
    }()
    /**
     * Remove a participant from the conversation. When a string is passed as the
     * argument, it will assume that the string is an identity or SID.
     * @param participant Identity, SID or the participant object to remove.
     */

  }, {
    key: "removeParticipant",
    value: function () {
      var _removeParticipant = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee15(participant) {
        return _regeneratorRuntime__default["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this._participantsEntity.remove(typeof participant === "string" ? participant : participant.sid);

              case 2:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function removeParticipant(_x10) {
        return _removeParticipant.apply(this, arguments);
      }

      return removeParticipant;
    }()
    /**
     * Send a message to the conversation.
     * @param message Message body for the text message,
     * `FormData` or {@link SendMediaOptions} for media content. Sending FormData
     * is supported only with the browser engine.
     * @param messageAttributes Attributes for the message.
     * @param emailOptions Email options for the message.
     * @return Index of the new message.
     */

  }, {
    key: "sendMessage",
    value: function () {
      var _sendMessage = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee16(message, messageAttributes, emailOptions) {
        var _parseToNumber2;

        var _parseToNumber, _response, response;

        return _regeneratorRuntime__default["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                if (!(typeof message === "string" || message === null)) {
                  _context16.next = 5;
                  break;
                }

                _context16.next = 3;
                return this._messagesEntity.send(message, messageAttributes, emailOptions);

              case 3:
                _response = _context16.sent;
                return _context16.abrupt("return", (_parseToNumber = parseToNumber(_response.index)) !== null && _parseToNumber !== void 0 ? _parseToNumber : 0);

              case 5:
                _context16.next = 7;
                return this._messagesEntity.sendMedia(message, messageAttributes, emailOptions);

              case 7:
                response = _context16.sent;
                return _context16.abrupt("return", (_parseToNumber2 = parseToNumber(response.index)) !== null && _parseToNumber2 !== void 0 ? _parseToNumber2 : 0);

              case 9:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function sendMessage(_x11, _x12, _x13) {
        return _sendMessage.apply(this, arguments);
      }

      return sendMessage;
    }()
    /**
     * New interface to prepare for sending a message.
     * Use this instead of {@link Conversation.sendMessage}.
     * @return A MessageBuilder to help set all message sending options.
     */

  }, {
    key: "prepareMessage",
    value: function prepareMessage() {
      return new MessageBuilder(this.limits, this._messagesEntity);
    }
    /**
     * Set last read message index of the conversation to the index of the last
     * known message.
     * @return Resulting unread messages count in the conversation.
     */

  }, {
    key: "setAllMessagesRead",
    value: function () {
      var _setAllMessagesRead = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee17() {
        var messagesPage;
        return _regeneratorRuntime__default["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this._subscribeStreams();

              case 2:
                _context17.next = 4;
                return this.getMessages(1);

              case 4:
                messagesPage = _context17.sent;

                if (!(messagesPage.items.length > 0)) {
                  _context17.next = 7;
                  break;
                }

                return _context17.abrupt("return", this.advanceLastReadMessageIndex(messagesPage.items[0].index));

              case 7:
                return _context17.abrupt("return", 0);

              case 8:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function setAllMessagesRead() {
        return _setAllMessagesRead.apply(this, arguments);
      }

      return setAllMessagesRead;
    }()
    /**
     * Set all messages in the conversation unread.
     * @returns New count of unread messages after this update.
     */

  }, {
    key: "setAllMessagesUnread",
    value: function () {
      var _setAllMessagesUnread = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee18() {
        return _regeneratorRuntime__default["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this._subscribeStreams();

              case 2:
                _context18.next = 4;
                return this._setLastReadMessageIndex(null);

              case 4:
                return _context18.abrupt("return", _context18.sent);

              case 5:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function setAllMessagesUnread() {
        return _setAllMessagesUnread.apply(this, arguments);
      }

      return setAllMessagesUnread;
    }()
    /**
     * Set user notification level for this conversation.
     * @param notificationLevel New user notification level.
     */

  }, {
    key: "setUserNotificationLevel",
    value: function () {
      var _setUserNotificationLevel = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee19(notificationLevel) {
        return _regeneratorRuntime__default["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this._services.commandExecutor.mutateResource("post", "".concat(this._configuration.links.myConversations, "/").concat(this.sid), {
                  notification_level: notificationLevel
                });

              case 2:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function setUserNotificationLevel(_x14) {
        return _setUserNotificationLevel.apply(this, arguments);
      }

      return setUserNotificationLevel;
    }()
    /**
     * Send a notification to the server indicating that this client is currently
     * typing in this conversation. Typing ended notification is sent after a
     * while automatically, but by calling this method again you ensure that
     * typing ended is not received.
     */

  }, {
    key: "typing",
    value: function typing() {
      return this._services.typingIndicator.send(this.sid);
    }
    /**
     * Update the attributes of the conversation.
     * @param attributes New attributes.
     */

  }, {
    key: "updateAttributes",
    value: function () {
      var _updateAttributes = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee20(attributes) {
        return _regeneratorRuntime__default["default"].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this._services.commandExecutor.mutateResource("post", this._links.self, {
                  attributes: attributes !== undefined ? JSON.stringify(attributes) : undefined
                });

              case 2:
                return _context20.abrupt("return", this);

              case 3:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function updateAttributes(_x15) {
        return _updateAttributes.apply(this, arguments);
      }

      return updateAttributes;
    }()
    /**
     * Update the friendly name of the conversation.
     * @param friendlyName New friendly name.
     */

  }, {
    key: "updateFriendlyName",
    value: function () {
      var _updateFriendlyName = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee21(friendlyName) {
        return _regeneratorRuntime__default["default"].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                if (!(this._internalState.friendlyName !== friendlyName)) {
                  _context21.next = 3;
                  break;
                }

                _context21.next = 3;
                return this._services.commandExecutor.mutateResource("post", this._links.self, {
                  friendly_name: friendlyName
                });

              case 3:
                return _context21.abrupt("return", this);

              case 4:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function updateFriendlyName(_x16) {
        return _updateFriendlyName.apply(this, arguments);
      }

      return updateFriendlyName;
    }()
    /**
     * Set the last read message index to the current read horizon.
     * @param index Message index to set as last read. If null is provided, then
     * the behavior is identical to {@link Conversation.setAllMessagesUnread}.
     * @returns New count of unread messages after this update.
     */

  }, {
    key: "updateLastReadMessageIndex",
    value: function () {
      var _updateLastReadMessageIndex = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee22(index) {
        return _regeneratorRuntime__default["default"].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this._subscribeStreams();

              case 2:
                return _context22.abrupt("return", this._setLastReadMessageIndex(index));

              case 3:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function updateLastReadMessageIndex(_x17) {
        return _updateLastReadMessageIndex.apply(this, arguments);
      }

      return updateLastReadMessageIndex;
    }()
    /**
     * Update the unique name of the conversation.
     * @param uniqueName New unique name for the conversation. Setting unique name
     * to null removes it.
     */

  }, {
    key: "updateUniqueName",
    value: function () {
      var _updateUniqueName = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee23(uniqueName) {
        return _regeneratorRuntime__default["default"].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                if (!(this._internalState.uniqueName !== uniqueName)) {
                  _context23.next = 4;
                  break;
                }

                uniqueName || (uniqueName = "");
                _context23.next = 4;
                return this._services.commandExecutor.mutateResource("post", this._links.self, {
                  unique_name: uniqueName
                });

              case 4:
                return _context23.abrupt("return", this);

              case 5:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function updateUniqueName(_x18) {
        return _updateUniqueName.apply(this, arguments);
      }

      return updateUniqueName;
    }()
    /**
     * Load and subscribe to this conversation and do not subscribe to its
     * participants and messages. This or _subscribeStreams will need to be called
     * before any events on conversation will fire.
     * @internal
     */

  }, {
    key: "_subscribe",
    value: function () {
      var _subscribe2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee24() {
        var _this2 = this;

        return _regeneratorRuntime__default["default"].wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                if (!this._entityPromise) {
                  _context24.next = 2;
                  break;
                }

                return _context24.abrupt("return", this._entityPromise);

              case 2:
                this._entityPromise = this._services.syncClient.document({
                  id: this._entityName,
                  mode: "open_existing"
                });
                _context24.prev = 3;
                _context24.next = 6;
                return this._entityPromise;

              case 6:
                this._entity = _context24.sent;

                this._entity.on("updated", function (args) {
                  return _this2._update(args.data);
                });

                this._entity.on("removed", function () {
                  return _this2.emit("removed", _this2);
                });

                this._update(this._entity.data);

                return _context24.abrupt("return", this._entity);

              case 13:
                _context24.prev = 13;
                _context24.t0 = _context24["catch"](3);
                this._entity = null;
                this._entityPromise = null;

                if (this._services.syncClient.connectionState != "disconnected") {
                  Conversation._logger.error("Failed to get conversation object", _context24.t0);
                }

                Conversation._logger.debug("ERROR: Failed to get conversation object", _context24.t0);

                throw _context24.t0;

              case 20:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this, [[3, 13]]);
      }));

      function _subscribe() {
        return _subscribe2.apply(this, arguments);
      }

      return _subscribe;
    }()
    /**
     * Fetch participants and messages of the conversation. This method needs to
     * be called during conversation initialization to catch broken conversations
     * (broken conversations are conversations that have essential Sync entities
     * missing, i.e. the conversation document, the messages list or the
     * participant map). In case of this conversation being broken, the method
     * will throw an exception that will be caught and handled gracefully.
     * @internal
     */

  }, {
    key: "_fetchStreams",
    value: function () {
      var _fetchStreams2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee25() {
        var _this$_entity, _this$_entity2;

        var data;
        return _regeneratorRuntime__default["default"].wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return this._subscribe();

              case 2:
                Conversation._logger.trace("_streamsAvailable, this.entity.data=", (_this$_entity = this._entity) === null || _this$_entity === void 0 ? void 0 : _this$_entity.data);

                data = (_this$_entity2 = this._entity) === null || _this$_entity2 === void 0 ? void 0 : _this$_entity2.data;
                _context25.next = 6;
                return this._services.syncClient.list({
                  id: data.messages,
                  mode: "open_existing"
                });

              case 6:
                this._messagesList = _context25.sent;
                _context25.next = 9;
                return this._services.syncClient.map({
                  id: data.roster,
                  mode: "open_existing"
                });

              case 9:
                this._participantsMap = _context25.sent;

              case 10:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function _fetchStreams() {
        return _fetchStreams2.apply(this, arguments);
      }

      return _fetchStreams;
    }()
    /**
     * Load the attributes of this conversation and instantiate its participants
     * and messages. This or _subscribe will need to be called before any events
     * on the conversation will fire. This will need to be called before any
     * events on participants or messages will fire
     * @internal
     */

  }, {
    key: "_subscribeStreams",
    value: function () {
      var _subscribeStreams2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee26() {
        var _this$_entity3, _this$_entity4, _this$_messagesList, _this$_participantsMa, data, messagesObjectName, rosterObjectName;

        return _regeneratorRuntime__default["default"].wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.prev = 0;
                _context26.next = 3;
                return this._subscribe();

              case 3:
                Conversation._logger.trace("_subscribeStreams, this.entity.data=", (_this$_entity3 = this._entity) === null || _this$_entity3 === void 0 ? void 0 : _this$_entity3.data);

                data = (_this$_entity4 = this._entity) === null || _this$_entity4 === void 0 ? void 0 : _this$_entity4.data;
                messagesObjectName = data.messages;
                rosterObjectName = data.roster;
                _context26.next = 9;
                return Promise.all([this._messagesEntity.subscribe((_this$_messagesList = this._messagesList) !== null && _this$_messagesList !== void 0 ? _this$_messagesList : messagesObjectName), this._participantsEntity.subscribe((_this$_participantsMa = this._participantsMap) !== null && _this$_participantsMa !== void 0 ? _this$_participantsMa : rosterObjectName)]);

              case 9:
                _context26.next = 16;
                break;

              case 11:
                _context26.prev = 11;
                _context26.t0 = _context26["catch"](0);

                if (this._services.syncClient.connectionState !== "disconnected") {
                  Conversation._logger.error("Failed to subscribe on conversation objects", this.sid, _context26.t0);
                }

                Conversation._logger.debug("ERROR: Failed to subscribe on conversation objects", this.sid, _context26.t0);

                throw _context26.t0;

              case 16:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this, [[0, 11]]);
      }));

      function _subscribeStreams() {
        return _subscribeStreams2.apply(this, arguments);
      }

      return _subscribeStreams;
    }()
    /**
     * Stop listening for and firing events on this conversation.
     * @internal
     */

  }, {
    key: "_unsubscribe",
    value: function () {
      var _unsubscribe2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee27() {
        return _regeneratorRuntime__default["default"].wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                if (!this._entity) {
                  _context27.next = 5;
                  break;
                }

                _context27.next = 3;
                return this._entity.close();

              case 3:
                this._entity = null;
                this._entityPromise = null;

              case 5:
                return _context27.abrupt("return", Promise.all([this._participantsEntity.unsubscribe(), this._messagesEntity.unsubscribe()]));

              case 6:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function _unsubscribe() {
        return _unsubscribe2.apply(this, arguments);
      }

      return _unsubscribe;
    }()
    /**
     * Set conversation status.
     * @internal
     */

  }, {
    key: "_setStatus",
    value: function _setStatus(status, source) {
      var _this3 = this;

      this._dataSource = source;

      if (this._internalState.status === status) {
        return;
      }

      this._internalState.status = status;

      if (status === "joined") {
        this._subscribeStreams().catch(function (err) {
          Conversation._logger.debug("ERROR while setting conversation status " + status, err);

          if (_this3._services.syncClient.connectionState !== "disconnected") {
            throw err;
          }
        });

        return;
      }

      if (this._entityPromise) {
        this._unsubscribe().catch(function (err) {
          Conversation._logger.debug("ERROR while setting conversation status " + status, err);

          if (_this3._services.syncClient.connectionState !== "disconnected") {
            throw err;
          }
        });
      }
    }
    /**
     * Update the local conversation object with new values.
     * @internal
     */

  }, {
    key: "_update",
    value: function _update(update) {
      var _update$lastMessage, _update$lastMessage2, _this$_internalState$4, _this$_internalState$5, _this$_internalState$6;

      Conversation._logger.trace("_update", update);

      Conversation.preprocessUpdate(update, this.sid);
      var updateReasons = new Set();

      for (var _i = 0, _Object$keys = Object.keys(update); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var localKey = fieldMappings[key];

        if (!localKey) {
          continue;
        }

        switch (localKey) {
          case fieldMappings.status:
            if (!update.status || update.status === "unknown" || this._internalState.status === update.status) {
              break;
            }

            this._internalState.status = update.status;
            updateReasons.add(localKey);
            break;

          case fieldMappings.attributes:
            if (isEqual__default["default"](this._internalState.attributes, update.attributes)) {
              break;
            }

            this._internalState.attributes = update.attributes;
            updateReasons.add(localKey);
            break;

          case fieldMappings.lastConsumedMessageIndex:
            if (update.lastConsumedMessageIndex === undefined || update.lastConsumedMessageIndex === this._internalState.lastReadMessageIndex) {
              break;
            }

            this._internalState.lastReadMessageIndex = update.lastConsumedMessageIndex;
            updateReasons.add("lastReadMessageIndex");
            break;

          case fieldMappings.lastMessage:
            if (this._internalState.lastMessage && !update.lastMessage) {
              delete this._internalState.lastMessage;
              updateReasons.add(localKey);
              break;
            }

            this._internalState.lastMessage = this._internalState.lastMessage || {};

            if (((_update$lastMessage = update.lastMessage) === null || _update$lastMessage === void 0 ? void 0 : _update$lastMessage.index) !== undefined && update.lastMessage.index !== this._internalState.lastMessage.index) {
              this._internalState.lastMessage.index = update.lastMessage.index;
              updateReasons.add(localKey);
            }

            if (((_update$lastMessage2 = update.lastMessage) === null || _update$lastMessage2 === void 0 ? void 0 : _update$lastMessage2.timestamp) !== undefined && ((_this$_internalState$4 = this._internalState.lastMessage) === null || _this$_internalState$4 === void 0 ? void 0 : (_this$_internalState$5 = _this$_internalState$4.dateCreated) === null || _this$_internalState$5 === void 0 ? void 0 : _this$_internalState$5.getTime()) !== update.lastMessage.timestamp.getTime()) {
              this._internalState.lastMessage.dateCreated = update.lastMessage.timestamp;
              updateReasons.add(localKey);
            }

            if (isEqual__default["default"](this._internalState.lastMessage, {})) {
              delete this._internalState.lastMessage;
            }

            break;

          case fieldMappings.state:
            var state = update.state || undefined;

            if (state !== undefined) {
              state.dateUpdated = new Date(state.dateUpdated);
            }

            if (isEqual__default["default"](this._internalState.state, state)) {
              break;
            }

            this._internalState.state = state;
            updateReasons.add(localKey);
            break;

          case fieldMappings.bindings:
            if (isEqual__default["default"](this._internalState.bindings, update.bindings)) {
              break;
            }

            this._internalState.bindings = update.bindings;
            updateReasons.add(localKey);
            break;

          default:
            var isDate = update[key] instanceof Date;
            var keysMatchAsDates = isDate && ((_this$_internalState$6 = this._internalState[localKey]) === null || _this$_internalState$6 === void 0 ? void 0 : _this$_internalState$6.getTime()) === update[key].getTime();
            var keysMatchAsNonDates = !isDate && this[localKey] === update[key];

            if (keysMatchAsDates || keysMatchAsNonDates) {
              break;
            }

            this._internalState[localKey] = update[key];
            updateReasons.add(localKey);
        }
      }

      if (updateReasons.size > 0) {
        this.emit("updated", {
          conversation: this,
          updateReasons: _toConsumableArray__default["default"](updateReasons)
        });
      }
    }
    /**
     * Handle onMessageAdded event.
     */

  }, {
    key: "_onMessageAdded",
    value: function _onMessageAdded(message) {
      var _iterator = _createForOfIteratorHelper$2(this._participants.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var participant = _step.value;

          if (participant.identity === message.author) {
            participant._endTyping();

            break;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.emit("messageAdded", message);
    }
    /**
     * Set last read message index.
     * @param index New index to set.
     */

  }, {
    key: "_setLastReadMessageIndex",
    value: function () {
      var _setLastReadMessageIndex2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee28(index) {
        var result;
        return _regeneratorRuntime__default["default"].wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this._services.commandExecutor.mutateResource("post", "".concat(this._configuration.links.myConversations, "/").concat(this.sid), {
                  last_read_message_index: index
                });

              case 2:
                result = _context28.sent;
                return _context28.abrupt("return", result.unread_messages_count);

              case 4:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function _setLastReadMessageIndex(_x19) {
        return _setLastReadMessageIndex2.apply(this, arguments);
      }

      return _setLastReadMessageIndex;
    }()
  }], [{
    key: "preprocessUpdate",
    value: function preprocessUpdate(update, conversationSid) {
      try {
        if (typeof update.attributes === "string") {
          update.attributes = JSON.parse(update.attributes);
        } else if (update.attributes) {
          JSON.stringify(update.attributes);
        }
      } catch (e) {
        Conversation._logger.warn("Retrieved malformed attributes from the server for conversation: " + conversationSid);

        update.attributes = {};
      }

      try {
        if (update.dateCreated) {
          update.dateCreated = new Date(update.dateCreated);
        }
      } catch (e) {
        Conversation._logger.warn("Retrieved malformed dateCreated from the server for conversation: " + conversationSid);

        delete update.dateCreated;
      }

      try {
        if (update.dateUpdated) {
          update.dateUpdated = new Date(update.dateUpdated);
        }
      } catch (e) {
        Conversation._logger.warn("Retrieved malformed dateUpdated from the server for conversation: " + conversationSid);

        delete update.dateUpdated;
      }

      try {
        if (update.lastMessage && update.lastMessage.timestamp) {
          update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);
        }
      } catch (e) {
        Conversation._logger.warn("Retrieved malformed lastMessage.timestamp from the server for conversation: " + conversationSid);

        delete update.lastMessage.timestamp;
      }
    }
  }]);

  return Conversation;
}(replayEventEmitter.ReplayEventEmitter);

_defineProperty__default["default"](Conversation, "participantJoined", "participantJoined");

_defineProperty__default["default"](Conversation, "participantLeft", "participantLeft");

_defineProperty__default["default"](Conversation, "participantUpdated", "participantUpdated");

_defineProperty__default["default"](Conversation, "messageAdded", "messageAdded");

_defineProperty__default["default"](Conversation, "messageRemoved", "messageRemoved");

_defineProperty__default["default"](Conversation, "messageUpdated", "messageUpdated");

_defineProperty__default["default"](Conversation, "typingEnded", "typingEnded");

_defineProperty__default["default"](Conversation, "typingStarted", "typingStarted");

_defineProperty__default["default"](Conversation, "updated", "updated");

_defineProperty__default["default"](Conversation, "removed", "removed");

_defineProperty__default["default"](Conversation, "_logger", Logger.scope("Conversation"));

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString, optionalJson), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object]), __metadata("design:returntype", Promise)], Conversation.prototype, "add", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString, declarativeTypeValidator.nonEmptyString, optionalJson), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String, Object, Object]), __metadata("design:returntype", Promise)], Conversation.prototype, "addNonChatParticipant", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], Conversation.prototype, "advanceLastReadMessageIndex", null);

__decorate([declarativeTypeValidator.validateTypesAsync(["undefined", declarativeTypeValidator.nonNegativeInteger], ["undefined", declarativeTypeValidator.nonNegativeInteger], ["undefined", declarativeTypeValidator.literal("backwards", "forward")]), __metadata("design:type", Function), __metadata("design:paramtypes", [Number, Number, String]), __metadata("design:returntype", Promise)], Conversation.prototype, "getMessages", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Conversation.prototype, "getParticipantBySid", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Conversation.prototype, "getParticipantByIdentity", null);

__decorate([declarativeTypeValidator.validateTypesAsync([declarativeTypeValidator.nonEmptyString, Participant]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Conversation.prototype, "removeParticipant", null);

__decorate([declarativeTypeValidator.validateTypesAsync(["string", FormData, declarativeTypeValidator.literal(null), declarativeTypeValidator.objectSchema("media options", {
  contentType: declarativeTypeValidator.nonEmptyString,
  media: declarativeTypeValidator.custom(function (value) {
    var isValid = typeof value === "string" && value.length > 0 || value instanceof Uint8Array || value instanceof ArrayBuffer;

    if (typeof Blob === "function") {
      isValid = isValid || value instanceof Blob;
    }

    return [isValid, "a non-empty string, an instance of Buffer or an instance of Blob"];
  })
})], optionalJson, ["undefined", declarativeTypeValidator.literal(null), declarativeTypeValidator.objectSchema("email attributes", {
  subject: [declarativeTypeValidator.nonEmptyString, "undefined"]
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, Object, Object]), __metadata("design:returntype", Promise)], Conversation.prototype, "sendMessage", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal("default", "muted")), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Conversation.prototype, "setUserNotificationLevel", null);

__decorate([declarativeTypeValidator.validateTypesAsync(json), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Conversation.prototype, "updateAttributes", null);

__decorate([declarativeTypeValidator.validateTypesAsync("string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Conversation.prototype, "updateFriendlyName", null);

__decorate([declarativeTypeValidator.validateTypesAsync([declarativeTypeValidator.literal(null), declarativeTypeValidator.nonNegativeInteger]), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], Conversation.prototype, "updateLastReadMessageIndex", null);

__decorate([declarativeTypeValidator.validateTypesAsync(["string", declarativeTypeValidator.literal(null)]), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Conversation.prototype, "updateUniqueName", null);

var Deferred = /*#__PURE__*/function () {
  function Deferred() {
    var _this = this;

    _classCallCheck__default["default"](this, Deferred);

    this._promise = new Promise(function (resolve, reject) {
      _this._resolve = resolve;
      _this._reject = reject;
    });
  }

  _createClass__default["default"](Deferred, [{
    key: "promise",
    get: function get() {
      return this._promise;
    }
  }, {
    key: "update",
    value: function update(value) {
      this._resolve(value);
    }
  }, {
    key: "set",
    value: function set(value) {
      this.current = value;

      this._resolve(value);
    }
  }, {
    key: "fail",
    value: function fail(e) {
      this._reject(e);
    }
  }]);

  return Deferred;
}();

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf__default["default"](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default["default"](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default["default"](this, result); }; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var log$1 = Logger.scope("Conversations");
/**
 * Represents conversations collection
 * {@see Conversation}
 */

var Conversations = /*#__PURE__*/function (_ReplayEventEmitter) {
  _inherits__default["default"](Conversations, _ReplayEventEmitter);

  var _super = _createSuper$3(Conversations);

  function Conversations(configuration, services) {
    var _this;

    _classCallCheck__default["default"](this, Conversations);

    _this = _super.call(this);

    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "conversations", new Map());

    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "myConversationsRead", new Deferred());

    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "tombstones", new Set());

    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "myConversationsFetched", false);

    _this.configuration = configuration;
    _this.services = services;
    return _this;
  }

  _createClass__default["default"](Conversations, [{
    key: "addConversation",
    value: function () {
      var _addConversation = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(options) {
        var _response$sid, _response$sync_object, _response$sync_object2;

        var attributes, response, conversationSid, conversationDocument, links, existingConversation, conversation;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                attributes = typeof (options === null || options === void 0 ? void 0 : options.attributes) !== "undefined" ? options.attributes : {};
                _context.next = 3;
                return this.services.commandExecutor.mutateResource("post", this.configuration.links.conversations, {
                  friendly_name: options.friendlyName,
                  unique_name: options.uniqueName,
                  attributes: typeof attributes !== "undefined" ? JSON.stringify(attributes) : undefined
                });

              case 3:
                response = _context.sent;
                conversationSid = (_response$sid = response.sid) !== null && _response$sid !== void 0 ? _response$sid : null;
                conversationDocument = (_response$sync_object = (_response$sync_object2 = response.sync_objects) === null || _response$sync_object2 === void 0 ? void 0 : _response$sync_object2.conversation) !== null && _response$sync_object !== void 0 ? _response$sync_object : null;
                links = _objectSpread$2({
                  self: response.url
                }, response.links);
                existingConversation = this.conversations.get(conversationSid);

                if (!existingConversation) {
                  _context.next = 12;
                  break;
                }

                _context.next = 11;
                return existingConversation._subscribe();

              case 11:
                return _context.abrupt("return", existingConversation);

              case 12:
                conversation = new Conversation({
                  channel: conversationDocument,
                  entityName: "",
                  uniqueName: "",
                  attributes: null,
                  createdBy: "",
                  friendlyName: "",
                  lastConsumedMessageIndex: 0,
                  dateCreated: null,
                  dateUpdated: null
                }, conversationSid, links, this.configuration, this.services);
                this.conversations.set(conversation.sid, conversation);

                this._registerForEvents(conversation);

                _context.next = 17;
                return conversation._subscribe();

              case 17:
                this.emit("conversationAdded", conversation);
                return _context.abrupt("return", conversation);

              case 19:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function addConversation(_x) {
        return _addConversation.apply(this, arguments);
      }

      return addConversation;
    }()
    /**
     * Fetch conversations list and instantiate all necessary objects
     */

  }, {
    key: "fetchConversations",
    value: function () {
      var _fetchConversations = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2() {
        var _this2 = this;

        var map, myConversations, upserts, _iterator, _step, conversation, errorMessage;

        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return this._getMap();

              case 3:
                map = _context2.sent;
                map.on("itemAdded", function (args) {
                  log$1.debug("itemAdded: ".concat(args.item.key));

                  _this2._upsertConversation("sync", args.item.key, args.item.data);
                });
                map.on("itemRemoved", function (args) {
                  log$1.debug("itemRemoved: ".concat(args.key));
                  var sid = args.key;

                  if (!_this2.myConversationsFetched) {
                    _this2.tombstones.add(sid);
                  }

                  var conversation = _this2.conversations.get(sid);

                  if (!conversation) {
                    return;
                  }

                  if (conversation.status === "joined") {
                    conversation._setStatus("notParticipating", "sync");

                    _this2.emit("conversationLeft", conversation);
                  }

                  _this2.conversations.delete(sid);

                  _this2.emit("conversationRemoved", conversation);

                  conversation.emit("removed", conversation);
                });
                map.on("itemUpdated", function (args) {
                  log$1.debug("itemUpdated: ".concat(args.item.key));

                  _this2._upsertConversation("sync", args.item.key, args.item.data);
                });
                _context2.next = 9;
                return this._fetchMyConversations();

              case 9:
                myConversations = _context2.sent;
                upserts = [];
                _iterator = _createForOfIteratorHelper$1(myConversations);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    conversation = _step.value;
                    upserts.push(this._upsertConversation("rest", conversation["channel_sid"], conversation));
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                this.myConversationsRead.set(true);
                _context2.next = 16;
                return Promise.all(upserts);

              case 16:
                this.myConversationsFetched = true;
                this.tombstones.clear();
                log$1.debug("The conversations list has been successfully fetched");
                return _context2.abrupt("return", this);

              case 22:
                _context2.prev = 22;
                _context2.t0 = _context2["catch"](0);
                errorMessage = "Failed to fetch the conversations list";

                if (this.services.syncClient.connectionState !== "disconnected") {
                  log$1.error(errorMessage, _context2.t0);
                }

                log$1.debug("ERROR: ".concat(errorMessage), _context2.t0);
                throw _context2.t0;

              case 28:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 22]]);
      }));

      function fetchConversations() {
        return _fetchConversations.apply(this, arguments);
      }

      return fetchConversations;
    }()
  }, {
    key: "getConversations",
    value: function () {
      var _getConversations = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3() {
        var _this3 = this;

        var conversationsMap, page;
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._getMap();

              case 2:
                conversationsMap = _context3.sent;
                _context3.next = 5;
                return conversationsMap.getItems();

              case 5:
                page = _context3.sent;
                return _context3.abrupt("return", this._wrapPaginator(page, function (items) {
                  return Promise.all(items.map(function (item) {
                    return _this3._upsertConversation("sync", item.key, item.data);
                  }));
                }));

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getConversations() {
        return _getConversations.apply(this, arguments);
      }

      return getConversations;
    }()
  }, {
    key: "getConversation",
    value: function () {
      var _getConversation = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee4(sid) {
        var _this4 = this;

        var conversationsMap, page, items;
        return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._getMap();

              case 2:
                conversationsMap = _context4.sent;
                _context4.next = 5;
                return conversationsMap.getItems({
                  key: sid
                });

              case 5:
                page = _context4.sent;
                items = page.items.map(function (item) {
                  return _this4._upsertConversation("sync", item.key, item.data);
                });
                return _context4.abrupt("return", items.length > 0 ? items[0] : null);

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getConversation(_x2) {
        return _getConversation.apply(this, arguments);
      }

      return getConversation;
    }()
  }, {
    key: "getConversationByUniqueName",
    value: function () {
      var _getConversationByUniqueName = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee5(uniqueName) {
        var url, response, body, sid, data;
        return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                url = new UriBuilder(this.configuration.links.myConversations).path(uniqueName).build();
                _context5.next = 3;
                return this.services.network.get(url);

              case 3:
                response = _context5.sent;
                body = response.body;
                sid = body.conversation_sid;
                data = {
                  entityName: null,
                  lastConsumedMessageIndex: body.last_read_message_index,
                  status: (body === null || body === void 0 ? void 0 : body.status) || "unknown",
                  friendlyName: body.friendly_name,
                  dateUpdated: body.date_updated,
                  dateCreated: body.date_created,
                  uniqueName: body.unique_name,
                  createdBy: body.created_by,
                  attributes: body.attributes,
                  channel: body.sync_objects.conversation,
                  notificationLevel: body === null || body === void 0 ? void 0 : body.notification_level,
                  sid: sid
                };
                return _context5.abrupt("return", sid ? this._upsertConversation("sync", sid, data) : null);

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getConversationByUniqueName(_x3) {
        return _getConversationByUniqueName.apply(this, arguments);
      }

      return getConversationByUniqueName;
    }()
  }, {
    key: "peekConversation",
    value: function () {
      var _peekConversation = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee6(sid) {
        var url, response, body, data;
        return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                url = new UriBuilder(this.configuration.links.conversations).path(sid).build();
                _context6.next = 3;
                return this.services.network.get(url);

              case 3:
                response = _context6.sent;
                body = response.body;
                data = {
                  entityName: null,
                  // lastConsumedMessageIndex: body.last_read_message_index,
                  status: (body === null || body === void 0 ? void 0 : body.status) || "unknown",
                  friendlyName: body.friendly_name,
                  dateUpdated: body.date_updated,
                  dateCreated: body.date_created,
                  uniqueName: body.unique_name,
                  createdBy: body.created_by,
                  attributes: body.attributes,
                  channel: "".concat(sid, ".channel"),
                  // notificationLevel: body?.notification_level,
                  sid: sid
                };
                return _context6.abrupt("return", this._upsertConversation("sync", sid, data));

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function peekConversation(_x4) {
        return _peekConversation.apply(this, arguments);
      }

      return peekConversation;
    }()
  }, {
    key: "_getMap",
    value: function () {
      var _getMap2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee7() {
        return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.services.syncClient.map({
                  id: this.configuration.myConversations,
                  mode: "open_existing"
                });

              case 2:
                return _context7.abrupt("return", _context7.sent);

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _getMap() {
        return _getMap2.apply(this, arguments);
      }

      return _getMap;
    }()
  }, {
    key: "_wrapPaginator",
    value: function () {
      var _wrapPaginator2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee8(page, op) {
        var _this5 = this;

        var items;
        return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return op(page.items);

              case 2:
                items = _context8.sent;
                return _context8.abrupt("return", {
                  items: items.filter(function (item) {
                    return item !== null;
                  }),
                  hasNextPage: page.hasNextPage,
                  hasPrevPage: page.hasPrevPage,
                  nextPage: function nextPage() {
                    return page.nextPage().then(function (x) {
                      return _this5._wrapPaginator(x, op);
                    });
                  },
                  prevPage: function prevPage() {
                    return page.prevPage().then(function (x) {
                      return _this5._wrapPaginator(x, op);
                    });
                  }
                });

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }));

      function _wrapPaginator(_x5, _x6) {
        return _wrapPaginator2.apply(this, arguments);
      }

      return _wrapPaginator;
    }()
  }, {
    key: "_updateConversation",
    value: function () {
      var _updateConversation2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee9(source, conversation, data) {
        var areSourcesDifferent, isChannelSourceSync, updateData;
        return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                areSourcesDifferent = conversation._statusSource !== undefined && source !== conversation._statusSource;
                isChannelSourceSync = source !== "rest" || conversation._statusSource === "sync";

                if (!(areSourcesDifferent && isChannelSourceSync && source !== "sync")) {
                  _context9.next = 5;
                  break;
                }

                log$1.trace("upsertConversation: conversation is known from sync and came from REST, ignoring", {
                  sid: conversation.sid,
                  data: data.status,
                  conversation: conversation.status
                });
                return _context9.abrupt("return");

              case 5:
                if (!(data.status === "joined" && conversation.status !== "joined")) {
                  _context9.next = 15;
                  break;
                }

                conversation._setStatus("joined", source);

                updateData = {};

                if (typeof data.notificationLevel !== "undefined") {
                  updateData.notificationLevel = data.notificationLevel;
                }

                if (typeof data.lastConsumedMessageIndex !== "undefined") {
                  updateData.lastConsumedMessageIndex = data.lastConsumedMessageIndex;
                }

                if (!isEqual__default["default"](updateData, {})) {
                  conversation._update(updateData);
                }

                _context9.next = 13;
                return conversation._subscribe();

              case 13:
                this.emit("conversationJoined", conversation);
                return _context9.abrupt("return");

              case 15:
                if (!(data.status === "notParticipating" && conversation.status === "joined")) {
                  _context9.next = 22;
                  break;
                }

                conversation._setStatus("notParticipating", source);

                conversation._update(data);

                _context9.next = 20;
                return conversation._subscribe();

              case 20:
                this.emit("conversationLeft", conversation);
                return _context9.abrupt("return");

              case 22:
                if (!(data.status === "notParticipating")) {
                  _context9.next = 26;
                  break;
                }

                _context9.next = 25;
                return conversation._subscribe();

              case 25:
                return _context9.abrupt("return");

              case 26:
                conversation._update(data);

              case 27:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _updateConversation(_x7, _x8, _x9) {
        return _updateConversation2.apply(this, arguments);
      }

      return _updateConversation;
    }()
  }, {
    key: "_upsertConversation",
    value: function () {
      var _upsertConversation2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee10(source, sid, data) {
        var conversation, baseLink, links, newConversation;
        return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                log$1.trace("upsertConversation called for ".concat(sid), data);
                conversation = this.conversations.get(sid); // If the channel is known, update it

                if (!conversation) {
                  _context10.next = 9;
                  break;
                }

                log$1.trace("upsertConversation: the conversation ".concat(conversation.sid, " is known;") + "its status is known from the source ".concat(conversation._statusSource, " ") + "and the update came from the source ".concat(source), conversation);
                _context10.next = 6;
                return this._updateConversation(source, conversation, data);

              case 6:
                _context10.next = 8;
                return conversation._subscribe();

              case 8:
                return _context10.abrupt("return", conversation);

              case 9:
                if (!(source === "rest" && this.tombstones.has(sid))) {
                  _context10.next = 12;
                  break;
                }

                log$1.trace("upsertChannel: the conversation is deleted but reappeared again from REST, ignoring", sid);
                return _context10.abrupt("return", null);

              case 12:
                // If the conversation is unknown, fetch it
                log$1.trace("upsertConversation: creating a local conversation object with sid " + sid, data);
                baseLink = "".concat(this.configuration.links.conversations, "/").concat(sid);
                links = {
                  self: baseLink,
                  messages: "".concat(baseLink, "/Messages"),
                  participants: "".concat(baseLink, "/Participants")
                };
                newConversation = new Conversation(data, sid, links, this.configuration, this.services);
                this.conversations.set(sid, newConversation);
                _context10.prev = 17;
                _context10.next = 20;
                return newConversation._subscribe();

              case 20:
                if (!(data.status === "joined")) {
                  _context10.next = 23;
                  break;
                }

                _context10.next = 23;
                return newConversation._fetchStreams();

              case 23:
                _context10.next = 32;
                break;

              case 25:
                _context10.prev = 25;
                _context10.t0 = _context10["catch"](17);

                if (!(_context10.t0.name !== "SyncError")) {
                  _context10.next = 29;
                  break;
                }

                throw _context10.t0;

              case 29:
                log$1.trace("upsertChannel: the conversation is missing some Sync entity(ies), ignoring", sid, _context10.t0);
                this.conversations.delete(sid);
                return _context10.abrupt("return", null);

              case 32:
                this._registerForEvents(newConversation);

                this.emit("conversationAdded", newConversation);

                if (data.status === "joined") {
                  newConversation._setStatus("joined", source);

                  this.emit("conversationJoined", newConversation);
                }

                return _context10.abrupt("return", newConversation);

              case 36:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[17, 25]]);
      }));

      function _upsertConversation(_x10, _x11, _x12) {
        return _upsertConversation2.apply(this, arguments);
      }

      return _upsertConversation;
    }()
  }, {
    key: "_fetchMyConversations",
    value: function () {
      var _fetchMyConversations2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee11() {
        var conversations, pageToken, _response$body, url, response, receivedConversations;

        return _regeneratorRuntime__default["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                conversations = [];
                pageToken = null;

              case 2:
                url = new UriBuilder(this.configuration.links.myConversations);

                if (pageToken) {
                  url.arg("PageToken", pageToken);
                }

                _context11.next = 6;
                return this.services.network.get(url.build());

              case 6:
                response = _context11.sent;
                receivedConversations = (_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.conversations.map(function (conversationDescriptor) {
                  return {
                    descriptor: conversationDescriptor,
                    channel_sid: conversationDescriptor.conversation_sid,
                    status: conversationDescriptor.status,
                    channel: conversationDescriptor.sync_objects.conversation,
                    messages: conversationDescriptor.sync_objects.messages,
                    roster: "".concat(conversationDescriptor.conversation_sid, ".roster"),
                    lastConsumedMessageIndex: conversationDescriptor.last_read_message_index,
                    notificationLevel: conversationDescriptor.notification_level
                  };
                });
                pageToken = response.body.meta.next_token;
                conversations = [].concat(_toConsumableArray__default["default"](conversations), _toConsumableArray__default["default"](receivedConversations));

              case 10:
                if (pageToken) {
                  _context11.next = 2;
                  break;
                }

              case 11:
                return _context11.abrupt("return", conversations);

              case 12:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function _fetchMyConversations() {
        return _fetchMyConversations2.apply(this, arguments);
      }

      return _fetchMyConversations;
    }()
  }, {
    key: "_onConversationRemoved",
    value: function _onConversationRemoved(sid) {
      var conversation = this.conversations.get(sid);

      if (conversation) {
        this.conversations.delete(sid);
        this.emit("conversationRemoved", conversation);
      }
    }
  }, {
    key: "_registerForEvents",
    value: function _registerForEvents(conversation) {
      var _this6 = this;

      conversation.on("removed", function () {
        return _this6._onConversationRemoved(conversation.sid);
      });
      conversation.on("updated", function (args) {
        return _this6.emit("conversationUpdated", args);
      });
      conversation.on("participantJoined", function (participant) {
        return _this6.emit("participantJoined", participant);
      });
      conversation.on("participantLeft", function (participant) {
        return _this6.emit("participantLeft", participant);
      });
      conversation.on("participantUpdated", function (args) {
        return _this6.emit("participantUpdated", args);
      });
      conversation.on("messageAdded", function (message) {
        return _this6.emit("messageAdded", message);
      });
      conversation.on("messageUpdated", function (args) {
        return _this6.emit("messageUpdated", args);
      });
      conversation.on("messageRemoved", function (message) {
        return _this6.emit("messageRemoved", message);
      });
      conversation.on("typingStarted", function (participant) {
        return _this6.emit("typingStarted", participant);
      });
      conversation.on("typingEnded", function (participant) {
        return _this6.emit("typingEnded", participant);
      });
    }
  }]);

  return Conversations;
}(replayEventEmitter.ReplayEventEmitter);

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf__default["default"](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default["default"](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default["default"](this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Container for known users
 */

var Users = /*#__PURE__*/function (_ReplayEventEmitter) {
  _inherits__default["default"](Users, _ReplayEventEmitter);

  var _super = _createSuper$2(Users);

  function Users(myself, configuration, services) {
    var _this;

    _classCallCheck__default["default"](this, Users);

    _this = _super.call(this);
    _this.configuration = configuration;
    _this.services = services;
    _this.fifoStack = [];
    _this.myself = myself;

    _this.myself.on("updated", function (args) {
      return _this.emit("userUpdated", args);
    });

    _this.myself.on("userSubscribed", function () {
      return _this.emit("userSubscribed", _this.myself);
    });

    _this.myself.on("userUnsubscribed", function () {
      _this.emit("userUnsubscribed", _this.myself);

      _this.myself._ensureFetched();
    });

    _this.subscribedUsers = new Map();
    return _this;
  }

  _createClass__default["default"](Users, [{
    key: "handleUnsubscribeUser",
    value: function handleUnsubscribeUser(user) {
      if (this.subscribedUsers.has(user.identity)) {
        this.subscribedUsers.delete(user.identity);
      }

      var foundItemIndex = 0;
      var foundItem = this.fifoStack.find(function (item, index) {
        if (item == user.identity) {
          foundItemIndex = index;
          return true;
        }

        return false;
      });

      if (foundItem) {
        this.fifoStack.splice(foundItemIndex, 1);
      }

      this.emit("userUnsubscribed", user);
    }
  }, {
    key: "handleSubscribeUser",
    value: function handleSubscribeUser(user) {
      if (this.subscribedUsers.has(user.identity)) {
        return;
      }

      if (this.fifoStack.length >= this.configuration.userInfosToSubscribe) {
        var _this$subscribedUsers, _this$subscribedUsers2;

        var item = this.fifoStack.shift();
        (_this$subscribedUsers = this.subscribedUsers) === null || _this$subscribedUsers === void 0 ? void 0 : (_this$subscribedUsers2 = _this$subscribedUsers.get(item)) === null || _this$subscribedUsers2 === void 0 ? void 0 : _this$subscribedUsers2.unsubscribe();
      }

      this.fifoStack.push(user.identity);
      this.subscribedUsers.set(user.identity, user);
      this.emit("userSubscribed", user);
    }
    /**
     * Gets user, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the FIFO stack
     * @returns {Promise<User>} Fully initialized user
     */

  }, {
    key: "getUser",
    value: function () {
      var _getUser = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(identity, entityName) {
        var _entityName,
            _this2 = this;

        var user, newUser;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.myself._ensureFetched();

              case 2:
                if (!(identity == this.myself.identity)) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", this.myself);

              case 4:
                user = this.subscribedUsers.get(identity);

                if (!user) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return", user);

              case 7:
                if (!((_entityName = entityName) !== null && _entityName !== void 0)) {
                  _context.next = 11;
                  break;
                }
                _context.next = 14;
                break;

              case 11:
                _context.next = 13;
                return this.getSyncUniqueName(identity);

              case 13:
                entityName = _context.sent;

              case 14:
                newUser = new User(identity, entityName, this.configuration, this.services);
                newUser.on("updated", function (args) {
                  return _this2.emit("userUpdated", args);
                });
                newUser.on("userSubscribed", function () {
                  return _this2.handleSubscribeUser(newUser);
                });
                newUser.on("userUnsubscribed", function () {
                  return _this2.handleUnsubscribeUser(newUser);
                });
                _context.next = 20;
                return newUser._ensureFetched();

              case 20:
                return _context.abrupt("return", newUser);

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getUser(_x, _x2) {
        return _getUser.apply(this, arguments);
      }

      return getUser;
    }()
    /**
     * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}
     */

  }, {
    key: "getSubscribedUsers",
    value: function () {
      var _getSubscribedUsers = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2() {
        var users;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.myself._ensureFetched();

              case 2:
                users = [this.myself];
                this.subscribedUsers.forEach(function (user) {
                  return users.push(user);
                });
                return _context2.abrupt("return", users);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getSubscribedUsers() {
        return _getSubscribedUsers.apply(this, arguments);
      }

      return getSubscribedUsers;
    }()
    /**
     * @returns {Promise<string>} User's sync unique name
     */

  }, {
    key: "getSyncUniqueName",
    value: function () {
      var _getSyncUniqueName = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3(identity) {
        var _response$body$sync_o, _response$body;

        var url, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                url = new UriBuilder(this.configuration.links.users).path(identity).build();
                _context3.next = 3;
                return this.services.network.get(url);

              case 3:
                response = _context3.sent;
                return _context3.abrupt("return", (_response$body$sync_o = (_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.sync_objects.user_info_map) !== null && _response$body$sync_o !== void 0 ? _response$body$sync_o : "");

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getSyncUniqueName(_x3) {
        return _getSyncUniqueName.apply(this, arguments);
      }

      return getSyncUniqueName;
    }()
  }]);

  return Users;
}(replayEventEmitter.ReplayEventEmitter);

var log = Logger.scope("TypingIndicator");
/**
 * An important note in regards to typing timeout timers. There are two places that the SDK can get the "typing_timeout" attribute from. The first
 * place that the attribute appears in is the response received from POST -> /v1/typing REST call. In the body of that response, the value of the
 * "typing_timeout" attribute will be exactly the same as defined in the console. The second place that the attribute appears in is from a
 * notification of type "twilio.ipmsg.typing_indicator". In this case, the "typing_timeout" value will be +1 of that in the console. This
 * intentional. The timeout returned from the POST -> /v1/typing call should be used to disable further calls for that period of time. On contrary,
 * the timeout returned from the notification should be used as the timeout for the "typingEnded" event, +1 is to account for latency.
 *
 * @private
 */

/**
 * @class TypingIndicator
 *
 * @constructor
 * @private
 */

var TypingIndicator = /*#__PURE__*/function () {
  function TypingIndicator(getConversation, config, services) {
    _classCallCheck__default["default"](this, TypingIndicator);

    this.configuration = config;
    this.services = services;
    this.getConversation = getConversation;
    this.serviceTypingTimeout = null;
    this.sentUpdates = new Map();
  }

  _createClass__default["default"](TypingIndicator, [{
    key: "typingTimeout",
    get: function get() {
      return this.configuration.typingIndicatorTimeoutOverride || this.serviceTypingTimeout || this.configuration.typingIndicatorTimeoutDefault;
    }
    /**
     * Initialize TypingIndicator controller
     * Registers for needed message types and sets listeners
     * @private
     */

  }, {
    key: "initialize",
    value: function initialize() {
      var _this = this;

      // this.services.notificationClient.subscribe(NotificationTypes.TYPING_INDICATOR, 'twilsock');
      this.services.notificationClient.on("message", /*#__PURE__*/function () {
        var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(type, message) {
          return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(type === NotificationTypes.TYPING_INDICATOR)) {
                    _context.next = 3;
                    break;
                  }

                  _context.next = 3;
                  return _this._handleRemoteTyping(message);

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }());
    }
    /**
     * Remote participants typing events handler
     */

  }, {
    key: "_handleRemoteTyping",
    value: function () {
      var _handleRemoteTyping2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(message) {
        var _this2 = this;

        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                log.trace("Got new typing indicator ", message);
                this.getConversation(message.channel_sid).then(function (conversation) {
                  if (!conversation) {
                    return;
                  }

                  conversation._participants.forEach(function (participant) {
                    if (participant.identity !== message.identity) {
                      return;
                    }

                    var timeout = _this2.configuration.typingIndicatorTimeoutOverride ? _this2.configuration.typingIndicatorTimeoutOverride + 1000 : message.typing_timeout * 1000;

                    participant._startTyping(timeout);
                  });
                }).catch(function (err) {
                  log.error(err);
                  throw err;
                });

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _handleRemoteTyping(_x3) {
        return _handleRemoteTyping2.apply(this, arguments);
      }

      return _handleRemoteTyping;
    }()
    /**
     * Send typing event for the given conversation sid
     * @param {String} conversationSid
     */

  }, {
    key: "send",
    value: function send(conversationSid) {
      var lastUpdate = this.sentUpdates.get(conversationSid);

      if (lastUpdate && lastUpdate > Date.now() - this.typingTimeout) {
        return Promise.resolve();
      }

      this.sentUpdates.set(conversationSid, Date.now());
      return this._send(conversationSid);
    }
  }, {
    key: "_send",
    value: function _send(conversationSid) {
      var _this3 = this;

      log.trace("Sending typing indicator");
      var url = this.configuration.links.typing;
      var headers = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
      var body = "ChannelSid=".concat(conversationSid);
      return this.services.twilsockClient.post(url, headers, body, this.configuration.productId).then(function (response) {
        if (response.body.hasOwnProperty("typing_timeout")) {
          _this3.serviceTypingTimeout = response.body.typing_timeout * 1000;
        }
      }).catch(function (err) {
        log.error("Failed to send typing indicator:", err);
        throw err;
      });
    }
  }]);

  return TypingIndicator;
}();

/**
 * Push notification for a Conversations client.
 */
var PushNotification = /*#__PURE__*/_createClass__default["default"](
/**
 * Title of the notification.
 */

/**
 * Text of the notification.
 */

/**
 * Sound of the notification.
 */

/**
 * Number of the badge.
 */

/**
 * Notification action (`click_action` in FCM terms and `category` in APN terms).
 */

/**
 * Type of the notification.
 */

/**
 * Additional data of the conversation.
 */

/**
 * @internal
 */
function PushNotification(data) {
  _classCallCheck__default["default"](this, PushNotification);

  this.title = data.title || null;
  this.body = data.body || null;
  this.sound = data.sound || null;
  this.badge = data.badge || null;
  this.action = data.action || null;
  this.type = data.type || null;
  this.data = data.data || {};
});

var version = "2.4.0";

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf__default["default"](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default["default"](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default["default"](this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var trimSlashes = function trimSlashes(url) {
  return url.replace(/(^\/+|\/+$)/g, "");
};

var isMutationConflictResponse = function isMutationConflictResponse(response) {
  return response.status.code === 202;
};

var ChannelMetadataNotFoundError = /*#__PURE__*/function (_Error) {
  _inherits__default["default"](ChannelMetadataNotFoundError, _Error);

  var _super = _createSuper$1(ChannelMetadataNotFoundError);

  function ChannelMetadataNotFoundError(message) {
    _classCallCheck__default["default"](this, ChannelMetadataNotFoundError);

    return _super.call(this, message);
  }

  return _createClass__default["default"](ChannelMetadataNotFoundError);
}( /*#__PURE__*/_wrapNativeSuper__default["default"](Error));

var CommandExecutor = /*#__PURE__*/function () {
  function CommandExecutor(_serviceUrl, _services, _productId) {
    _classCallCheck__default["default"](this, CommandExecutor);

    this._serviceUrl = _serviceUrl;
    this._services = _services;
    this._productId = _productId;
  }

  _createClass__default["default"](CommandExecutor, [{
    key: "_preProcessUrl",
    value: function _preProcessUrl(url) {
      var trimmedUrl = trimSlashes(url);

      if (/^https?:\/\//.test(url)) {
        return trimmedUrl;
      }

      return "".concat(trimSlashes(this._serviceUrl), "/").concat(trimmedUrl);
    }
  }, {
    key: "_makeRequest",
    value: function () {
      var _makeRequest2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(method, url, requestBody, headers) {
        var preProcessedUrl, finalHeaders, response, getUrl;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                preProcessedUrl = this._preProcessUrl(url);
                finalHeaders = _objectSpread$1({
                  "Content-Type": "application/json; charset=utf-8"
                }, headers || {});
                _context.t0 = method;
                _context.next = _context.t0 === "get" ? 5 : _context.t0 === "post" ? 11 : _context.t0 === "delete" ? 15 : 19;
                break;

              case 5:
                getUrl = preProcessedUrl;

                if (requestBody) {
                  getUrl += "?" + Object.entries(requestBody).map(function (entry) {
                    return entry.map(encodeURIComponent).join("=");
                  }).join("&");
                }

                _context.next = 9;
                return this._services.transport.get(getUrl, finalHeaders, this._productId);

              case 9:
                response = _context.sent;
                return _context.abrupt("break", 19);

              case 11:
                _context.next = 13;
                return this._services.transport.post(preProcessedUrl, finalHeaders, JSON.stringify(requestBody), this._productId);

              case 13:
                response = _context.sent;
                return _context.abrupt("break", 19);

              case 15:
                _context.next = 17;
                return this._services.transport.delete(preProcessedUrl, finalHeaders, {}, this._productId);

              case 17:
                response = _context.sent;
                return _context.abrupt("break", 19);

              case 19:
                if (!(response.status.code < 200 || response.status.code >= 300)) {
                  _context.next = 21;
                  break;
                }

                throw new Error("Request responded with a non-success code ".concat(response.status.code));

              case 21:
                return _context.abrupt("return", response);

              case 22:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _makeRequest(_x, _x2, _x3, _x4) {
        return _makeRequest2.apply(this, arguments);
      }

      return _makeRequest;
    }()
  }, {
    key: "fetchResource",
    value: function () {
      var _fetchResource = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3(url, requestBody) {
        var _this = this;

        var maxAttemptsCount, retrier, resolution;
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                maxAttemptsCount = 6;
                retrier = new operationRetrier.AsyncRetrier({
                  min: 50,
                  max: 1600,
                  maxAttemptsCount: maxAttemptsCount
                });
                _context3.prev = 2;
                _context3.next = 5;
                return retrier.run( /*#__PURE__*/_asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2() {
                  var response, _e$body, _e$body2;

                  return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.prev = 0;
                          _context2.next = 3;
                          return _this._makeRequest("get", url, requestBody);

                        case 3:
                          response = _context2.sent;
                          return _context2.abrupt("return", {
                            type: "success",
                            data: response.body
                          });

                        case 7:
                          _context2.prev = 7;
                          _context2.t0 = _context2["catch"](0);

                          if (!((_context2.t0 === null || _context2.t0 === void 0 ? void 0 : (_e$body = _context2.t0.body) === null || _e$body === void 0 ? void 0 : _e$body.status) === 404 && (_context2.t0 === null || _context2.t0 === void 0 ? void 0 : (_e$body2 = _context2.t0.body) === null || _e$body2 === void 0 ? void 0 : _e$body2.code) === 50530)) {
                            _context2.next = 11;
                            break;
                          }

                          return _context2.abrupt("return", {
                            type: "noMetadata"
                          });

                        case 11:
                          throw _context2.t0;

                        case 12:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2, null, [[0, 7]]);
                })));

              case 5:
                resolution = _context3.sent;
                _context3.next = 11;
                break;

              case 8:
                _context3.prev = 8;
                _context3.t0 = _context3["catch"](2);
                throw new Error("Fetch resource from \"".concat(url, "\" failed."));

              case 11:
                if (!(resolution.type === "noMetadata")) {
                  _context3.next = 13;
                  break;
                }

                throw new ChannelMetadataNotFoundError("No metadata found.");

              case 13:
                return _context3.abrupt("return", resolution.data);

              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[2, 8]]);
      }));

      function fetchResource(_x5, _x6) {
        return _fetchResource.apply(this, arguments);
      }

      return fetchResource;
    }()
  }, {
    key: "mutateResource",
    value: function () {
      var _mutateResource = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee4(method, url, requestBody) {
        var result;
        return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._makeRequest(method, url, requestBody, {
                  "X-Twilio-Mutation-Id": uuid.v4()
                });

              case 2:
                result = _context4.sent;

                if (!isMutationConflictResponse(result)) {
                  _context4.next = 7;
                  break;
                }

                _context4.next = 6;
                return this.fetchResource(result.body.resource_url);

              case 6:
                return _context4.abrupt("return", _context4.sent);

              case 7:
                return _context4.abrupt("return", result.body);

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function mutateResource(_x7, _x8, _x9) {
        return _mutateResource.apply(this, arguments);
      }

      return mutateResource;
    }()
  }]);

  return CommandExecutor;
}();

var ContentClient = /*#__PURE__*/function () {
  function ContentClient(_services) {
    var _pageSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

    var _cacheTtlMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5000;

    _classCallCheck__default["default"](this, ContentClient);

    _defineProperty__default["default"](this, "_cachedTemplates", null);

    this._services = _services;
    this._pageSize = _pageSize;
    this._cacheTtlMs = _cacheTtlMs;
  }

  _createClass__default["default"](ContentClient, [{
    key: "getContentTemplates",
    value: function () {
      var _getContentTemplates = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee() {
        var _this = this;

        var _yield$this$_fetchCon, _yield$this$_fetchCon2, templatesPage, nextToken, templates, _yield$this$_fetchCon3, _yield$this$_fetchCon4;

        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this._cachedTemplates !== null)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", this._cachedTemplates);

              case 2:
                _context.next = 4;
                return this._fetchContentTemplates();

              case 4:
                _yield$this$_fetchCon = _context.sent;
                _yield$this$_fetchCon2 = _slicedToArray__default["default"](_yield$this$_fetchCon, 2);
                templatesPage = _yield$this$_fetchCon2[0];
                nextToken = _yield$this$_fetchCon2[1];
                templates = templatesPage;

              case 9:
                if (!(nextToken !== null)) {
                  _context.next = 19;
                  break;
                }

                _context.next = 12;
                return this._fetchContentTemplates(nextToken);

              case 12:
                _yield$this$_fetchCon3 = _context.sent;
                _yield$this$_fetchCon4 = _slicedToArray__default["default"](_yield$this$_fetchCon3, 2);
                templatesPage = _yield$this$_fetchCon4[0];
                nextToken = _yield$this$_fetchCon4[1];
                templates = [].concat(_toConsumableArray__default["default"](templates), _toConsumableArray__default["default"](templatesPage));
                _context.next = 9;
                break;

              case 19:
                this._cachedTemplates = Object.freeze(templates);
                setTimeout(function () {
                  _this._cachedTemplates = null;
                }, this._cacheTtlMs);
                return _context.abrupt("return", templates);

              case 22:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getContentTemplates() {
        return _getContentTemplates.apply(this, arguments);
      }

      return getContentTemplates;
    }()
  }, {
    key: "_fetchContentTemplates",
    value: function () {
      var _fetchContentTemplates2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(pageToken) {
        var contentTemplatesUrl, url, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                contentTemplatesUrl = "Client/v2/ContentTemplates";
                url = new UriBuilder(contentTemplatesUrl);
                url.arg("PageSize", this._pageSize);

                if (pageToken !== undefined) {
                  url.arg("PageToken", pageToken);
                }

                _context2.next = 6;
                return this._services.commandExecutor.fetchResource(url.build());

              case 6:
                response = _context2.sent;
                return _context2.abrupt("return", [response.templates.map(function (template) {
                  return new ContentTemplate(template);
                }), response.meta.next_token]);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _fetchContentTemplates(_x) {
        return _fetchContentTemplates2.apply(this, arguments);
      }

      return _fetchContentTemplates;
    }()
  }]);

  return ContentClient;
}();

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var QuickLRU = /*#__PURE__*/function (_Symbol$iterator) {
  function QuickLRU() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck__default["default"](this, QuickLRU);

    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError('`maxSize` must be a number greater than 0');
    }

    this.maxSize = options.maxSize;
    this.onEviction = options.onEviction;
    this.cache = new Map();
    this.oldCache = new Map();
    this._size = 0;
  }

  _createClass__default["default"](QuickLRU, [{
    key: "_set",
    value: function _set(key, value) {
      this.cache.set(key, value);
      this._size++;

      if (this._size >= this.maxSize) {
        this._size = 0;

        if (typeof this.onEviction === 'function') {
          var _iterator = _createForOfIteratorHelper(this.oldCache.entries()),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray__default["default"](_step.value, 2),
                  _key = _step$value[0],
                  _value = _step$value[1];

              this.onEviction(_key, _value);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        this.oldCache = this.cache;
        this.cache = new Map();
      }
    }
  }, {
    key: "get",
    value: function get(key) {
      if (this.cache.has(key)) {
        return this.cache.get(key);
      }

      if (this.oldCache.has(key)) {
        var value = this.oldCache.get(key);
        this.oldCache.delete(key);

        this._set(key, value);

        return value;
      }
    }
  }, {
    key: "set",
    value: function set(key, value) {
      if (this.cache.has(key)) {
        this.cache.set(key, value);
      } else {
        this._set(key, value);
      }

      return this;
    }
  }, {
    key: "has",
    value: function has(key) {
      return this.cache.has(key) || this.oldCache.has(key);
    }
  }, {
    key: "peek",
    value: function peek(key) {
      if (this.cache.has(key)) {
        return this.cache.get(key);
      }

      if (this.oldCache.has(key)) {
        return this.oldCache.get(key);
      }
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      var deleted = this.cache.delete(key);

      if (deleted) {
        this._size--;
      }

      return this.oldCache.delete(key) || deleted;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.cache.clear();
      this.oldCache.clear();
      this._size = 0;
    }
  }, {
    key: "keys",
    value: /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function keys() {
      var _iterator2, _step2, _step2$value, key;

      return _regeneratorRuntime__default["default"].wrap(function keys$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelper(this);
              _context.prev = 1;

              _iterator2.s();

            case 3:
              if ((_step2 = _iterator2.n()).done) {
                _context.next = 9;
                break;
              }

              _step2$value = _slicedToArray__default["default"](_step2.value, 1), key = _step2$value[0];
              _context.next = 7;
              return key;

            case 7:
              _context.next = 3;
              break;

            case 9:
              _context.next = 14;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](1);

              _iterator2.e(_context.t0);

            case 14:
              _context.prev = 14;

              _iterator2.f();

              return _context.finish(14);

            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, keys, this, [[1, 11, 14, 17]]);
    })
  }, {
    key: "values",
    value: /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function values() {
      var _iterator3, _step3, _step3$value, value;

      return _regeneratorRuntime__default["default"].wrap(function values$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _iterator3 = _createForOfIteratorHelper(this);
              _context2.prev = 1;

              _iterator3.s();

            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context2.next = 9;
                break;
              }

              _step3$value = _slicedToArray__default["default"](_step3.value, 2), value = _step3$value[1];
              _context2.next = 7;
              return value;

            case 7:
              _context2.next = 3;
              break;

            case 9:
              _context2.next = 14;
              break;

            case 11:
              _context2.prev = 11;
              _context2.t0 = _context2["catch"](1);

              _iterator3.e(_context2.t0);

            case 14:
              _context2.prev = 14;

              _iterator3.f();

              return _context2.finish(14);

            case 17:
            case "end":
              return _context2.stop();
          }
        }
      }, values, this, [[1, 11, 14, 17]]);
    })
  }, {
    key: _Symbol$iterator,
    value: /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function value() {
      var _iterator4, _step4, item, _iterator5, _step5, _item, _item2, key;

      return _regeneratorRuntime__default["default"].wrap(function value$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _iterator4 = _createForOfIteratorHelper(this.cache);
              _context3.prev = 1;

              _iterator4.s();

            case 3:
              if ((_step4 = _iterator4.n()).done) {
                _context3.next = 9;
                break;
              }

              item = _step4.value;
              _context3.next = 7;
              return item;

            case 7:
              _context3.next = 3;
              break;

            case 9:
              _context3.next = 14;
              break;

            case 11:
              _context3.prev = 11;
              _context3.t0 = _context3["catch"](1);

              _iterator4.e(_context3.t0);

            case 14:
              _context3.prev = 14;

              _iterator4.f();

              return _context3.finish(14);

            case 17:
              _iterator5 = _createForOfIteratorHelper(this.oldCache);
              _context3.prev = 18;

              _iterator5.s();

            case 20:
              if ((_step5 = _iterator5.n()).done) {
                _context3.next = 28;
                break;
              }

              _item = _step5.value;
              _item2 = _slicedToArray__default["default"](_item, 1), key = _item2[0];

              if (this.cache.has(key)) {
                _context3.next = 26;
                break;
              }

              _context3.next = 26;
              return _item;

            case 26:
              _context3.next = 20;
              break;

            case 28:
              _context3.next = 33;
              break;

            case 30:
              _context3.prev = 30;
              _context3.t1 = _context3["catch"](18);

              _iterator5.e(_context3.t1);

            case 33:
              _context3.prev = 33;

              _iterator5.f();

              return _context3.finish(33);

            case 36:
            case "end":
              return _context3.stop();
          }
        }
      }, value, this, [[1, 11, 14, 17], [18, 30, 33, 36]]);
    })
  }, {
    key: "size",
    get: function get() {
      var oldCacheSize = 0;

      var _iterator6 = _createForOfIteratorHelper(this.oldCache.keys()),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var key = _step6.value;

          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return Math.min(this._size + oldCacheSize, this.maxSize);
    }
  }]);

  return QuickLRU;
}(Symbol.iterator);

var quickLru = QuickLRU;

/**
 * Represents channel metadata.
 */

var ChannelMetadata = /*#__PURE__*/_createClass__default["default"](
/**
 * Communication channel type.
 */

/**
 * The actual metadata.
 */

/**
 * @internal
 */
function ChannelMetadata(type, data) {
  _classCallCheck__default["default"](this, ChannelMetadata);

  this.type = type;
  this.data = data;
  Object.freeze(data);
});

var ChannelMetadataClient = /*#__PURE__*/function () {
  function ChannelMetadataClient(services, configuration) {
    _classCallCheck__default["default"](this, ChannelMetadataClient);

    this._services = services;
    this._configuration = configuration;
    this._cache = new quickLru({
      maxSize: configuration.channelMetadataCacheCapacity
    });
  }

  _createClass__default["default"](ChannelMetadataClient, [{
    key: "getChannelMetadata",
    value: function () {
      var _getChannelMetadata = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(conversationSid, messageSid) {
        var key, cachedItem, url, metadataResponse, metadata;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                key = "".concat(conversationSid, ",").concat(messageSid);
                cachedItem = this._cache.get(key);

                if (!cachedItem) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", cachedItem.item);

              case 4:
                url = "".concat(this._configuration.links.conversations, "/").concat(conversationSid, "/Messages/").concat(messageSid, "/ChannelMetadata");
                _context.prev = 5;
                _context.next = 8;
                return this._services.commandExecutor.fetchResource(url);

              case 8:
                metadataResponse = _context.sent;
                _context.next = 17;
                break;

              case 11:
                _context.prev = 11;
                _context.t0 = _context["catch"](5);

                if (!(_context.t0 instanceof ChannelMetadataNotFoundError)) {
                  _context.next = 16;
                  break;
                }

                this._cache.set(key, {
                  item: null
                });

                return _context.abrupt("return", null);

              case 16:
                throw new Error(_context.t0);

              case 17:
                metadata = new ChannelMetadata(metadataResponse.type, metadataResponse.data);

                this._cache.set(key, {
                  item: metadata
                });

                return _context.abrupt("return", metadata);

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[5, 11]]);
      }));

      function getChannelMetadata(_x, _x2) {
        return _getChannelMetadata.apply(this, arguments);
      }

      return getChannelMetadata;
    }()
  }]);

  return ChannelMetadataClient;
}();

var _class;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf__default["default"](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default["default"](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default["default"](this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Client_1;
/**
 * Client services.
 */

var ClientServices = /*#__PURE__*/_createClass__default["default"](function ClientServices() {
  _classCallCheck__default["default"](this, ClientServices);
});
/**
 * A client is the starting point to the Twilio Conversations functionality.
 */


exports.Client = Client_1 = (_class = /*#__PURE__*/function (_ReplayEventEmitter) {
  _inherits__default["default"](Client, _ReplayEventEmitter);

  var _super = _createSuper(Client);

  /**
   * Fired when a conversation becomes visible to the client. The event is also
   * triggered when the client creates a new conversation.
   * Fired for all conversations that the client has joined.
   *
   * Parameters:
   * 1. {@link Conversation} `conversation` - the conversation in question
   * @event
   */

  /**
   * Fired when the client joins a conversation.
   *
   * Parameters:
   * 1. {@link Conversation} `conversation` - the conversation in question
   * @event
   */

  /**
   * Fired when the client leaves a conversation.
   *
   * Parameters:
   * 1. {@link Conversation} `conversation` - the conversation in question
   * @event
   */

  /**
   * Fired when a conversation is no longer visible to the client.
   *
   * Parameters:
   * 1. {@link Conversation} `conversation` - the conversation in question
   * @event
   */

  /**
   * Fired when the attributes or the metadata of a conversation have been
   * updated. During conversation's creation and initialization, this event
   * might be fired multiple times for same joined or created conversation as
   * new data is arriving from different sources.
   *
   * Parameters:
   * 1. object `data` - info object provided with the event. It has the
   * following properties:
   *     * {@link Conversation} `conversation` - the conversation in question
   *     * {@link ConversationUpdateReason}[] `updateReasons` - array of reasons
   *     for the update
   * @event
   */

  /**
   * Fired when a participant has joined a conversation.
   *
   * Parameters:
   * 1. {@link Participant} `participant` - the participant in question
   * @event
   */

  /**
   * Fired when a participant has left a conversation.
   *
   * Parameters:
   * 1. {@link Participant} `participant` - the participant in question
   * @event
   */

  /**
   * Fired when a participant's fields have been updated.
   *
   * Parameters:
   * 1. object `data` - info object provided with the event. It has the
   * following properties:
   *     * {@link Participant} `participant` - the participant in question
   *     * {@link ParticipantUpdateReason}[] `updateReasons` - array of reasons
   *     for the update
   * @event
   */

  /**
   * Fired when a new message has been added to the conversation on the server.
   *
   * Parameters:
   * 1. {@link Message} `message` - the message in question
   * @event
   */

  /**
   * Fired when a message is removed from the message list of a conversation.
   *
   * Parameters:
   * 1. {@link Message} `message` - the message in question
   * @event
   */

  /**
   * Fired when the fields of an existing message are updated with new values.
   *
   * Parameters:
   * 1. object `data` - info object provided with the event. It has the
   * following properties:
   *     * {@link Message} `message` - the message in question
   *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for
   *     the update
   * @event
   */

  /**
   * Fired when the token is about to expire and needs to be updated.
   * @event
   */

  /**
   * Fired when the token has expired.
   * @event
   */

  /**
   * Fired when a participant has stopped typing.
   *
   * Parameters:
   * 1. {@link Participant} `participant` - the participant in question
   * @event
   */

  /**
   * Fired when a participant has started typing.
   *
   * Parameters:
   * 1. {@link Participant} `participant` - the participant in question
   * @event
   */

  /**
   * Fired when the client has received (and parsed) a push notification via one
   * of the push channels (apn or fcm).
   *
   * Parameters:
   * 1. {@link PushNotification} `pushNotification` - the push notification in
   * question
   * @event
   */

  /**
   * Fired when the client has subscribed to a user.
   *
   * Parameters:
   * 1. {@link User} `user` - the user in question
   * @event
   */

  /**
   * Fired when the client has unsubscribed from a user.
   *
   * Parameters:
   * 1. {@link User} `user` - the user in question
   * @event
   */

  /**
   * Fired when the properties or the reachability status of a user have been
   * updated.
   *
   * Parameters:
   * 1. object `data` - info object provided with the event. It has the
   * following properties:
   *     * {@link User} `user` - the user in question
   *     * {@link UserUpdateReason}[] `updateReasons` - array of reasons for the
   *     update
   * @event
   */

  /**
   * @deprecated Use initialized or initFailed events instead
   * Fired when the state of the client has been changed.
   *
   * Parameters:
   * 1. {@link State} `state` - the new client state
   * @event
   */

  /**
   * Fired when the client has completed initialization successfully.
   * @event
   */

  /**
   * Fired when the client initialization failed.
   *
   * Parameters:
   * 1. object `data` - info object provided with the event. It has the
   * following property:
   *     * Error? `error` - the initialization error if present
   * @event
   */

  /**
   * Fired when the connection state of the client has been changed.
   *
   * Parameters:
   * 1. {@link ConnectionState} `state` - the new connection state
   * @event
   */

  /**
   * Fired when the connection is interrupted for an unexpected reason.
   *
   * Parameters:
   * 1. object `data` - info object provided with the event. It has the
   * following properties:
   *     * boolean `terminal` - Twilsock will stop connection attempts if true
   *     * string `message` - the error message of the root cause
   *     * number? `httpStatusCode` - http status code if available
   *     * number? `errorCode` - Twilio public error code if available
   * @event
   */

  /**
   * Current version of the Conversations client.
   */

  /**
   * Logger instance.
   */

  /**
   * Supported push notification channels.
   */

  /**
   * Supported push data fields.
   */

  /**
   * Current version of the Conversations client.
   */

  /**
   * Client connection state.
   */

  /**
   * Returned Conversations instance is not yet fully initialized. Calling any
   * operations will block until it is. Use connection events to monitor when
   * client becomes fully available (connectionStateChanged with state
   * 'connected') or not available (connectionStateChange with state 'denied',
   * event tokenExpired, event connectionError).
   *
   * @param fpaToken Access token
   * @param options Options to customize the Client
   * @returns A not yet fully-initialized client.
   */
  function Client(fpaToken) {
    var _this$_options$logLev, _this$_options$twilso, _this$_options$transp, _this$_options$notifi, _this$_options$syncCl;

    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck__default["default"](this, Client);

    _this = _super.call(this);

    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "version", version);

    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "connectionState", "unknown");

    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "parsePushNotification", Client_1.parsePushNotification);

    _this._fpaToken = fpaToken !== null && fpaToken !== void 0 ? fpaToken : "";
    _this._options = options !== null && options !== void 0 ? options : {};

    if (!_this._options.disableDeepClone) {
      var _options = _objectSpread(_objectSpread({}, _this._options), {}, {
        transport: undefined,
        twilsockClient: undefined
      });

      _options = deepClone(_options);
      _options.transport = _this._options.transport;
      _options.twilsockClient = _this._options.twilsockClient;
      _this._options = _options;
    }

    _this._options.logLevel = (_this$_options$logLev = _this._options.logLevel) !== null && _this$_options$logLev !== void 0 ? _this$_options$logLev : "silent";

    Client_1._logger.setLevel(_this._options.logLevel);

    var productId = _this._options.productId = "ip_messaging"; // Filling ClientMetadata

    _this._options.clientMetadata = _this._options.clientMetadata || {};

    if (!_this._options.clientMetadata.hasOwnProperty("type")) {
      _this._options.clientMetadata.type = "conversations";
    }

    if (!_this._options.clientMetadata.hasOwnProperty("sdk")) {
      _this._options.clientMetadata.sdk = "JS";
      _this._options.clientMetadata.sdkv = version;
    } // Enable session local storage for Sync


    _this._options.Sync = _this._options.Sync || {};

    if (typeof _this._options.Sync.enableSessionStorage === "undefined") {
      _this._options.Sync.enableSessionStorage = true;
    }

    if (_this._options.region) {
      _this._options.Sync.region = _this._options.region;
    }

    if (!fpaToken) {
      throw new Error("A valid Twilio token should be provided");
    }

    _this._services = new ClientServices();
    _this._myself = new User("", "", null, _this._services);
    var startTwilsock = !_this._options.twilsockClient; // Create default init registrations if none were provided.
    // Otherwise, the outside party have to list all the init registrations they
    // need.
    // Init registrations passed to the Conversations client will be passed down
    // to the Sync client as well.

    if (!_this._options.initRegistrations) {
      var initRegistration = new twilsock.InitRegistration(productId);
      Client_1.populateInitRegistrations(initRegistration);
      _this._options.initRegistrations = [initRegistration];
    }

    _this._services.twilsockClient = _this._options.twilsockClient = (_this$_options$twilso = _this._options.twilsockClient) !== null && _this$_options$twilso !== void 0 ? _this$_options$twilso : new twilsock.TwilsockClient(fpaToken, productId, _this._options);

    _this._services.twilsockClient.on("tokenAboutToExpire", function () {
      return _this.emit("tokenAboutToExpire");
    });

    _this._services.twilsockClient.on("tokenExpired", function () {
      return _this.emit("tokenExpired");
    });

    _this._services.twilsockClient.on("connectionError", function (error) {
      return _this.emit("connectionError", error);
    });

    _this._services.twilsockClient.on("stateChanged", function (state) {
      Client_1._logger.debug("Handling stateChanged for ConversationsClient: new state ".concat(state));

      if (state !== _this.connectionState) {
        _this.connectionState = state;

        _this.emit("connectionStateChanged", _this.connectionState);
      }
    });

    _this._services.transport = _this._options.transport = (_this$_options$transp = _this._options.transport) !== null && _this$_options$transp !== void 0 ? _this$_options$transp : _this._options.twilsockClient;
    _this._services.notificationClient = _this._options.notificationsClient = (_this$_options$notifi = _this._options.notificationsClient) !== null && _this$_options$notifi !== void 0 ? _this$_options$notifi : new notifications.Notifications(fpaToken, _this._options);
    _this._services.syncClient = _this._options.syncClient = (_this$_options$syncCl = _this._options.syncClient) !== null && _this$_options$syncCl !== void 0 ? _this$_options$syncCl : new twilioSync.SyncClient(fpaToken, _this._options);
    var configurationOptions = (options === null || options === void 0 ? void 0 : options.Chat) || (options === null || options === void 0 ? void 0 : options.IPMessaging) || options || {};
    var region = configurationOptions.region || (options === null || options === void 0 ? void 0 : options.region);
    var baseUrl = configurationOptions.apiUri || configurationOptions.typingUri || "https://aim.".concat(region || "us1", ".twilio.com");
    _this._services.commandExecutor = new CommandExecutor(baseUrl, {
      transport: _this._options.transport
    }, productId);
    _this._services.contentClient = new ContentClient(_this._services);

    var emitFailed = function emitFailed(error) {
      _this._rejectEnsureReady(error);

      _this.emit("stateChanged", "failed");

      _this.emit("initFailed", {
        error: error
      });
    };

    var emitDisconnected = function emitDisconnected() {
      emitFailed({
        terminal: true,
        message: "Twilsock has disconnected."
      });
    };

    _this._services.twilsockClient.once("connectionError", emitFailed);

    _this._services.twilsockClient.once("disconnected", emitDisconnected);

    _this._services.twilsockClient.once("connected", /*#__PURE__*/_asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee() {
      var startupEvent, connectionError;
      return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              Client_1._logger.debug("ConversationsClient started INITIALIZING");

              _this._services.twilsockClient.off("connectionError", emitFailed);

              _this._services.twilsockClient.off("disconnected", emitDisconnected);

              _context.prev = 3;
              startupEvent = "conversations.client.startup";

              _this._services.twilsockClient.addPartialTelemetryEvent(new twilsock.TelemetryEventDescription(startupEvent, "Conversations client startup", new Date()), startupEvent, twilsock.TelemetryPoint.Start);

              _context.next = 8;
              return _this._initialize();

            case 8:
              _this._services.twilsockClient.addPartialTelemetryEvent(new twilsock.TelemetryEventDescription("", "", new Date()), startupEvent, twilsock.TelemetryPoint.End);

              _context.next = 17;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](3);
              // Fail ChatClient if initialization is incomplete
              connectionError = {
                terminal: true,
                message: _context.t0.message
              };

              _this._rejectEnsureReady(connectionError);

              _this.emit("stateChanged", "failed");

              _this.emit("initFailed", {
                error: connectionError
              });

            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 11]]);
    })));

    _this._ensureReady = new Promise(function (resolve, reject) {
      _this._resolveEnsureReady = resolve;
      _this._rejectEnsureReady = reject;
    }).catch(function () {
      return void 0;
    }); // @todo How to process unhandled rejection here?

    if (startTwilsock) {
      _this._services.twilsockClient.connect();
    }

    return _this;
  }
  /**
   * Information of the logged-in user. Before client initialization, returns an
   * uninitialized user. Will trigger a {@link Client.userUpdated} event after
   * initialization.
   */


  _createClass__default["default"](Client, [{
    key: "user",
    get: function get() {
      return this._myself;
    }
    /**
     * Client reachability state. Throws an error if accessed before the client
     * initialization was completed.
     */

  }, {
    key: "reachabilityEnabled",
    get: function get() {
      if (!this._configuration) {
        throw new Error("Reachability information could not yet be accessed as the client " + "has not yet been initialized. Subscribe to the 'stateChanged' event " + "to properly react to the client initialization.");
      }

      return this._configuration.reachabilityEnabled;
    }
    /**
     * @deprecated
     * Current token.
     * @internal
     */

  }, {
    key: "token",
    get: function get() {
      return this._fpaToken;
    }
    /**
     * @deprecated Call constructor directly.
     *
     * Factory method to create a Conversations client instance.
     *
     * The factory method will automatically trigger connection.
     * Do not use it if you need finer-grained control.
     *
     * Since this method returns an already-initialized client, some of the events
     * will be lost because they happen *before* the initialization. It is
     * recommended that `client.onWithReplay` is used as opposed to `client.on`
     * for subscribing to client events. The `client.onWithReplay` will re-emit
     * the most recent value for a given event if it emitted before the
     * subscription.
     *
     * @param token Access token.
     * @param options Options to customize the client.
     * @returns Returns a fully initialized client.
     */

  }, {
    key: "shutdown",
    value:
    /**
     * Gracefully shut down the client.
     */
    function () {
      var _shutdown = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2() {
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._ensureReady;

              case 2:
                _context2.next = 4;
                return this._services.twilsockClient.disconnect();

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function shutdown() {
        return _shutdown.apply(this, arguments);
      }

      return shutdown;
    }()
    /**
     * Update the token used by the client and re-register with the Conversations services.
     * @param token New access token.
     */

  }, {
    key: "updateToken",
    value: function () {
      var _updateToken = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3(token) {
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._ensureReady;

              case 2:
                Client_1._logger.info("updateToken");

                if (!(this._fpaToken === token)) {
                  _context3.next = 5;
                  break;
                }

                return _context3.abrupt("return", this);

              case 5:
                _context3.next = 7;
                return this._services.twilsockClient.updateToken(token);

              case 7:
                _context3.next = 9;
                return this._services.notificationClient.updateToken(token);

              case 9:
                _context3.next = 11;
                return this._services.mcsClient.updateToken(token);

              case 11:
                this._fpaToken = token;
                return _context3.abrupt("return", this);

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function updateToken(_x) {
        return _updateToken.apply(this, arguments);
      }

      return updateToken;
    }()
    /**
     * Get a known conversation by its SID.
     * @param conversationSid Conversation sid
     */

  }, {
    key: "getConversationBySid",
    value: function () {
      var _getConversationBySid = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee4(conversationSid) {
        var conversation;
        return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._ensureReady;

              case 2:
                _context4.next = 4;
                return this._conversationsEntity.myConversationsRead.promise;

              case 4:
                _context4.next = 6;
                return this._conversationsEntity.getConversation(conversationSid);

              case 6:
                conversation = _context4.sent;

                if (conversation) {
                  _context4.next = 12;
                  break;
                }

                _context4.next = 10;
                return this.peekConversationBySid(conversationSid);

              case 10:
                conversation = _context4.sent;

                if (conversation) {
                  deprecationDecorator.deprecationWarning("The method getConversationBySid is deprecated to retrieve conversations you're not part of. Use peekConversationBySid instead.");
                }

              case 12:
                if (conversation) {
                  _context4.next = 14;
                  break;
                }

                throw new Error("Conversation with SID ".concat(conversationSid, " was not found."));

              case 14:
                return _context4.abrupt("return", conversation);

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getConversationBySid(_x2) {
        return _getConversationBySid.apply(this, arguments);
      }

      return getConversationBySid;
    }()
    /**
     * Peek a conversation by its SID.
     * @param conversationSid Conversation sid
     * @internal
     */

  }, {
    key: "peekConversationBySid",
    value: function () {
      var _peekConversationBySid = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee5(conversationSid) {
        var conversation;
        return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._ensureReady;

              case 2:
                _context5.next = 4;
                return this._conversationsEntity.peekConversation(conversationSid);

              case 4:
                conversation = _context5.sent;

                if (conversation) {
                  _context5.next = 7;
                  break;
                }

                throw new Error("Conversation with SID ".concat(conversationSid, " was not found."));

              case 7:
                return _context5.abrupt("return", conversation);

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function peekConversationBySid(_x3) {
        return _peekConversationBySid.apply(this, arguments);
      }

      return peekConversationBySid;
    }()
    /**
     * Get a known conversation by its unique identifier name.
     * @param uniqueName The unique identifier name of the conversation.
     */

  }, {
    key: "getConversationByUniqueName",
    value: function () {
      var _getConversationByUniqueName = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee6(uniqueName) {
        var conversation;
        return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._ensureReady;

              case 2:
                _context6.next = 4;
                return this._conversationsEntity.myConversationsRead.promise;

              case 4:
                _context6.next = 6;
                return this._conversationsEntity.getConversationByUniqueName(uniqueName);

              case 6:
                conversation = _context6.sent;

                if (conversation) {
                  _context6.next = 9;
                  break;
                }

                throw new Error("Conversation with unique name ".concat(uniqueName, " was not found."));

              case 9:
                return _context6.abrupt("return", conversation);

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getConversationByUniqueName(_x4) {
        return _getConversationByUniqueName.apply(this, arguments);
      }

      return getConversationByUniqueName;
    }()
    /**
     * Get the current list of all the subscribed conversations.
     */

  }, {
    key: "getSubscribedConversations",
    value: function () {
      var _getSubscribedConversations = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee7() {
        return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._ensureReady;

              case 2:
                return _context7.abrupt("return", this._conversationsPromise.then(function (conversations) {
                  return conversations.getConversations();
                }));

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getSubscribedConversations() {
        return _getSubscribedConversations.apply(this, arguments);
      }

      return getSubscribedConversations;
    }()
    /**
     * Create a conversation on the server and subscribe to its events.
     * The default is a conversation with an empty friendly name.
     * @param options Options for the conversation.
     */

  }, {
    key: "createConversation",
    value: function () {
      var _createConversation = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee8(options) {
        return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._ensureReady;

              case 2:
                options = options || {};
                return _context8.abrupt("return", this._conversationsPromise.then(function (conversationsEntity) {
                  return conversationsEntity.addConversation(options);
                }));

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function createConversation(_x5) {
        return _createConversation.apply(this, arguments);
      }

      return createConversation;
    }()
    /**
     * Register for push notifications.
     * @param channelType Channel type.
     * @param registrationId Push notification ID provided by the FCM/APNS service
     * on the platform.
     */

  }, {
    key: "setPushRegistrationId",
    value: function () {
      var _setPushRegistrationId = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee9(channelType, registrationId) {
        return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._ensureReady;

              case 2:
                this._subscribeToPushNotifications(channelType);

                this._services.notificationClient.setPushRegistrationId(channelType, registrationId);

                _context9.next = 6;
                return this._services.notificationClient.commitChanges();

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function setPushRegistrationId(_x6, _x7) {
        return _setPushRegistrationId.apply(this, arguments);
      }

      return setPushRegistrationId;
    }()
    /**
     * Unregister from push notifications.
     * @param channelType Channel type.
     * @deprecated Use removePushRegistrations() instead.
     */

  }, {
    key: "unsetPushRegistrationId",
    value: function () {
      var _unsetPushRegistrationId = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee10(channelType) {
        return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this._ensureReady;

              case 2:
                this._unsubscribeFromPushNotifications(channelType);

                _context10.next = 5;
                return this._services.notificationClient.commitChanges();

              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function unsetPushRegistrationId(_x8) {
        return _unsetPushRegistrationId.apply(this, arguments);
      }

      return unsetPushRegistrationId;
    }()
    /**
     * Clear existing registrations directly using provided device token.
     * This is useful to ensure stopped subscriptions without resubscribing.
     *
     * This function goes completely beside the state machine and removes all
     * registrations.
     * Use with caution: if it races with current state machine operations,
     * madness will ensue.
     *
     * @param channelType Channel type.
     * @param registrationId Push notification ID provided by the FCM/APNS service
     * on the platform.
     */

  }, {
    key: "removePushRegistrations",
    value: function () {
      var _removePushRegistrations = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee11(channelType, registrationId) {
        return _regeneratorRuntime__default["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this._services.notificationClient.removeRegistrations(channelType, registrationId);

              case 2:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function removePushRegistrations(_x9, _x10) {
        return _removePushRegistrations.apply(this, arguments);
      }

      return removePushRegistrations;
    }()
    /**
     * Current version of the Conversations client.
     */

  }, {
    key: "handlePushNotification",
    value:
    /**
     * Handle push notification payload parsing and emit the
     * {@link Client.pushNotification} event on this {@link Client} instance.
     * @param notificationPayload Push notification payload
     */
    function () {
      var _handlePushNotification = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee12(notificationPayload) {
        return _regeneratorRuntime__default["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this._ensureReady;

              case 2:
                Client_1._logger.debug("handlePushNotification, notificationPayload=", notificationPayload);

                this.emit("pushNotification", Client_1.parsePushNotification(notificationPayload));

              case 4:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function handlePushNotification(_x11) {
        return _handlePushNotification.apply(this, arguments);
      }

      return handlePushNotification;
    }()
    /**
     * Gets a user with the given identity. If it's in the subscribed list, then
     * return the user object from it;
     * if not, then subscribe and add user to the subscribed list.
     * @param identity Identity of the user.
     * @returns A fully initialized user.
     */

  }, {
    key: "getUser",
    value: function () {
      var _getUser = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee13(identity) {
        return _regeneratorRuntime__default["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this._ensureReady;

              case 2:
                return _context13.abrupt("return", this._services.users.getUser(identity));

              case 3:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getUser(_x12) {
        return _getUser.apply(this, arguments);
      }

      return getUser;
    }()
    /**
     * Get a list of subscribed user objects.
     */

  }, {
    key: "getSubscribedUsers",
    value: function () {
      var _getSubscribedUsers = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee14() {
        return _regeneratorRuntime__default["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this._ensureReady;

              case 2:
                return _context14.abrupt("return", this._services.users.getSubscribedUsers());

              case 3:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function getSubscribedUsers() {
        return _getSubscribedUsers.apply(this, arguments);
      }

      return getSubscribedUsers;
    }()
    /**
     * Get content URLs for all media attachments in the given set of media sids
     * using a single operation.
     * @param mediaSids Set of media sids to query for the content URL.
     */

  }, {
    key: "getTemporaryContentUrlsForMediaSids",
    value: function getTemporaryContentUrlsForMediaSids(mediaSids) {
      var _this2 = this;

      return new mcsClient.CancellablePromise( /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee15(resolve, reject, onCancel) {
          var request, urls;
          return _regeneratorRuntime__default["default"].wrap(function _callee15$(_context15) {
            while (1) {
              switch (_context15.prev = _context15.next) {
                case 0:
                  if (!(!_this2._services.mcsClient || !mediaSids)) {
                    _context15.next = 3;
                    break;
                  }

                  reject(new Error("Media Content Service is unavailable"));
                  return _context15.abrupt("return");

                case 3:
                  request = _this2._services.mcsClient.mediaSetGetContentUrls(mediaSids);
                  onCancel(function () {
                    request.cancel();
                  });
                  _context15.prev = 5;
                  _context15.next = 8;
                  return request;

                case 8:
                  urls = _context15.sent;
                  resolve(urls);
                  _context15.next = 15;
                  break;

                case 12:
                  _context15.prev = 12;
                  _context15.t0 = _context15["catch"](5);
                  reject(_context15.t0);

                case 15:
                case "end":
                  return _context15.stop();
              }
            }
          }, _callee15, null, [[5, 12]]);
        }));

        return function (_x13, _x14, _x15) {
          return _ref2.apply(this, arguments);
        };
      }());
    }
    /**
     * Get content URLs for all media attachments in the given set using a single
     * operation.
     * @param contentSet Set of media attachments to query content URLs.
     */

  }, {
    key: "getTemporaryContentUrlsForMedia",
    value: function getTemporaryContentUrlsForMedia(contentSet) {
      // We ignore existing mcsMedia members of each of the media entries.
      // Instead, we just collect their sids and pull new descriptors from a
      // mediaSet GET endpoint.
      var sids = contentSet.map(function (m) {
        return m.sid;
      });
      return this.getTemporaryContentUrlsForMediaSids(sids);
    }
    /**
     * Returns rich content templates belonging to the account. Rich content
     * templates can be created via the Twilio console or the REST API.
     */

  }, {
    key: "getContentTemplates",
    value: function () {
      var _getContentTemplates = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee16() {
        return _regeneratorRuntime__default["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this._ensureReady;

              case 2:
                _context16.next = 4;
                return this._services.contentClient.getContentTemplates();

              case 4:
                return _context16.abrupt("return", _context16.sent);

              case 5:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function getContentTemplates() {
        return _getContentTemplates.apply(this, arguments);
      }

      return getContentTemplates;
    }()
    /**
     * Initialize the client.
     */

  }, {
    key: "_initialize",
    value: function () {
      var _initialize2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee17() {
        var _this3 = this;

        var configurationResponse;
        return _regeneratorRuntime__default["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this._services.commandExecutor.fetchResource("Client/v2/Configuration");

              case 2:
                configurationResponse = _context17.sent;
                this._configuration = new Configuration(this._options, configurationResponse, Client_1._logger);
                this._services.channelMetadataClient = new ChannelMetadataClient(this._services, this._configuration);

                this._myself._resolveInitialization(this._configuration, this._configuration.userIdentity, this._configuration.userInfo, true);

                this._services.typingIndicator = new TypingIndicator(this.getConversationBySid.bind(this), this._configuration, this._services);
                this._services.network = new Network(this._configuration, this._services);
                this._services.users = new Users(this._myself, this._configuration, this._services);

                this._services.users.on("userSubscribed", function (user) {
                  _this3.emit("userSubscribed", user);
                });

                this._services.users.on("userUpdated", function (args) {
                  return _this3.emit("userUpdated", args);
                });

                this._services.users.on("userUnsubscribed", function (user) {
                  _this3.emit("userUnsubscribed", user);
                });

                this._conversationsEntity = new Conversations(this._configuration, this._services);

                this._conversationsEntity.on("conversationAdded", function (conversation) {
                  _this3.emit("conversationAdded", conversation);
                });

                this._conversationsEntity.on("conversationRemoved", function (conversation) {
                  _this3.emit("conversationRemoved", conversation);
                });

                this._conversationsEntity.on("conversationJoined", function (conversation) {
                  _this3.emit("conversationJoined", conversation);
                });

                this._conversationsEntity.on("conversationLeft", function (conversation) {
                  _this3.emit("conversationLeft", conversation);
                });

                this._conversationsEntity.on("conversationUpdated", function (args) {
                  return _this3.emit("conversationUpdated", args);
                });

                this._conversationsEntity.on("participantJoined", function (participant) {
                  _this3.emit("participantJoined", participant);
                });

                this._conversationsEntity.on("participantLeft", function (participant) {
                  _this3.emit("participantLeft", participant);
                });

                this._conversationsEntity.on("participantUpdated", function (args) {
                  return _this3.emit("participantUpdated", args);
                });

                this._conversationsEntity.on("messageAdded", function (message) {
                  return _this3.emit("messageAdded", message);
                });

                this._conversationsEntity.on("messageUpdated", function (args) {
                  return _this3.emit("messageUpdated", args);
                });

                this._conversationsEntity.on("messageRemoved", function (message) {
                  return _this3.emit("messageRemoved", message);
                });

                this._conversationsEntity.on("typingStarted", function (participant) {
                  return _this3.emit("typingStarted", participant);
                });

                this._conversationsEntity.on("typingEnded", function (participant) {
                  return _this3.emit("typingEnded", participant);
                });

                this._conversationsPromise = this._conversationsEntity.fetchConversations().then(function () {
                  return _this3._conversationsEntity;
                }).catch(function (error) {
                  throw error;
                });
                _context17.next = 29;
                return this._services.users.myself._ensureFetched();

              case 29:
                Client_1._supportedPushChannels.forEach(function (channelType) {
                  return _this3._subscribeToPushNotifications(channelType);
                });

                this._services.typingIndicator.initialize();

                this._services.mcsClient = new mcsClient.McsClient(this._fpaToken, this._configuration.links.mediaService, this._configuration.links.mediaSetService, _objectSpread(_objectSpread({}, this._options), {}, {
                  transport: undefined
                }));

                this._resolveEnsureReady();

                this.emit("stateChanged", "initialized");
                this.emit("initialized");

              case 35:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function _initialize() {
        return _initialize2.apply(this, arguments);
      }

      return _initialize;
    }()
    /**
     * Subscribe to push notifications.
     * @param channelType The channel type to subscribe to.
     */

  }, {
    key: "_subscribeToPushNotifications",
    value: function _subscribeToPushNotifications(channelType) {
      var _this4 = this;

      [NotificationTypes.NEW_MESSAGE, NotificationTypes.ADDED_TO_CONVERSATION, NotificationTypes.REMOVED_FROM_CONVERSATION, NotificationTypes.TYPING_INDICATOR, NotificationTypes.CONSUMPTION_UPDATE].forEach(function (messageType) {
        _this4._services.notificationClient.subscribe(channelType, messageType);
      });
    }
    /**
     * Unsubscribe from push notifications.
     * @param channelType The channel type to unsubscribe from.
     */

  }, {
    key: "_unsubscribeFromPushNotifications",
    value: function _unsubscribeFromPushNotifications(channelType) {
      var _this5 = this;

      [NotificationTypes.NEW_MESSAGE, NotificationTypes.ADDED_TO_CONVERSATION, NotificationTypes.REMOVED_FROM_CONVERSATION, NotificationTypes.TYPING_INDICATOR, NotificationTypes.CONSUMPTION_UPDATE].forEach(function (messageType) {
        _this5._services.notificationClient.unsubscribe(channelType, messageType);
      });
    }
  }], [{
    key: "create",
    value: function () {
      var _create = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee18(token, options) {
        var client;
        return _regeneratorRuntime__default["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                if (!(options !== null && options !== void 0 && options.twilsockClient)) {
                  _context18.next = 2;
                  break;
                }

                throw new Error("Obsolete usage of ConversationsClient.create() " + "factory method: if you pass twilsock from the outside then you must " + "use ConversationsClient constructor and be prepared to work with " + "uninitialized client.");

              case 2:
                client = new Client_1(token, options);
                _context18.next = 5;
                return client._ensureReady;

              case 5:
                return _context18.abrupt("return", client);

              case 6:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18);
      }));

      function create(_x16, _x17) {
        return _create.apply(this, arguments);
      }

      return create;
    }()
    /**
     * Static method for push notification payload parsing. Returns parsed push as
     * a {@link PushNotification} object.
     * @param notificationPayload Push notification payload.
     */

  }, {
    key: "parsePushNotification",
    value: function parsePushNotification(notificationPayload) {
      Client_1._logger.debug("parsePushNotification, notificationPayload=", notificationPayload); // APNS specifics


      if (typeof notificationPayload.aps !== "undefined") {
        if (!notificationPayload.twi_message_type) {
          throw new Error("Provided push notification payload does not contain Programmable Chat push notification type");
        }

        var data = Client_1._parsePushNotificationChatData(notificationPayload);

        var apsPayload = notificationPayload.aps;
        var body;
        var title = null;

        if (typeof apsPayload.alert === "string") {
          body = apsPayload.alert || null;
        } else {
          var _apsPayload$alert, _apsPayload$alert2;

          body = ((_apsPayload$alert = apsPayload.alert) === null || _apsPayload$alert === void 0 ? void 0 : _apsPayload$alert.body) || null;
          title = ((_apsPayload$alert2 = apsPayload.alert) === null || _apsPayload$alert2 === void 0 ? void 0 : _apsPayload$alert2.title) || null;
        }

        return new PushNotification({
          title: title,
          body: body,
          sound: apsPayload.sound || null,
          badge: apsPayload.badge || null,
          action: apsPayload.category || null,
          type: notificationPayload.twi_message_type,
          data: data
        });
      } // FCM specifics


      if (typeof notificationPayload.data !== "undefined") {
        var dataPayload = notificationPayload.data;

        if (!dataPayload.twi_message_type) {
          throw new Error("Provided push notification payload does not contain Programmable Chat push notification type");
        }

        var _data = Client_1._parsePushNotificationChatData(notificationPayload.data);

        return new PushNotification({
          title: dataPayload.twi_title || null,
          body: dataPayload.twi_body || null,
          sound: dataPayload.twi_sound || null,
          badge: null,
          action: dataPayload.twi_action || null,
          type: dataPayload.twi_message_type,
          data: _data
        });
      }

      throw new Error("Provided push notification payload is not Programmable Chat notification");
    }
    /**
     * Static method for parsing push notification chat data.
     * @param data Data to parse
     */

  }, {
    key: "_parsePushNotificationChatData",
    value: function _parsePushNotificationChatData(data) {
      var result = {};

      for (var key in Client_1._supportedPushDataFields) {
        var value = data[key];

        if (typeof value === "undefined" || value === null) {
          continue;
        }

        if (key === "message_index" || key === "media_count") {
          var number = parseToNumber(value);

          if (number !== null) {
            result[Client_1._supportedPushDataFields[key]] = number;
          }

          continue;
        }

        if (key === "media") {
          if (typeof value === "string") {
            try {
              result[Client_1._supportedPushDataFields[key]] = JSON.parse(value);
            } catch (_unused) {
              Client_1._logger.debug("Media message notification parsing error");
            }
          }

          continue;
        }

        result[Client_1._supportedPushDataFields[key]] = value;
      }

      return result;
    }
    /**
     * Populate the client with init registrations.
     * @param reg The init registration to populate.
     */

  }, {
    key: "populateInitRegistrations",
    value: function populateInitRegistrations(reg) {
      reg.populateInitRegistrations([NotificationTypes.TYPING_INDICATOR]);
      twilioSync.SyncClient.populateInitRegistrations(reg);
    }
  }]);

  return Client;
}(replayEventEmitter.ReplayEventEmitter), _defineProperty__default["default"](_class, "conversationAdded", "conversationAdded"), _defineProperty__default["default"](_class, "conversationJoined", "conversationJoined"), _defineProperty__default["default"](_class, "conversationLeft", "conversationLeft"), _defineProperty__default["default"](_class, "conversationRemoved", "conversationRemoved"), _defineProperty__default["default"](_class, "conversationUpdated", "conversationUpdated"), _defineProperty__default["default"](_class, "participantJoined", "participantJoined"), _defineProperty__default["default"](_class, "participantLeft", "participantLeft"), _defineProperty__default["default"](_class, "participantUpdated", "participantUpdated"), _defineProperty__default["default"](_class, "messageAdded", "messageAdded"), _defineProperty__default["default"](_class, "messageRemoved", "messageRemoved"), _defineProperty__default["default"](_class, "messageUpdated", "messageUpdated"), _defineProperty__default["default"](_class, "tokenAboutToExpire", "tokenAboutToExpire"), _defineProperty__default["default"](_class, "tokenExpired", "tokenExpired"), _defineProperty__default["default"](_class, "typingEnded", "typingEnded"), _defineProperty__default["default"](_class, "typingStarted", "typingStarted"), _defineProperty__default["default"](_class, "pushNotification", "pushNotification"), _defineProperty__default["default"](_class, "userSubscribed", "userSubscribed"), _defineProperty__default["default"](_class, "userUnsubscribed", "userUnsubscribed"), _defineProperty__default["default"](_class, "userUpdated", "userUpdated"), _defineProperty__default["default"](_class, "stateChanged", "stateChanged"), _defineProperty__default["default"](_class, "initialized", "initialized"), _defineProperty__default["default"](_class, "initFailed", "initFailed"), _defineProperty__default["default"](_class, "connectionStateChanged", "connectionStateChanged"), _defineProperty__default["default"](_class, "connectionError", "connectionError"), _defineProperty__default["default"](_class, "version", version), _defineProperty__default["default"](_class, "_logger", Logger.scope("Client")), _defineProperty__default["default"](_class, "_supportedPushChannels", ["fcm", "apn"]), _defineProperty__default["default"](_class, "_supportedPushDataFields", {
  conversation_sid: "conversationSid",
  conversation_title: "conversationTitle",
  message_sid: "messageSid",
  message_index: "messageIndex",
  media_count: "mediaCount",
  media: "media" // object

}), _class);

__decorate([deprecationDecorator.deprecated("token"), __metadata("design:type", String), __metadata("design:paramtypes", [])], exports.Client.prototype, "token", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "updateToken", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "getConversationBySid", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "peekConversationBySid", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "getConversationByUniqueName", null);

__decorate([declarativeTypeValidator.validateTypesAsync(["undefined", declarativeTypeValidator.objectSchema("conversation options", {
  friendlyName: ["string", "undefined"],
  isPrivate: ["boolean", "undefined"],
  uniqueName: ["string", "undefined"]
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], exports.Client.prototype, "createConversation", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal("fcm", "apn"), "string"), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "setPushRegistrationId", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal("fcm", "apn")), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "unsetPushRegistrationId", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.literal("fcm", "apn"), declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "removePushRegistrations", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], exports.Client.prototype, "handlePushNotification", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], exports.Client.prototype, "getUser", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyArray("strings", "string")), __metadata("design:type", Function), __metadata("design:paramtypes", [Array]), __metadata("design:returntype", mcsClient.CancellablePromise)], exports.Client.prototype, "getTemporaryContentUrlsForMediaSids", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyArray("media", Media)), __metadata("design:type", Function), __metadata("design:paramtypes", [Array]), __metadata("design:returntype", mcsClient.CancellablePromise)], exports.Client.prototype, "getTemporaryContentUrlsForMedia", null);

__decorate([deprecationDecorator.deprecated("Client.create()", "new Client()"), declarativeTypeValidator.validateTypesAsync("string", ["undefined", declarativeTypeValidator.pureObject]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object]), __metadata("design:returntype", Promise)], exports.Client, "create", null);

__decorate([declarativeTypeValidator.validateTypes(declarativeTypeValidator.pureObject), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", PushNotification)], exports.Client, "parsePushNotification", null);

exports.Client = Client_1 = __decorate([declarativeTypeValidator.validateConstructorTypes(declarativeTypeValidator.nonEmptyString, [declarativeTypeValidator.pureObject, "undefined"]), __metadata("design:paramtypes", [String, Object])], exports.Client);

Object.defineProperty(exports, 'CancellablePromise', {
    enumerable: true,
    get: function () { return mcsClient.CancellablePromise; }
});
exports.AggregatedDeliveryReceipt = AggregatedDeliveryReceipt;
exports.ChannelMetadata = ChannelMetadata;
exports.ContentTemplate = ContentTemplate;
exports.ContentTemplateVariable = ContentTemplateVariable;
exports.Conversation = Conversation;
exports.DetailedDeliveryReceipt = DetailedDeliveryReceipt;
exports.Media = Media;
exports.Message = Message;
exports.MessageBuilder = MessageBuilder;
exports.NotificationTypes = NotificationTypes;
exports.Participant = Participant;
exports.PushNotification = PushNotification;
exports.RestPaginator = RestPaginator;
exports.UnsentMessage = UnsentMessage;
exports.User = User;
//# sourceMappingURL=browser.js.map

/// <reference types="node" />
import { SyncClient, SyncDocument, SyncList } from "twilio-sync";
import { LogLevelDesc } from "loglevel";
import { Transport, TwilsockClient, InitRegistration, TransportResult } from "twilsock";
import { ConnectionState as TwilsockConnectionState } from "twilsock";
import { ReplayEventEmitter } from "@twilio/replay-event-emitter";
import { ChannelType, Notifications } from "@twilio/notifications";
import { Notifications as NotificationClient } from "@twilio/notifications";
import { CancellablePromise, McsClient, MediaCategory, McsMedia } from "@twilio/mcs-client";
import { MediaCategory as McsMediaCategory } from "@twilio/mcs-client";
interface ConfigurationResponse {
    options: {
        consumption_report_interval: string;
        user_infos_to_subscribe: number;
        reachability_enabled: boolean;
        http_cache_interval: string;
        my_conversations_page_size: number;
        media_attachments_count_limit: number;
        media_attachment_size_limit_in_mb: number;
        media_attachments_total_size_limit_in_mb: number;
        email_histories_allowed_mime_types: string[];
        email_bodies_allowed_mime_types: string[];
    };
    sync_objects: {
        my_conversations: string;
        my_user_info: string;
    };
    links: {
        my_conversations: string;
        conversations: string;
        users: string;
        current_user: string;
        typing: string;
        media_service: string;
        media_set_service: string;
        messages_receipts: string;
    };
    identity: string;
    url: string;
}
// twilio-conversations is used by Flex SDK. Please DO NOT change
declare class Logger {
    private prefix;
    private constructor();
    static scope(prefix: string): Logger;
    setLevel(level: LogLevelDesc): void;
    static setLevel(level: LogLevelDesc): void;
    trace(...args: any[]): void;
    debug(...args: any[]): void;
    info(...args: any[]): void;
    warn(...args: any[]): void;
    error(...args: any[]): void;
    static trace(...args: any[]): void;
    static debug(...args: any[]): void;
    static info(...args: any[]): void;
    static warn(...args: any[]): void;
    static error(...args: any[]): void;
}
/**
 * Represents conversation limits.
 */
interface ConversationLimits {
    /**
     * Maximum amount of attachments.
     */
    mediaAttachmentsCountLimit: number;
    /**
     * Maximum attachment size in MB.
     */
    mediaAttachmentSizeLimitInMb: number;
    /**
     * Maximum total attachment size in MB.
     */
    mediaAttachmentsTotalSizeLimitInMb: number;
    /**
     * Allowed content types for E-Mail histories.
     */
    emailHistoriesAllowedContentTypes: string[];
    /**
     * Allowed content types for E-Mail bodies.
     */
    emailBodiesAllowedContentTypes: string[];
}
interface BackoffConfiguration {
    min: number;
    max: number;
    maxAttemptsCount: number;
}
declare class Configuration {
    readonly links: {
        myConversations: string;
        conversations: string;
        users: string;
        currentUser: string;
        typing: string;
        mediaService: string;
        mediaSetService: string;
        messagesReceipts: string;
    };
    readonly limits: ConversationLimits;
    readonly productId?: string;
    readonly typingIndicatorTimeoutOverride?: number;
    readonly typingIndicatorTimeoutDefault: number;
    readonly backoffConfiguration: BackoffConfiguration;
    readonly retryWhenThrottled: boolean;
    readonly consumptionReportInterval: number;
    readonly userInfosToSubscribe: number;
    readonly httpCacheInterval: number;
    readonly reachabilityEnabled: boolean;
    readonly userIdentity: string;
    readonly userInfo: string;
    readonly myConversations: string;
    readonly channelMetadataCacheCapacity: number;
    constructor(options: ClientOptions, configurationResponse: ConfigurationResponse, logger: Logger);
}
interface CommandExecutorServices {
    transport: Transport;
}
declare class CommandExecutor {
    private _serviceUrl;
    private _services;
    private _productId?;
    constructor(_serviceUrl: string, _services: CommandExecutorServices, _productId?: string);
    private _preProcessUrl;
    private _makeRequest;
    fetchResource<Request = void, Response = void>(url: string, requestBody?: Request): Promise<Response>;
    mutateResource<Request = void, Response = void>(method: "post" | "delete", url: string, requestBody?: Request): Promise<Response>;
}
/**
 * Represents a JSON value.
 */
type JSONValue = null | string | number | boolean | JSONObject | JSONArray;
/**
 * Represents a JSON object.
 */
type JSONObject = {
    [x: string]: JSONValue;
};
/**
 * Represents a JSON array.
 */
type JSONArray = JSONValue[];
type UserEvents = {
    updated: (data: {
        user: User;
        updateReasons: UserUpdateReason[];
    }) => void;
    userSubscribed: (user: User) => void;
    userUnsubscribed: (user: User) => void;
};
interface UserServices {
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
}
/**
 * The reason for the `updated` event being emitted by a user.
 */
type UserUpdateReason = "friendlyName" | "attributes" | "reachabilityOnline" | "reachabilityNotifiable";
interface UserUpdatedEventArgs {
    user: User;
    updateReasons: UserUpdateReason[];
}
/**
 * Extended user information.
 * Note that `isOnline` and `isNotifiable` properties are eligible
 * for use only if the reachability function is enabled.
 * You may check if it is enabled by reading the value of {@link Client.reachabilityEnabled}.
 */
declare class User extends ReplayEventEmitter<UserEvents> {
    private links;
    private configuration;
    private readonly services;
    private entity;
    private state;
    private promiseToFetch;
    private subscribed;
    private _initializationPromise;
    private _resolveInitializationPromise;
    /**
     * @internal
     */
    constructor(identity: string, entityName: string, configuration: Configuration | null, services: UserServices);
    /**
     * Fired when the properties or the reachability status of the message has been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link User} `user` - the user in question
     *     * {@link UserUpdateReason}[] `updateReasons` - array of reasons for the update
     * @event
     */
    readonly updated = "updated";
    /**
     * Fired when the client has subscribed to the user.
     *
     * Parameters:
     * 1. {@link User} `user` - the user in question
     * @event
     */
    readonly userSubscribed = "userSubscribed";
    /**
     * Fired when the client has unsubscribed from the user.
     *
     * Parameters:
     * 1. {@link User} `user` - the user in question
     * @event
     */
    readonly userUnsubscribed = "userUnsubscribed";
    /**
     * User identity.
     */
    get identity(): string;
    set identity(identity: string);
    set entityName(name: string);
    /**
     * Custom attributes of the user.
     */
    get attributes(): JSONValue;
    /**
     * Friendly name of the user, null if not set.
     */
    get friendlyName(): string | null;
    /**
     * Status of the real-time conversation connection of the user.
     */
    get isOnline(): boolean | null;
    /**
     * User push notification registration status.
     */
    get isNotifiable(): boolean | null;
    /**
     * True if this user is receiving real-time status updates.
     */
    get isSubscribed(): boolean;
    // Handles service updates
    _update(key: string, value: {
        value: string;
        notifiable: boolean | null;
        online: boolean | null;
    }): Promise<void>;
    // Fetch reachability info
    private _updateReachabilityInfo;
    // Fetch user
    _fetch(): Promise<User>;
    _ensureFetched(): Promise<User>;
    /**
     * Edit user attributes.
     * @param attributes New attributes.
     */
    updateAttributes(attributes: JSONValue): Promise<User>;
    /**
     * Update the friendly name of the user.
     * @param friendlyName New friendly name.
     */
    updateFriendlyName(friendlyName: string): Promise<User>;
    /**
     * Remove the user from the subscription list.
     * @return A promise of completion.
     */
    unsubscribe(): Promise<void>;
    _resolveInitialization(configuration: Configuration, identity: string, entityName: string, emitUpdated: boolean): void;
}
declare class Network {
    private readonly configuration;
    private readonly services;
    private cacheLifetime;
    private readonly cache;
    private timer;
    constructor(configuration: any, services: any);
    private isExpired;
    private cleanupCache;
    pokeTimer(): void;
    private executeWithRetry;
    get<T>(url: string): Promise<TransportResult<T>>;
}
type UsersEvents = {
    userUpdated: (data: {
        user: User;
        updateReasons: UserUpdateReason[];
    }) => void;
    userSubscribed: (user: User) => void;
    userUnsubscribed: (user: User) => void;
};
interface UsersServices {
    network: Network;
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
}
/**
 * Container for known users
 */
declare class Users extends ReplayEventEmitter<UsersEvents> {
    private readonly configuration;
    private readonly services;
    private subscribedUsers;
    private fifoStack;
    readonly myself: User;
    constructor(myself: User, configuration: Configuration, services: UsersServices);
    private handleUnsubscribeUser;
    private handleSubscribeUser;
    /**
     * Gets user, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the FIFO stack
     * @returns {Promise<User>} Fully initialized user
     */
    getUser(identity: string, entityName?: string): Promise<User>;
    /**
     * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}
     */
    getSubscribedUsers(): Promise<Array<User>>;
    /**
     * @returns {Promise<string>} User's sync unique name
     */
    private getSyncUniqueName;
}
type ParticipantEvents = {
    typingEnded: (participant: Participant) => void;
    typingStarted: (participant: Participant) => void;
    updated: (data: {
        participant: Participant;
        updateReasons: ParticipantUpdateReason[];
    }) => void;
};
interface ParticipantDescriptor {
    attributes?: JSONValue;
    dateCreated: Date | null;
    dateUpdated: Date | null;
    identity: string;
    roleSid?: string;
    lastConsumedMessageIndex: number | null;
    lastConsumptionTimestamp: number | null;
    type: ParticipantType;
    userInfo?: string;
    bindings?: ParticipantBindings;
}
interface ParticipantServices {
    users: Users;
    commandExecutor: CommandExecutor;
}
interface ParticipantLinks {
    self: string;
}
/**
 * The reason for the `updated` event being emitted by a participant.
 */
type ParticipantUpdateReason = "attributes" | "dateCreated" | "dateUpdated" | "roleSid" | "lastReadMessageIndex" | "lastReadTimestamp" | "bindings";
/**
 * Participant type. The string variant can be used to denote new types of
 * participant that aren't supported by this version of the SDK.
 */
type ParticipantType = "chat" | "sms" | "whatsapp" | "email" | string;
interface ParticipantUpdatedEventArgs {
    participant: Participant;
    updateReasons: ParticipantUpdateReason[];
}
/**
 * Bindings for conversation participant.
 */
interface ParticipantBindings {
    email?: ParticipantEmailBinding;
}
/**
 * Email participation level.
 * to = to/from
 * cc = cc
 */
type ParticipantEmailLevel = "to" | "cc";
/**
 * Bindings for email participant.
 */
interface ParticipantEmailBinding {
    name: string;
    address: string;
    level: ParticipantEmailLevel;
}
/**
 * A participant represents a remote client in a conversation.
 */
declare class Participant extends ReplayEventEmitter<ParticipantEvents> {
    private state;
    private readonly links;
    private readonly services;
    /**
     * Conversation that the remote client is a participant of.
     */
    readonly conversation: Conversation;
    /**
     * The server-assigned unique identifier for the participant.
     */
    get sid(): string;
    /**
     * Custom attributes of the participant.
     */
    get attributes(): JSONValue;
    /**
     * Date this participant was created on.
     */
    get dateCreated(): Date | null;
    /**
     * Date this participant was last updated on.
     */
    get dateUpdated(): Date | null;
    /**
     * Identity of the participant.
     */
    get identity(): string | null;
    /**
     * Indicates whether the participant is currently typing.
     */
    get isTyping(): boolean;
    /**
     * The index of the last read message by the participant.
     * Note that retrieving messages on a client endpoint does not mean that messages are read,
     * please consider reading about the [Read Horizon feature](https://www.twilio.com/docs/api/chat/guides/consumption-horizon)
     * to find out about the proper way to mark messages as read.
     */
    get lastReadMessageIndex(): number | null;
    /**
     * Date of the most recent read horizon update.
     */
    get lastReadTimestamp(): Date | null;
    get roleSid(): string;
    /**
     * Type of the participant.
     */
    get type(): ParticipantType;
    /**
     * Get the bindings mapping for the current participant.
     * Available binding depends on the participant type.
     * You could access it as `participant.bindings.sms?.address` or
     * using the type dynamically `participant.bindings[participant.type]`
     * just be aware that the binding information has different structure for
     * each participant type.
     * See also {ParticipantEmailBinding}, the only available currently binding descriptor.
     */
    get bindings(): ParticipantBindings;
    /**
     * @internal
     */
    constructor(data: ParticipantDescriptor, sid: string, conversation: Conversation, links: ParticipantLinks, services: ParticipantServices);
    /**
     * Fired when the participant has started typing.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant in question
     * @event
     */
    static readonly typingStarted = "typingStarted";
    /**
     * Fired when the participant has stopped typing.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant in question
     * @event
     */
    static readonly typingEnded = "typingEnded";
    /**
     * Fired when the fields of the participant have been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Participant} participant - the participant in question
     *     * {@link ParticipantUpdateReason}[] updateReasons - array of reasons for the update
     * @event
     */
    static readonly updated = "updated";
    /**
     * Internal method used to start or reset the typing indicator timeout (with event emitting).
     * @internal
     */
    _startTyping(timeout: any): this;
    /**
     * Internal method function used to stop the typing indicator timeout (with event emitting).
     * @internal
     */
    _endTyping(): void;
    /**
     * Internal method function used update local object's property roleSid with a new value.
     * @internal
     */
    _update(data: any): this;
    /**
     * Get the user for this participant and subscribes to it. Supported only for participants of type `chat`.
     */
    getUser(): Promise<User>;
    /**
     * Remove the participant from the conversation.
     */
    remove(): Promise<void>;
    /**
     * Update the attributes of the participant.
     * @param attributes New attributes.
     */
    updateAttributes(attributes: JSONValue): Promise<Participant>;
}
interface ParticipantResponse {
    account_sid: string;
    chat_service_sid: string;
    conversation_sid: string;
    role_sid: string;
    sid: string;
    attributes: string;
    date_created: string;
    date_updated: string;
    identity: string;
    messaging_binding: {
        type: "chat" | "sms" | "whatsapp" | "email";
        address: string;
        proxy_address: string;
    } | null;
    url: string;
    links: {
        conversation: string;
    };
}
interface ParticipantBindingOptions {
    email?: ParticipantEmailBinding;
}
/**
 * Category of media. Possible values are as follows:
 * * `'media'`
 * * `'body'`
 * * `'history'`
 */
type MediaCategory$0 = McsMediaCategory;
interface MediaState {
    sid: string;
    category: MediaCategory$0;
    filename: string | null;
    contentType: string;
    size: number;
}
interface MediaServices {
    mcsClient: McsClient;
}
/**
 * Represents a media information for a message in a conversation.
 */
declare class Media {
    private state;
    private services;
    private mcsMedia;
    /**
     * @internal
     */
    constructor(data: MediaState | McsMedia, services: MediaServices);
    /**
     * Server-assigned unique identifier for the media.
     */
    get sid(): string;
    /**
     * File name. Null if absent.
     */
    get filename(): string | null;
    /**
     * Content type of the media.
     */
    get contentType(): string;
    /**
     * Size of the media in bytes.
     */
    get size(): number;
    /**
     * Media category, can be one of the {@link MediaCategory} values.
     */
    get category(): MediaCategory$0;
    /**
     * Returns the direct content URL for the media.
     *
     * This URL is impermanent, it will expire in several minutes and cannot be cached.
     * If the URL becomes expired, you need to request a new one.
     * Each call to this function produces a new temporary URL.
     */
    getContentTemporaryUrl(): CancellablePromise<string | null>;
    private _fetchMcsMedia;
}
/**
 * Signifies the amount of participants which have the status for the message.
 */
type DeliveryAmount = "none" | "some" | "all";
interface AggregatedDeliveryDescriptor {
    total: number;
    delivered: DeliveryAmount;
    failed: DeliveryAmount;
    read: DeliveryAmount;
    sent: DeliveryAmount;
    undelivered: DeliveryAmount;
}
/**
 * Contains aggregated information about delivery statuses of a message across all participants
 * of a conversation.
 *
 * At any moment during the message delivery to a participant, the message can have zero or more of the following
 * delivery statuses:
 * * Message is considered as **sent** to a participant if the nearest upstream carrier accepted the message.
 * * Message is considered as **delivered** to a participant if Twilio has received confirmation of message
 * delivery from the upstream carrier, and, where available, the destination handset.
 * * Message considered as **undelivered** to a participant if Twilio has received a delivery receipt
 * indicating that the message was not delivered. This can happen for many reasons including carrier content
 * filtering and the availability of the destination handset.
 * * Message considered as **read** by a participant if the message has been delivered and opened by the
 * recipient in a conversation. The recipient must have enabled the read receipts.
 * * Message considered as **failed** to be delivered to a participant if the message could not be sent.
 * This can happen for various reasons including queue overflows, account suspensions and media
 * errors (in the case of MMS for instance).
 *
 * {@link AggregatedDeliveryReceipt} class contains an aggregated value {@link DeliveryAmount} for each delivery status.
 */
declare class AggregatedDeliveryReceipt {
    private state;
    /**
     * @internal
     */
    constructor(data: AggregatedDeliveryDescriptor);
    /**
     * Maximum number of delivery events expected for the message.
     */
    get total(): number;
    /**
     * Message is considered as **sent** to a participant if the nearest upstream carrier accepted the message.
     *
     * @return Amount of participants that have the **sent** delivery status for the message.
     */
    get sent(): DeliveryAmount;
    /**
     * Message is considered as **delivered** to a participant if Twilio has received confirmation of message
     * delivery from the upstream carrier, and, where available, the destination handset.
     *
     * @return Amount of participants that have the **delivered** delivery status for the message.
     */
    get delivered(): DeliveryAmount;
    /**
     * Message is considered as **read** by a participant, if the message has been delivered and opened by the
     * recipient in a conversation. The recipient must have enabled the read receipts.
     *
     * @return Amount of participants that have the **read** delivery status for the message.
     */
    get read(): DeliveryAmount;
    /**
     * Message is considered as **undelivered** to a participant if Twilio has received a delivery receipt
     * indicating that the message was not delivered. This can happen for many reasons including carrier content
     * filtering and the availability of the destination handset.
     *
     * @return Ammount of participants that have the **undelivered** delivery status for the message.
     */
    get undelivered(): DeliveryAmount;
    /**
     * Message is considered as **failed** to be delivered to a participant if the message could not be sent.
     * This can happen for various reasons including queue overflows, account suspensions and media
     * errors (in the case of MMS for instance). Twilio does not charge you for failed messages.
     *
     * @return Amount of participants that have the **failed** delivery status for the message.
     */
    get failed(): DeliveryAmount;
    _update(data: AggregatedDeliveryDescriptor): void;
    _isEquals(data: AggregatedDeliveryDescriptor): boolean;
}
/**
 * Message delivery status.
 */
type DeliveryStatus = "sent" | "delivered" | "failed" | "read" | "undelivered" | "queued";
interface DetailedDeliveryReceiptDescriptor {
    sid: string;
    message_sid: string;
    conversation_sid: string;
    channel_message_sid: string;
    participant_sid: string;
    status: DeliveryStatus;
    error_code: string | null;
    date_created: string;
    date_updated: string;
}
/**
 * Represents a delivery receipt of a message.
 */
declare class DetailedDeliveryReceipt {
    /**
     * Unique identifier for the delivery receipt.
     */
    sid: string;
    /**
     * Unique identifier for the message in the conversation.
     */
    messageSid: string;
    /**
     * Unique identifier for the conversation.
     */
    conversationSid: string;
    /**
     * Unique identifier for the `‘channel’` message (e.g., `WAxx` for WhatsApp, `SMxx` for SMS).
     */
    channelMessageSid: string;
    /**
     * Unique identifier for the participant.
     */
    participantSid: string;
    /**
     * Status of the message delivery.
     */
    status: DeliveryStatus;
    /**
     * Numeric error code mapped from Status callback code. Information about the error codes can be found
     * [here](https://www.twilio.com/docs/sms/api/message-resource#delivery-related-errors).
     */
    errorCode: string | 0;
    /**
     * Date this delivery receipt was created on.
     */
    dateCreated: string;
    /**
     * Date this delivery receipt was last updated on.
     */
    dateUpdated: string;
    /**
     * @internal
     */
    constructor(descriptor: DetailedDeliveryReceiptDescriptor);
}
type ContentDataActionResponse = Readonly<{
    type: string;
    title: string;
    id?: string;
    url?: string;
    phone?: string;
    index?: number;
}>;
type ContentDataTextResponse = Readonly<{
    body: string;
}>;
type ContentDataMediaResponse = Readonly<{
    body?: string;
    media: string[];
}>;
type ContentDataLocationResponse = Readonly<{
    longitude: number;
    latitude: number;
    label?: string;
}>;
type ContentDataQuickReplyResponse = Readonly<{
    body: string;
    actions: Readonly<{
        title: string;
        id?: string;
    }>[];
}>;
type ContentDataCallToActionResponse = Readonly<{
    body: string;
    actions: ContentDataActionResponse[];
}>;
type ContentDataListPickerResponse = Readonly<{
    body: string;
    button: string;
    items: Readonly<{
        id: string;
        item: string;
        description?: string;
    }>[];
}>;
type ContentDataCardResponse = Readonly<{
    title: string;
    subtitle?: string;
    media?: string[];
    actions?: ContentDataActionResponse[];
}>;
type ContentDataResponse = Readonly<{
    "twilio/text"?: ContentDataTextResponse;
    "twilio/media"?: ContentDataMediaResponse;
    "twilio/location"?: ContentDataLocationResponse;
    "twilio/quick-reply"?: ContentDataQuickReplyResponse;
    "twilio/call-to-action"?: ContentDataCallToActionResponse;
    "twilio/list-picker"?: ContentDataListPickerResponse;
    "twilio/card"?: ContentDataCardResponse;
}>;
type ContentTemplateResponse = Readonly<{
    sid: string;
    account_sid: string;
    friendly_name: string;
    variables: string;
    variants: ContentDataResponse;
    date_created: string;
    date_updated: string;
}>;
/**
 * Shows a button that sends back a predefined text. Used in
 * {@link ContentDataQuickReply}.
 */
type ContentDataReply = {
    /**
     * Display value of the action. This is the message that will be sent back
     * when the user taps on the button.
     */
    readonly title: string;
    /**
     * Postback payload. This field is not visible to the end user.
     */
    readonly id?: string;
};
/**
 * Shows a button that redirects recipient to a predefined URL.
 */
type ContentDataActionUrl = {
    /**
     * The type discriminant.
     */
    readonly type: "url";
    /**
     * Display value for the action.
     */
    readonly title: string;
    /**
     * URL to direct to when the recipient taps the button.
     */
    readonly url: string;
    /**
     * Full data as a stringified JSON. This could be used for future content
     * types and fields which are not yet supported by the newest version of
     * the Conversations SDK, or for using newer types in the older versions of
     * the SDK.
     */
    readonly rawData: string;
};
/**
 * Shows a button that calls a phone number.
 */
type ContentDataActionPhone = {
    /**
     * The type discriminant.
     */
    readonly type: "phone";
    /**
     * Display value for the action.
     */
    readonly title: string;
    /**
     * Phone number to call when the recipient taps the button.
     */
    readonly phone: string;
    /**
     * Full data as a stringified JSON. This could be used for future content
     * types and fields which are not yet supported by the newest version of
     * the Conversations SDK, or for using newer types in the older versions of
     * the SDK.
     */
    readonly rawData: string;
};
/**
 * Shows a button that sends back a predefined text.
 */
type ContentDataActionReply = {
    /**
     * The type discriminant.
     */
    readonly type: "reply";
    /**
     * Display value for the action. This is the message that will be sent back
     * when the user taps on the button.
     */
    readonly title: string;
    /**
     * Postback payload. This field is not visible to the end user.
     */
    readonly id?: string;
    /**
     * Index for the action.
     */
    readonly index: number;
    /**
     * Full data as a stringified JSON. This could be used for future content
     * types and fields which are not yet supported by the newest version of
     * the Conversations SDK, or for using newer types in the older versions of
     * the SDK.
     */
    readonly rawData: string;
};
/**
 * Used for unknown action types which aren't present in the current version of
 * the Conversations SDK.
 */
type ContentDataActionOther = {
    /**
     * The type discriminant.
     */
    readonly type: "other";
    /**
     * Full data as a stringified JSON. This could be used for future content
     * types and fields which are not yet supported by the newest version of
     * the Conversations SDK, or for using newer types in the older versions of
     * the SDK.
     */
    readonly rawData: string;
};
/**
 * A union of possible actions used in {@link ContentDataCallToAction} and
 * {@link ContentDataCard}.
 */
type ContentDataAction = ContentDataActionUrl | ContentDataActionPhone | ContentDataActionReply | ContentDataActionOther;
/**
 * Represents an item in the {@link ContentDataListPicker}.
 */
type ContentDataListItem = {
    /**
     * Unique item identifier. Not visible to the recipient.
     */
    readonly id: string;
    /**
     * Display value of the item.
     */
    readonly item: string;
    /**
     * Description of the item.
     */
    readonly description?: string;
};
/**
 * Contains only the plain text-based content. Represents the twilio/text
 * content type.
 */
type ContentDataText = {
    /**
     * The type discriminant.
     */
    readonly type: "text";
    /**
     * The text of the message you want to send.
     */
    readonly body: string;
    /**
     * Full data as a stringified JSON. This could be used for future content
     * types and fields which are not yet supported by the newest version of
     * the Conversations SDK, or for using newer types in the older versions of
     * the SDK.
     */
    readonly rawData: string;
};
/**
 * Used to send file attachments, or to send long texts via MMS in the US and
 * Canada. Represents the twilio/media content type.
 */
type ContentDataMedia = {
    /**
     * The type discriminant.
     */
    readonly type: "media";
    /**
     * The text of the message you want to send.
     */
    readonly body?: string;
    /**
     * URLs of the media you want to send.
     */
    readonly media: string[];
    /**
     * Full data as a stringified JSON. This could be used for future content
     * types and fields which are not yet supported by the newest version of
     * the Conversations SDK, or for using newer types in the older versions of
     * the SDK.
     */
    readonly rawData: string;
};
/**
 * Contains a location pin and an optional label, which can be used to enhance
 * delivery notifications or connect recipients to physical experiences you
 * offer. Represents the twilio/location content type.
 */
type ContentDataLocation = {
    /**
     * The type discriminant.
     */
    readonly type: "location";
    /**
     * The longitude value of the location pin you want to send.
     */
    readonly longitude: number;
    /**
     * The latitude value of the location pin you want to send.
     */
    readonly latitude: number;
    /**
     * The label to be displayed to the end user alongside the location pin.
     */
    readonly label?: string;
    /**
     * Full data as a stringified JSON. This could be used for future content
     * types and fields which are not yet supported by the newest version of
     * the Conversations SDK, or for using newer types in the older versions of
     * the SDK.
     */
    readonly rawData: string;
};
/**
 * Let recipients tap, rather than type, to respond to the message. Represents
 * the twilio/quick-reply content type.
 */
type ContentDataQuickReply = {
    /**
     * The type discriminant.
     */
    readonly type: "quickReply";
    /**
     * The text of the message you want to send. This is included as a regular
     * text message.
     */
    readonly body: string;
    /**
     * Up to 3 buttons can be created for quick reply. See
     * {@link ContentDataReply}.
     */
    readonly replies: ContentDataReply[];
    /**
     * Full data as a stringified JSON. This could be used for future content
     * types and fields which are not yet supported by the newest version of
     * the Conversations SDK, or for using newer types in the older versions of
     * the SDK.
     */
    readonly rawData: string;
};
/**
 * Buttons that let recipients tap to trigger actions such as launching a
 * website or making a phone call. Represents the twilio/call-to-action content
 * type.
 */
type ContentDataCallToAction = {
    /**
     * The type discriminant.
     */
    readonly type: "callToAction";
    /**
     * The text of the message you want to send. This is included as a regular
     * text message.
     */
    readonly body: string;
    /**
     * Buttons that recipients can tap on to act on the message.
     */
    readonly actions: ContentDataAction[];
    /**
     * Full data as a stringified JSON. This could be used for future content
     * types and fields which are not yet supported by the newest version of
     * the Conversations SDK, or for using newer types in the older versions of
     * the SDK.
     */
    readonly rawData: string;
};
/**
 * Shows a menu of up to 10 options, which offers a simple way for users to make
 * a selection. Represents the twilio/list-picker content type.
 */
type ContentDataListPicker = {
    /**
     * The type discriminant.
     */
    readonly type: "listPicker";
    /**
     * The text of the message you want to send. This is rendered as the body of
     * the message.
     */
    readonly body: string;
    /**
     * Display value of the primary button.
     */
    readonly button: string;
    /**
     * List item objects displayed in the list. See {@link ContentDataListItem}.
     */
    readonly items: ContentDataListItem[];
    /**
     * Full data as a stringified JSON. This could be used for future content
     * types and fields which are not yet supported by the newest version of
     * the Conversations SDK, or for using newer types in the older versions of
     * the SDK.
     */
    readonly rawData: string;
};
/**
 * Shows a menu of up to 10 options, which offers a simple way for users to make
 * a selection. Represents the twilio/card content type.
 */
type ContentDataCard = {
    /**
     * The type discriminant.
     */
    readonly type: "card";
    /**
     * Title of the card.
     */
    readonly title: string;
    /**
     * Subtitle of the card.
     */
    readonly subtitle?: string;
    /**
     * URLs of the media to send with the message.
     */
    readonly media: string[];
    /**
     * Buttons that the recipients can tap on to act on the message.
     */
    readonly actions: ContentDataAction[];
    /**
     * Full data as a stringified JSON. This could be used for future content
     * types and fields which are not yet supported by the newest version of
     * the Conversations SDK, or for using newer types in the older versions of
     * the SDK.
     */
    readonly rawData: string;
};
/**
 * Used for unknown content types which aren't present in the current version of
 * the Conversations SDK.
 */
type ContentDataOther = {
    /**
     * The type discriminant.
     */
    readonly type: "other";
    /**
     * Full data as a stringified JSON. This could be used for future content
     * types and fields which are not yet supported by the newest version of
     * the Conversations SDK, or for using newer types in the older versions of
     * the SDK.
     */
    readonly rawData: string;
};
/**
 * A union of possible data types in rich content templates.
 */
type ContentData = ContentDataText | ContentDataMedia | ContentDataLocation | ContentDataQuickReply | ContentDataCallToAction | ContentDataListPicker | ContentDataCard | ContentDataOther;
/**
 * Represents a variable for a content template. See
 * {@link ContentTemplate.variables}.
 */
declare class ContentTemplateVariable {
    readonly name: string;
    readonly value: string;
    constructor(/**
     * Name of the variable.
     */
    name: string, /**
     * Key of the variable
     */
    value: string);
    /**
     * Copies the variable with a new value.
     *
     * @param value The new value for the variable.
     */
    copyWithValue(value: string): ContentTemplateVariable;
}
/**
 * A rich content template.
 *
 * Use {@Link Client.getContentTemplates} to request all the templates available
 * for the current account.
 */
declare class ContentTemplate {
    /**
     * The server-assigned unique identifier for the template.
     */
    readonly sid: string;
    /**
     * Friendly name used to describe the content. Not visible to the recipient.
     */
    readonly friendlyName: string;
    /**
     * Variables used by this template.
     */
    readonly variables: ContentTemplateVariable[];
    /**
     * Variants of the content. See {@link ContentData}.
     */
    readonly variants: Map<string, ContentData>;
    /**
     * Date of creation.
     */
    readonly dateCreated: Date;
    /**
     * Date of the last update.
     */
    readonly dateUpdated: Date;
    /**
     * @internal
     */
    constructor(contentTemplateResponse: ContentTemplateResponse);
}
type ChannelMetadataClientServices = {
    commandExecutor: CommandExecutor;
};
/**
 * Represents channel metadata.
 */
declare class ChannelMetadata {
    /**
     * Communication channel type.
     */
    readonly type: string;
    /**
     * The actual metadata.
     */
    readonly data: unknown;
    /**
     * @internal
     */
    constructor(type: string, data: unknown);
}
declare class ChannelMetadataClient {
    private readonly _services;
    private readonly _configuration;
    private readonly _cache;
    constructor(services: ChannelMetadataClientServices, configuration: Configuration);
    getChannelMetadata(conversationSid: string, messageSid: string): Promise<ChannelMetadata | null>;
}
type MessageEvents = {
    updated: (data: {
        message: Message;
        updateReasons: MessageUpdateReason[];
    }) => void;
};
interface MessageServices {
    mcsClient: McsClient;
    network: Network;
    commandExecutor: CommandExecutor;
    channelMetadataClient: ChannelMetadataClient;
}
interface MessageLinks {
    self: string;
    conversation: string;
    messages_receipts: string;
}
/**
 * The reason for the `updated` event being emitted by a message.
 */
type MessageUpdateReason = "body" | "lastUpdatedBy" | "dateCreated" | "dateUpdated" | "attributes" | "author" | "deliveryReceipt" | "subject";
/**
 * Type of a message.
 */
type MessageType = "text" | "media";
interface MessageUpdatedEventArgs {
    message: Message;
    updateReasons: MessageUpdateReason[];
}
interface MessageData {
    sid: string;
    text?: string;
    type?: MessageType;
    author: string | null;
    subject: string | null;
    contentSid: string | null;
    lastUpdatedBy?: string | null;
    attributes?: JSONValue;
    dateUpdated: string;
    timestamp?: string;
    medias?: Media[];
    media?: Media;
    memberSid?: string;
    delivery?: AggregatedDeliveryDescriptor;
    channelMetadata?: boolean;
}
/**
 * A message in a conversation.
 */
declare class Message extends ReplayEventEmitter<MessageEvents> {
    /**
     * Conversation that the message is in.
     */
    readonly conversation: Conversation;
    private readonly links;
    private readonly configuration;
    private readonly services;
    private state;
    /**
     * @internal
     */
    constructor(index: number, data: MessageData, conversation: Conversation, links: MessageLinks, configuration: Configuration, services: MessageServices);
    /**
     * Fired when the properties or the body of the message has been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the following properties:
     *     * {@link Message} message - the message in question
     *     * {@link MessageUpdateReason}[] updateReasons - array of reasons for the update
     */
    static readonly updated = "updated";
    /**
     * The server-assigned unique identifier for the message.
     */
    get sid(): string;
    /**
     * Name of the user that sent the message.
     */
    get author(): string | null;
    /**
     * Message subject. Used only in email conversations.
     */
    get subject(): string | null;
    /**
     * Unique identifier of {@link ContentTemplate} for this message.
     */
    get contentSid(): string | null;
    /**
     * Body of the message.
     */
    get body(): string | null;
    /**
     * Date this message was last updated on.
     */
    get dateUpdated(): Date | null;
    /**
     * Index of this message in the conversation's list of messages.
     *
     * By design, the message indices may have arbitrary gaps between them,
     * that does not necessarily mean they were deleted or otherwise modified - just that
     * messages may have some non-contiguous indices even if they are being sent immediately one after another.
     *
     * Trying to use indices for some calculations is going to be unreliable.
     *
     * To calculate the number of unread messages, it is better to use the Read Horizon API.
     * See {@link Conversation.getUnreadMessagesCount} for details.
     */
    get index(): number;
    /**
     * Identity of the last user that updated the message.
     */
    get lastUpdatedBy(): string | null;
    /**
     * Date this message was created on.
     */
    get dateCreated(): Date | null;
    /**
     * Custom attributes of the message.
     */
    get attributes(): JSONValue;
    /**
     * Type of the message.
     */
    get type(): MessageType;
    /**
     * One of the attached media (if present).
     * @deprecated Use attachedMedia instead. Note that the latter is now an array.
     */
    get media(): Media | null;
    /**
     * Return all media attachments, except email body/history attachments, without temporary urls.
     */
    get attachedMedia(): Array<Media> | null;
    /**
     * The server-assigned unique identifier of the authoring participant.
     */
    get participantSid(): string | null;
    /**
     * Aggregated information about the message delivery statuses across all participants of a conversation..
     */
    get aggregatedDeliveryReceipt(): AggregatedDeliveryReceipt | null;
    /**
     * @deprecated
     * Return a (possibly empty) array of media matching a specific set of categories.
     * Allowed category is so far only 'media'.
     * @param categories Array of categories to match.
     * @returns Array of media descriptors matching given categories.
     */
    getMediaByCategory(categories: Array<MediaCategory>): Array<Media> | null;
    /**
     * Return a (possibly empty) array of media matching a specific set of categories.
     * Allowed category is so far only 'media'.
     * @param categories Array of categories to match.
     * @returns Array of media descriptors matching given categories.
     */
    getMediaByCategories(categories: MediaCategory[]): Media[] | null;
    /**
     * Get a media descriptor for an email body attachment of a provided type.
     * Allowed body types are returned in the Conversation.limits().emailBodiesAllowedContentTypes array.
     * @param type Type of email body to request, defaults to `text/plain`.
     */
    getEmailBody(type?: string): Media | null;
    /**
     * Get a media descriptor for an email history attachment of a provided type.
     * Allowed body types are returned in the Conversation.limits().emailHistoriesAllowedContentTypes array.
     * @param type Type of email history to request, defaults to `text/plain`.
     */
    getEmailHistory(type?: string): Media | null;
    _update(data: any): void;
    /**
     * Get the participant who is the author of the message.
     */
    getParticipant(): Promise<Participant>;
    /**
     * Get the delivery receipts of the message.
     */
    getDetailedDeliveryReceipts(): Promise<DetailedDeliveryReceipt[]>;
    /**
     * Remove the message.
     */
    remove(): Promise<Message>;
    /**
     * Edit the message body.
     * @param body New body of the message.
     */
    updateBody(body: string): Promise<Message>;
    /**
     * Edit the message attributes.
     * @param attributes New attributes.
     */
    updateAttributes(attributes: JSONValue): Promise<Message>;
    /**
     * @deprecated
     * Get content URLs for all media attachments in the given set using a single operation.
     * @param contentSet Set of media attachments to query content URLs.
     */
    attachTemporaryUrlsFor(contentSet: Media[] | null): Promise<Media[]>;
    /**
     * Get content URLs for all media attachments in the given set using a single operation.
     * @param contentSet Set of media attachments to query content URLs.
     */
    getTemporaryContentUrlsForMedia(contentSet: Media[]): CancellablePromise<Map<string, string>>;
    /**
     * Get content URLs for all media attachments in the given set of media sids using a single operation.
     * @param mediaSids Set of media sids to query for the content URL.
     */
    getTemporaryContentUrlsForMediaSids(mediaSids: string[]): CancellablePromise<Map<string, string>>;
    /**
     * Get content URLs for all media attached to the message.
     */
    getTemporaryContentUrlsForAttachedMedia(): CancellablePromise<Map<string, string>>;
    private _getDetailedDeliveryReceiptsPaginator;
    /**
     * Get the {@link ContentData} for this message. Resolves to `null` when
     * {@link Message.contentSid} is null.
     */
    getContentData(): CancellablePromise<ContentData | null>;
    /**
     * Get the {@link ChannelMetadata} for this message. Resolves to `null` if
     * the message doesn't have any channel metadata.
     */
    getChannelMetadata(): Promise<ChannelMetadata | null>;
}
/**
 * Pagination helper interface.
 * @typeParam T The item type.
 */
interface Paginator<T> {
    /**
     * Indicates the existence of the next page.
     */
    hasNextPage: boolean;
    /**
     * Indicates the existence of the previous page.
     */
    hasPrevPage: boolean;
    /**
     * Array of elements of type T on the current page.
     */
    items: T[];
    /**
     * Request next page.
     * Does not modify the existing object.
     */
    nextPage(): Promise<Paginator<T>>;
    /**
     * Request previous page.
     * Does not modify the existing object.
     */
    prevPage(): Promise<Paginator<T>>;
}
interface TypingIndicatorServices {
    twilsockClient: TwilsockClient;
    notificationClient: Notifications;
}
/**
 * An important note in regards to typing timeout timers. There are two places that the SDK can get the "typing_timeout" attribute from. The first
 * place that the attribute appears in is the response received from POST -> /v1/typing REST call. In the body of that response, the value of the
 * "typing_timeout" attribute will be exactly the same as defined in the console. The second place that the attribute appears in is from a
 * notification of type "twilio.ipmsg.typing_indicator". In this case, the "typing_timeout" value will be +1 of that in the console. This
 * intentional. The timeout returned from the POST -> /v1/typing call should be used to disable further calls for that period of time. On contrary,
 * the timeout returned from the notification should be used as the timeout for the "typingEnded" event, +1 is to account for latency.
 *
 * @private
 */
/**
 * @class TypingIndicator
 *
 * @constructor
 * @private
 */
declare class TypingIndicator {
    private readonly services;
    private readonly configuration;
    private sentUpdates;
    private getConversation;
    private serviceTypingTimeout;
    constructor(getConversation: (conversationSid: string) => Promise<Conversation>, config: Configuration, services: TypingIndicatorServices);
    get typingTimeout(): number;
    /**
     * Initialize TypingIndicator controller
     * Registers for needed message types and sets listeners
     * @private
     */
    initialize(): void;
    /**
     * Remote participants typing events handler
     */
    private _handleRemoteTyping;
    /**
     * Send typing event for the given conversation sid
     * @param {String} conversationSid
     */
    send(conversationSid: string): Promise<void>;
    private _send;
}
/**
 * Pagination helper class.
 */
declare class RestPaginator<T> implements Paginator<T> {
    private state;
    /**
     * Indicates the existence of the next page.
     */
    get hasNextPage(): boolean;
    /**
     * Indicates the existence of the previous page
     */
    get hasPrevPage(): boolean;
    /**
     * Array of elements on the current page.
     */
    get items(): T[];
    /**
     * @internal
     */
    constructor(items: any, source: any, prevToken: any, nextToken: any);
    /**
     * Request the next page. Does not modify the existing object.
     */
    nextPage(): Promise<RestPaginator<T>>;
    /**
     * Request the previous page. Does not modify the existing object.
     */
    prevPage(): Promise<RestPaginator<T>>;
}
/**
 * @classdesc Pagination helper class for Sync
 *
 * @property {Array} items Array of elements on current page
 * @property {boolean} hasNextPage
 * @property {boolean} hasPrevPage
 */
declare class SyncPaginator<T> implements Paginator<T> {
    private state;
    hasNextPage: boolean;
    hasPrevPage: boolean;
    get items(): T[];
    /**
     * @param {Array} items Array of element for current page
     * @param {Object} params
     */
    constructor(items: any, pageSize: any, anchor: any, direction: any, source: any);
    nextPage(): Promise<RestPaginator<T>>;
    prevPage(): Promise<SyncPaginator<T> | RestPaginator<T>>;
}
interface MessageResponse {
    account_sid: string;
    chat_service_sid: string;
    conversation_sid: string;
    sid: string;
    index: number;
    attributes: string;
    author: string;
    participant_sid: string;
    body: string;
    subject: string;
    date_created: string;
    date_updated: string;
    url: string;
    media: {
        sid: string;
        size: string;
        content_type: string;
        filename: string;
    }[] | null;
    links: {
        conversation: string;
        messages_receipts: string;
    };
}
type MessagesEvents = {
    messageAdded: (message: Message) => void;
    messageRemoved: (message: Message) => void;
    messageUpdated: (data: {
        message: Message;
        updateReasons: MessageUpdateReason[];
    }) => void;
};
interface MessagesServices {
    mcsClient: McsClient;
    network: Network;
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
    channelMetadataClient: ChannelMetadataClient;
}
/**
 * Represents the collection of messages in a conversation
 */
declare class Messages extends ReplayEventEmitter<MessagesEvents> {
    readonly conversation: Conversation;
    private readonly configuration;
    private readonly services;
    private readonly messagesByIndex;
    private messagesListPromise;
    constructor(conversation: Conversation, configuration: Configuration, services: MessagesServices);
    /**
     * Subscribe to the Messages Event Stream
     * @param arg - Name of the Sync object, or the SyncList itself, that
     * represents the Messages resource.
     */
    subscribe(arg: string | SyncList): Promise<SyncList>;
    unsubscribe(): Promise<void>;
    /**
     * Send a message to the conversation. The message could include text and multiple media attachments.
     * @param message Message to post
     */
    sendV2(message: UnsentMessage): CancellablePromise<MessageResponse>;
    /**
     * Send Message to the conversation
     * @param message Message to post
     * @param attributes Message attributes
     * @param emailOptions Options that modify E-mail integration behaviors.
     * @returns Returns promise which can fail
     */
    send(message: null | string | FormData | SendMediaOptions, attributes?: JSONValue, emailOptions?: SendEmailOptions): Promise<MessageResponse>;
    /**
     * Send Media Message to the conversation
     * @param mediaContent Media content to post
     * @param attributes Message attributes
     * @param emailOptions Email options
     * @returns Returns promise which can fail
     */
    sendMedia(mediaContent: FormData | SendMediaOptions, attributes?: JSONValue, emailOptions?: SendEmailOptions): Promise<MessageResponse>;
    /**
     * Returns messages from conversation using paginator interface
     * @param pageSize Number of messages to return in single chunk. By default it's 30.
     * @param anchor Most early message id which is already known, or 'end' by default
     * @param direction Pagination order 'backwards' or 'forward', 'forward' by default
     * @returns Last page of messages by default
     */
    getMessages(pageSize: number | undefined, anchor: number | "end" | undefined, direction?: "forward" | "backwards"): Promise<SyncPaginator<Message>>;
    private _wrapPaginator;
    private _upsertMessage;
    /**
     * Returns last messages from conversation
     * @param {Number} [pageSize] Number of messages to return in single chunk. By default it's 30.
     * @param {String} [anchor] Most early message id which is already known, or 'end' by default
     * @param {String} [direction] Pagination order 'backwards' or 'forward', or 'forward' by default
     * @returns {Promise<SyncPaginator<Message>>} last page of messages by default
     * @private
     */
    private _getMessages;
}
/**
 * An unsent message. Returned from {@link MessageBuilder.build}.
 */
declare class UnsentMessage {
    private messagesEntity;
    text?: string;
    attributes: JSONValue;
    mediaContent: [
        MediaCategory,
        FormData | SendMediaOptions
    ][];
    emailOptions: SendEmailOptions;
    contentSid?: string;
    contentVariables?: ContentTemplateVariable[];
    /**
     * @internal
     */
    constructor(messagesEntity: Messages);
    /**
     * Send the prepared message to the conversation.
     * @returns Index of the new message in the conversation.
     */
    send(): CancellablePromise<number | null>;
}
/**
 * Message builder. Allows the message to be built and sent via method chaining.
 *
 * Example:
 *
 * ```ts
 * await testConversation.prepareMessage()
 *   .setBody('Hello!')
 *   .setAttributes({foo: 'bar'})
 *   .addMedia(media1)
 *   .addMedia(media2)
 *   .build()
 *   .send();
 * ```
 */
declare class MessageBuilder {
    private readonly limits;
    private readonly message;
    private emailBodies;
    private emailHistories;
    /**
     * @internal
     */
    constructor(limits: ConversationLimits, messagesEntity: Messages);
    /**
     * Sets the message body.
     * @param text Contents of the body.
     */
    setBody(text: string): MessageBuilder;
    /**
     * Sets the message subject.
     * @param subject Contents of the subject.
     */
    setSubject(subject: string): MessageBuilder;
    /**
     * Sets the message attributes.
     * @param attributes Message attributes.
     */
    setAttributes(attributes: JSONValue): MessageBuilder;
    /**
     * Set the email body with a given content type.
     * @param contentType Format of the body to set (text/plain or text/html).
     * @param body Body payload in the selected format.
     */
    setEmailBody(contentType: string, body: FormData | SendMediaOptions): MessageBuilder;
    /**
     * Set the email history with a given content type.
     * @param contentType Format of the history to set (text/plain or text/html).
     * @param history History payload in the selected format.
     */
    setEmailHistory(contentType: string, history: FormData | SendMediaOptions): MessageBuilder;
    /**
     * Adds {@link ContentTemplate} SID for the message alongside optional
     * variables. When no variables provided, the default values will be used.
     *
     * Adding the content SID converts the message to a rich message. In this
     * case, other fields are ignored and the message is sent using the content
     * from the the {@link ContentTemplate}.
     *
     * Use {@link Client.getContentTemplates} to request all available
     * {@link ContentTemplate}s.
     *
     * @param contentSid SID of the {@link ContentTemplate}
     * @param variables Custom variables to resolve the template.
     */
    setContentTemplate(contentSid: string, contentVariables?: ContentTemplateVariable[]): MessageBuilder;
    /**
     * Adds media to the message.
     * @param payload Media to add.
     */
    addMedia(payload: FormData | SendMediaOptions): MessageBuilder;
    /**
     * Builds the message, making it ready to be sent.
     */
    build(): UnsentMessage;
    /**
     * Prepares a message and sends it to the conversation.
     */
    buildAndSend(): CancellablePromise<number | null>;
}
/**
 * Conversation events.
 */
type ConversationEvents = {
    participantJoined: (participant: Participant) => void;
    participantLeft: (participant: Participant) => void;
    participantUpdated: (data: {
        participant: Participant;
        updateReasons: ParticipantUpdateReason[];
    }) => void;
    messageAdded: (message: Message) => void;
    messageRemoved: (message: Message) => void;
    messageUpdated: (data: {
        message: Message;
        updateReasons: MessageUpdateReason[];
    }) => void;
    typingEnded: (participant: Participant) => void;
    typingStarted: (participant: Participant) => void;
    updated: (data: {
        conversation: Conversation;
        updateReasons: ConversationUpdateReason[];
    }) => void;
    removed: (conversation: Conversation) => void;
};
/**
 * Reason for the `updated` event emission by a conversation.
 */
type ConversationUpdateReason = "attributes" | "createdBy" | "dateCreated" | "dateUpdated" | "friendlyName" | "lastReadMessageIndex" | "state" | "status" | "uniqueName" | "lastMessage" | "notificationLevel" | "bindings";
/**
 * Status of the conversation, relative to the client: whether the conversation
 * has been `joined` or the client is `notParticipating` in the conversation.
 */
type ConversationStatus = "notParticipating" | "joined";
/**
 * User's notification level for the conversation. Determines
 * whether the currently logged-in user will receive pushes for events
 * in this conversation. Can be either `muted` or `default`, where
 * `default` defers to the global service push configuration.
 */
type NotificationLevel = "default" | "muted";
/**
 * State of the conversation.
 */
interface ConversationState {
    /**
     * Current state.
     */
    current: "active" | "inactive" | "closed";
    /**
     * Date at which the latest conversation state update happened.
     */
    dateUpdated: Date;
}
/**
 * Event arguments for the `updated` event.
 */
interface ConversationUpdatedEventArgs {
    conversation: Conversation;
    updateReasons: ConversationUpdateReason[];
}
/**
 * Binding for email conversation.
 */
interface ConversationBindings {
    email?: ConversationEmailBinding;
    sms?: ConversationSmsBinding;
}
/**
 * Binding for email conversation.
 */
interface ConversationEmailBinding {
    name?: string;
    projected_address: string;
}
/**
 * Binding for SMS conversation.
 */
interface ConversationSmsBinding {
    address?: string;
}
/**
 * Configuration for attaching a media file to a message.
 * These options can be passed to {@link Conversation.sendMessage} and
 * {@link MessageBuilder.addMedia}.
 */
interface SendMediaOptions {
    /**
     * Content type of media.
     */
    contentType: null | string;
    /**
     * Optional filename.
     */
    filename?: string;
    /**
     * Content to post.
     */
    media: null | string | Buffer | Blob;
}
/**
 * These options can be passed to {@link Conversation.sendMessage}.
 */
interface SendEmailOptions {
    /**
     *  Message subject. Ignored for media messages.
     */
    subject?: string;
}
/**
 * Information about the last message of a conversation.
 */
interface LastMessage {
    /**
     * Message's index.
     */
    index?: number;
    /**
     *  Message's creation date.
     */
    dateCreated?: Date;
}
/**
 * Conversation services.
 */
interface ConversationServices {
    users: Users;
    typingIndicator: TypingIndicator;
    network: Network;
    mcsClient: McsClient;
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
    channelMetadataClient: ChannelMetadataClient;
}
/**
 * Conversation descriptor.
 */
interface ConversationDescriptor {
    channel: string;
    entityName: string;
    uniqueName: string;
    attributes: JSONValue;
    createdBy?: string;
    friendlyName?: string;
    lastConsumedMessageIndex: number;
    dateCreated: Date | null;
    dateUpdated: Date | null;
    notificationLevel?: NotificationLevel;
    bindings?: ConversationBindings;
}
/**
 * Conversation links.
 */
interface ConversationLinks {
    self: string;
    messages: string;
    participants: string;
}
/**
 * A conversation represents communication between multiple Conversations
 * clients.
 */
declare class Conversation extends ReplayEventEmitter<ConversationEvents> {
    /**
     * Fired when a participant has joined the conversation.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - participant that joined the
     * conversation
     * @event
     */
    static readonly participantJoined = "participantJoined";
    /**
     * Fired when a participant has left the conversation.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - participant that left the
     * conversation
     * @event
     */
    static readonly participantLeft = "participantLeft";
    /**
     * Fired when data of a participant has been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the
     * following properties:
     *     * {@link Participant} `participant` - participant that has received the
     *     update
     *     * {@link ParticipantUpdateReason}[] `updateReasons` - array of reasons
     *     for the update
     * @event
     */
    static readonly participantUpdated = "participantUpdated";
    /**
     * Fired when a new message has been added to the conversation.
     *
     * Parameters:
     * 1. {@link Message} `message` - message that has been added
     * @event
     */
    static readonly messageAdded = "messageAdded";
    /**
     * Fired when message is removed from the conversation's message list.
     *
     * Parameters:
     * 1. {@link Message} `message` - message that has been removed
     * @event
     */
    static readonly messageRemoved = "messageRemoved";
    /**
     * Fired when data of a message has been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the
     * following properties:
     *     * {@link Message} `message` - message that has received the update
     *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for
     *     the update
     * @event
     */
    static readonly messageUpdated = "messageUpdated";
    /**
     * Fired when a participant has stopped typing.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant that has stopped
     * typing
     * @event
     */
    static readonly typingEnded = "typingEnded";
    /**
     * Fired when a participant has started typing.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant that has started
     * typing
     * @event
     */
    static readonly typingStarted = "typingStarted";
    /**
     * Fired when the data of the conversation has been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the
     * following properties:
     *     * {@link Conversation} `conversation` - conversation that has received
     *     the update
     *     * {@link ConversationUpdateReason}[] `updateReasons` - array of reasons
     *     for the update
     * @event
     */
    static readonly updated = "updated";
    /**
     * Fired when the conversation was destroyed or the currently-logged-in user
     * has left private conversation.
     *
     * Parameters:
     * 1. {@link Conversation} `conversation` - conversation that has been removed
     * @event
     */
    static readonly removed = "removed";
    /**
     * Logger instance.
     */
    private static readonly _logger;
    /**
     * Unique system identifier of the conversation.
     */
    readonly sid: string;
    /**
     * Conversation links for REST requests.
     * @internal
     */
    readonly _links: ConversationLinks;
    /**
     * Map of participants.
     * @internal
     */
    readonly _participants: Map<string, Participant>;
    /**
     * Configuration of the client that the conversation belongs to.
     */
    private readonly _configuration;
    /**
     * Conversation service objects.
     */
    private readonly _services;
    /**
     * Internal state of the conversation.
     */
    private readonly _internalState;
    /**
     * Name of the conversation entity document.
     */
    private readonly _entityName;
    /**
     * Messages entity.
     */
    private readonly _messagesEntity;
    /**
     * Sync list containing messages.
     */
    private _messagesList?;
    /**
     * Participants entity.
     */
    private readonly _participantsEntity;
    /**
     * Sync map containing participants.
     */
    private _participantsMap?;
    /**
     * Source of the most recent update.
     */
    private _dataSource;
    /**
     * Promise for the conversation entity document.
     */
    private _entityPromise;
    /**
     * Conversation entity document.
     */
    private _entity;
    /**
     * @param descriptor Conversation descriptor.
     * @param sid Conversation SID.
     * @param links Conversation links for REST requests.
     * @param configuration Client configuration.
     * @param services Conversation services.
     * @internal
     */
    constructor(descriptor: ConversationDescriptor, sid: string, links: ConversationLinks, configuration: Configuration, services: ConversationServices);
    /**
     * Unique name of the conversation.
     */
    get uniqueName(): string | null;
    /**
     * Status of the conversation.
     */
    get status(): ConversationStatus;
    /**
     * Name of the conversation.
     */
    get friendlyName(): string | null;
    /**
     * Date this conversation was last updated on.
     */
    get dateUpdated(): Date | null;
    /**
     * Date this conversation was created on.
     */
    get dateCreated(): Date | null;
    /**
     * Identity of the user that created this conversation.
     */
    get createdBy(): string;
    /**
     * Custom attributes of the conversation.
     */
    get attributes(): JSONValue;
    /**
     * Index of the last message the user has read in this conversation.
     */
    get lastReadMessageIndex(): number | null;
    /**
     * Last message sent to this conversation.
     */
    get lastMessage(): LastMessage | undefined;
    /**
     * User notification level for this conversation.
     */
    get notificationLevel(): NotificationLevel;
    /**
     * Conversation bindings. Undocumented feature (for now).
     * @internal
     */
    get bindings(): ConversationBindings;
    /**
     * Current conversation limits.
     */
    get limits(): ConversationLimits;
    /**
     * State of the conversation.
     */
    get state(): ConversationState | undefined;
    /**
     * Source of the conversation update.
     * @internal
     */
    get _statusSource(): ConversationsDataSource;
    /**
     * Preprocess the update object.
     * @param update The update object received from Sync.
     * @param conversationSid The SID of the conversation in question.
     */
    private static preprocessUpdate;
    /**
     * Add a participant to the conversation by its identity.
     * @param identity Identity of the Client to add.
     * @param attributes Attributes to be attached to the participant.
     * @returns The added participant.
     */
    add(identity: string, attributes?: JSONValue): Promise<ParticipantResponse>;
    /**
     * Add a non-chat participant to the conversation.
     * @param proxyAddress Proxy (Twilio) address of the participant.
     * @param address User address of the participant.
     * @param attributes Attributes to be attached to the participant.
     * @param bindingOptions Options for adding email participants - name and
     * CC/To level.
     * @returns The added participant.
     */
    addNonChatParticipant(proxyAddress: string, address: string, attributes?: JSONValue, bindingOptions?: ParticipantBindingOptions): Promise<ParticipantResponse>;
    /**
     * Advance the conversation's last read message index to the current read
     * horizon. Rejects if the user is not a participant of the conversation. Last
     * read message index is updated only if the new index value is higher than
     * the previous.
     * @param index Message index to advance to.
     * @return Resulting unread messages count in the conversation.
     */
    advanceLastReadMessageIndex(index: number): Promise<number>;
    /**
     * Delete the conversation and unsubscribe from its events.
     */
    delete(): Promise<Conversation>;
    /**
     * Get the custom attributes of this Conversation.
     */
    getAttributes(): Promise<JSONValue>;
    /**
     * Returns messages from the conversation using the paginator interface.
     * @param pageSize Number of messages to return in a single chunk. Default is
     * 30.
     * @param anchor Index of the newest message to fetch. Default is from the
     * end.
     * @param direction Query direction. By default, it queries backwards
     * from newer to older. The `"forward"` value will query in the opposite
     * direction.
     * @return A page of messages.
     */
    getMessages(pageSize?: number, anchor?: number, direction?: "backwards" | "forward"): Promise<Paginator<Message>>;
    /**
     * Get a list of all the participants who are joined to this conversation.
     */
    getParticipants(): Promise<Participant[]>;
    /**
     * Get conversation participants count.
     *
     * This method is semi-realtime. This means that this data will be eventually
     * correct, but will also be possibly incorrect for a few seconds. The
     * Conversations system does not provide real time events for counter values
     * changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any
     * core application logic based on these counters being accurate in real time.
     */
    getParticipantsCount(): Promise<number>;
    /**
     * Get a participant by its SID.
     * @param participantSid Participant SID.
     */
    getParticipantBySid(participantSid: string): Promise<Participant | null>;
    /**
     * Get a participant by its identity.
     * @param identity Participant identity.
     */
    getParticipantByIdentity(identity?: string | null): Promise<Participant | null>;
    /**
     * Get the total message count in the conversation.
     *
     * This method is semi-realtime. This means that this data will be eventually
     * correct, but will also be possibly incorrect for a few seconds. The
     * Conversations system does not provide real time events for counter values
     * changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any
     * core application logic based on these counters being accurate in real time.
     */
    getMessagesCount(): Promise<number>;
    /**
     * Get count of unread messages for the user if they are a participant of this
     * conversation. Rejects if the user is not a participant of the conversation.
     *
     * Use this method to obtain the number of unread messages together with
     * {@link Conversation.updateLastReadMessageIndex} instead of relying on the
     * message indices which may have gaps. See {@link Message.index} for details.
     *
     * This method is semi-realtime. This means that this data will be eventually
     * correct, but it will also be possibly incorrect for a few seconds. The
     * Conversations system does not provide real time events for counter values
     * changes.
     *
     * This is useful for any UI badges, but it is not recommended to build any
     * core application logic based on these counters being accurate in real time.
     *
     * If the read horizon is not set, this function will return null. This could mean
     * that all messages in the conversation are unread, or that the read horizon system
     * is not being used. How to interpret this `null` value is up to the customer application.
     *
     * @return Number of unread messages based on the current read horizon set for
     * the user or `null` if the read horizon is not set.
     */
    getUnreadMessagesCount(): Promise<number | null>;
    /**
     * Join the conversation and subscribe to its events.
     */
    join(): Promise<Conversation>;
    /**
     * Leave the conversation.
     */
    leave(): Promise<Conversation>;
    /**
     * Remove a participant from the conversation. When a string is passed as the
     * argument, it will assume that the string is an identity or SID.
     * @param participant Identity, SID or the participant object to remove.
     */
    removeParticipant(participant: string | Participant): Promise<void>;
    /**
     * Send a message to the conversation.
     * @param message Message body for the text message,
     * `FormData` or {@link SendMediaOptions} for media content. Sending FormData
     * is supported only with the browser engine.
     * @param messageAttributes Attributes for the message.
     * @param emailOptions Email options for the message.
     * @return Index of the new message.
     */
    sendMessage(message: null | string | FormData | SendMediaOptions, messageAttributes?: JSONValue, emailOptions?: SendEmailOptions): Promise<number>;
    /**
     * New interface to prepare for sending a message.
     * Use this instead of {@link Conversation.sendMessage}.
     * @return A MessageBuilder to help set all message sending options.
     */
    prepareMessage(): MessageBuilder;
    /**
     * Set last read message index of the conversation to the index of the last
     * known message.
     * @return Resulting unread messages count in the conversation.
     */
    setAllMessagesRead(): Promise<number>;
    /**
     * Set all messages in the conversation unread.
     * @returns New count of unread messages after this update.
     */
    setAllMessagesUnread(): Promise<number>;
    /**
     * Set user notification level for this conversation.
     * @param notificationLevel New user notification level.
     */
    setUserNotificationLevel(notificationLevel: NotificationLevel): Promise<void>;
    /**
     * Send a notification to the server indicating that this client is currently
     * typing in this conversation. Typing ended notification is sent after a
     * while automatically, but by calling this method again you ensure that
     * typing ended is not received.
     */
    typing(): Promise<void>;
    /**
     * Update the attributes of the conversation.
     * @param attributes New attributes.
     */
    updateAttributes(attributes: JSONValue): Promise<Conversation>;
    /**
     * Update the friendly name of the conversation.
     * @param friendlyName New friendly name.
     */
    updateFriendlyName(friendlyName: string): Promise<Conversation>;
    /**
     * Set the last read message index to the current read horizon.
     * @param index Message index to set as last read. If null is provided, then
     * the behavior is identical to {@link Conversation.setAllMessagesUnread}.
     * @returns New count of unread messages after this update.
     */
    updateLastReadMessageIndex(index: number | null): Promise<number>;
    /**
     * Update the unique name of the conversation.
     * @param uniqueName New unique name for the conversation. Setting unique name
     * to null removes it.
     */
    updateUniqueName(uniqueName: string | null): Promise<Conversation>;
    /**
     * Load and subscribe to this conversation and do not subscribe to its
     * participants and messages. This or _subscribeStreams will need to be called
     * before any events on conversation will fire.
     * @internal
     */
    _subscribe(): Promise<SyncDocument>;
    /**
     * Fetch participants and messages of the conversation. This method needs to
     * be called during conversation initialization to catch broken conversations
     * (broken conversations are conversations that have essential Sync entities
     * missing, i.e. the conversation document, the messages list or the
     * participant map). In case of this conversation being broken, the method
     * will throw an exception that will be caught and handled gracefully.
     * @internal
     */
    _fetchStreams(): Promise<void>;
    /**
     * Load the attributes of this conversation and instantiate its participants
     * and messages. This or _subscribe will need to be called before any events
     * on the conversation will fire. This will need to be called before any
     * events on participants or messages will fire
     * @internal
     */
    _subscribeStreams(): Promise<void>;
    /**
     * Stop listening for and firing events on this conversation.
     * @internal
     */
    _unsubscribe(): Promise<[
        void,
        void
    ]>;
    /**
     * Set conversation status.
     * @internal
     */
    _setStatus(status: ConversationStatus, source: ConversationsDataSource): void;
    /**
     * Update the local conversation object with new values.
     * @internal
     */
    _update(update: any): void;
    /**
     * Handle onMessageAdded event.
     */
    private _onMessageAdded;
    /**
     * Set last read message index.
     * @param index New index to set.
     */
    private _setLastReadMessageIndex;
}
type ConversationsDataSource = "sync" | "rest";
type PushNotificationType = "twilio.conversations.new_message" | "twilio.conversations.added_to_conversation" | "twilio.conversations.removed_from_conversation";
interface PushNotificationDescriptor {
    title: string | null;
    body: string | null;
    sound: string | null;
    badge: number | null;
    action: string | null;
    type: PushNotificationType;
    data: Record<string, unknown>;
}
/**
 * Additional data for a given push notification.
 */
interface PushNotificationData {
    /**
     * SID of the conversation.
     */
    conversationSid?: string;
    /**
     * Title of the conversation.
     */
    conversationTitle?: string;
    /**
     * Index of the message in the conversation.
     */
    messageIndex?: number;
    /**
     * SID of the message in the conversation.
     */
    messageSid?: string;
    /**
     * Media of the notification
     */
    media?: Media;
    /**
     * Count of the attached media of the message.
     */
    mediaCount?: number;
}
/**
 * Push notification for a Conversations client.
 */
declare class PushNotification {
    /**
     * Title of the notification.
     */
    readonly title: string | null;
    /**
     * Text of the notification.
     */
    readonly body: string | null;
    /**
     * Sound of the notification.
     */
    readonly sound: string | null;
    /**
     * Number of the badge.
     */
    readonly badge: number | null;
    /**
     * Notification action (`click_action` in FCM terms and `category` in APN terms).
     */
    readonly action: string | null;
    /**
     * Type of the notification.
     */
    readonly type: PushNotificationType;
    /**
     * Additional data of the conversation.
     */
    readonly data: PushNotificationData;
    /**
     * @internal
     */
    constructor(data: PushNotificationDescriptor);
}
/**
 * Client events.
 */
type ClientEvents = {
    conversationAdded: (conversation: Conversation) => void;
    conversationJoined: (conversation: Conversation) => void;
    conversationLeft: (conversation: Conversation) => void;
    conversationRemoved: (conversation: Conversation) => void;
    conversationUpdated: (data: {
        conversation: Conversation;
        updateReasons: ConversationUpdateReason[];
    }) => void;
    participantJoined: (participant: Participant) => void;
    participantLeft: (participant: Participant) => void;
    participantUpdated: (data: {
        participant: Participant;
        updateReasons: ParticipantUpdateReason[];
    }) => void;
    messageAdded: (message: Message) => void;
    messageRemoved: (message: Message) => void;
    messageUpdated: (data: {
        message: Message;
        updateReasons: MessageUpdateReason[];
    }) => void;
    tokenAboutToExpire: () => void;
    tokenExpired: () => void;
    typingEnded: (participant: Participant) => void;
    typingStarted: (participant: Participant) => void;
    pushNotification: (pushNotification: PushNotification) => void;
    userSubscribed: (user: User) => void;
    userUnsubscribed: (user: User) => void;
    userUpdated: (data: {
        user: User;
        updateReasons: UserUpdateReason[];
    }) => void;
    stateChanged: (state: State) => void;
    initialized: () => void;
    initFailed: ({ error }: {
        error?: ConnectionError;
    }) => void;
    connectionStateChanged: (state: TwilsockConnectionState) => void;
    connectionError: (data: ConnectionError) => void;
};
/**
 * Connection state of the client. Possible values are as follows:
 * * `'connecting'` - client is offline and connection attempt is in process
 * * `'connected'` - client is online and ready
 * * `'disconnecting'` - client is going offline as disconnection is in process
 * * `'disconnected'` - client is offline and no connection attempt is in
 * process
 * * `'denied'` - client connection is denied because of invalid JWT access
 * token. User must refresh token in order to proceed
 */
type ConnectionState = TwilsockConnectionState;
/**
 * State of the client. Possible values are as follows:
 * * `'failed'` - the client failed to initialize
 * * `'initialized'` - the client successfully initialized
 */
type State = "failed" | "initialized";
/**
 * Notifications channel type. Possible values are as follows:
 * * `'fcm'`
 * * `'apn'`
 */
type NotificationsChannelType = ChannelType;
/**
 * Level of logging.
 */
type LogLevel = "trace" | "debug" | "info" | "warn" | "error" | "silent";
/**
 * Conversations client options.
 */
interface ClientOptions {
    /**
     * The level of logging to enable.
     */
    logLevel?: LogLevel;
    /**
     * The cache capacity for channel metadata.
     */
    channelMetadataCacheCapacity?: number;
    region?: string;
    productId?: string;
    twilsockClient?: TwilsockClient;
    transport?: Transport;
    notificationsClient?: NotificationClient;
    syncClient?: SyncClient;
    typingIndicatorTimeoutOverride?: number;
    consumptionReportIntervalOverride?: string;
    httpCacheIntervalOverride?: string;
    userInfosToSubscribeOverride?: number;
    retryWhenThrottledOverride?: boolean;
    backoffConfigOverride?: Record<string, unknown>;
    Chat?: ClientOptions;
    IPMessaging?: ClientOptions;
    Sync?: Record<string, unknown>;
    Notification?: Record<string, unknown>;
    Twilsock?: Record<string, unknown>;
    clientMetadata?: Record<string, unknown>;
    initRegistrations?: InitRegistration[];
    disableDeepClone?: boolean;
    typingUri?: string;
    apiUri?: string;
}
type ConnectionError = {
    terminal: boolean;
    message: string;
};
/**
 * Options for {@link Client.createConversation}.
 */
interface CreateConversationOptions {
    /**
     * Any custom attributes to attach to the conversation.
     */
    attributes?: JSONValue;
    /**
     * A non-unique display name of the conversation.
     */
    friendlyName?: string;
    /**
     * A unique identifier of the conversation.
     */
    uniqueName?: string;
}
/**
 * A client is the starting point to the Twilio Conversations functionality.
 */
declare class Client extends ReplayEventEmitter<ClientEvents> {
    /**
     * Fired when a conversation becomes visible to the client. The event is also
     * triggered when the client creates a new conversation.
     * Fired for all conversations that the client has joined.
     *
     * Parameters:
     * 1. {@link Conversation} `conversation` - the conversation in question
     * @event
     */
    static readonly conversationAdded = "conversationAdded";
    /**
     * Fired when the client joins a conversation.
     *
     * Parameters:
     * 1. {@link Conversation} `conversation` - the conversation in question
     * @event
     */
    static readonly conversationJoined = "conversationJoined";
    /**
     * Fired when the client leaves a conversation.
     *
     * Parameters:
     * 1. {@link Conversation} `conversation` - the conversation in question
     * @event
     */
    static readonly conversationLeft = "conversationLeft";
    /**
     * Fired when a conversation is no longer visible to the client.
     *
     * Parameters:
     * 1. {@link Conversation} `conversation` - the conversation in question
     * @event
     */
    static readonly conversationRemoved = "conversationRemoved";
    /**
     * Fired when the attributes or the metadata of a conversation have been
     * updated. During conversation's creation and initialization, this event
     * might be fired multiple times for same joined or created conversation as
     * new data is arriving from different sources.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the
     * following properties:
     *     * {@link Conversation} `conversation` - the conversation in question
     *     * {@link ConversationUpdateReason}[] `updateReasons` - array of reasons
     *     for the update
     * @event
     */
    static readonly conversationUpdated = "conversationUpdated";
    /**
     * Fired when a participant has joined a conversation.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant in question
     * @event
     */
    static readonly participantJoined = "participantJoined";
    /**
     * Fired when a participant has left a conversation.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant in question
     * @event
     */
    static readonly participantLeft = "participantLeft";
    /**
     * Fired when a participant's fields have been updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the
     * following properties:
     *     * {@link Participant} `participant` - the participant in question
     *     * {@link ParticipantUpdateReason}[] `updateReasons` - array of reasons
     *     for the update
     * @event
     */
    static readonly participantUpdated = "participantUpdated";
    /**
     * Fired when a new message has been added to the conversation on the server.
     *
     * Parameters:
     * 1. {@link Message} `message` - the message in question
     * @event
     */
    static readonly messageAdded = "messageAdded";
    /**
     * Fired when a message is removed from the message list of a conversation.
     *
     * Parameters:
     * 1. {@link Message} `message` - the message in question
     * @event
     */
    static readonly messageRemoved = "messageRemoved";
    /**
     * Fired when the fields of an existing message are updated with new values.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the
     * following properties:
     *     * {@link Message} `message` - the message in question
     *     * {@link MessageUpdateReason}[] `updateReasons` - array of reasons for
     *     the update
     * @event
     */
    static readonly messageUpdated = "messageUpdated";
    /**
     * Fired when the token is about to expire and needs to be updated.
     * @event
     */
    static readonly tokenAboutToExpire = "tokenAboutToExpire";
    /**
     * Fired when the token has expired.
     * @event
     */
    static readonly tokenExpired = "tokenExpired";
    /**
     * Fired when a participant has stopped typing.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant in question
     * @event
     */
    static readonly typingEnded = "typingEnded";
    /**
     * Fired when a participant has started typing.
     *
     * Parameters:
     * 1. {@link Participant} `participant` - the participant in question
     * @event
     */
    static readonly typingStarted = "typingStarted";
    /**
     * Fired when the client has received (and parsed) a push notification via one
     * of the push channels (apn or fcm).
     *
     * Parameters:
     * 1. {@link PushNotification} `pushNotification` - the push notification in
     * question
     * @event
     */
    static readonly pushNotification = "pushNotification";
    /**
     * Fired when the client has subscribed to a user.
     *
     * Parameters:
     * 1. {@link User} `user` - the user in question
     * @event
     */
    static readonly userSubscribed = "userSubscribed";
    /**
     * Fired when the client has unsubscribed from a user.
     *
     * Parameters:
     * 1. {@link User} `user` - the user in question
     * @event
     */
    static readonly userUnsubscribed = "userUnsubscribed";
    /**
     * Fired when the properties or the reachability status of a user have been
     * updated.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the
     * following properties:
     *     * {@link User} `user` - the user in question
     *     * {@link UserUpdateReason}[] `updateReasons` - array of reasons for the
     *     update
     * @event
     */
    static readonly userUpdated = "userUpdated";
    /**
     * @deprecated Use initialized or initFailed events instead
     * Fired when the state of the client has been changed.
     *
     * Parameters:
     * 1. {@link State} `state` - the new client state
     * @event
     */
    static readonly stateChanged = "stateChanged";
    /**
     * Fired when the client has completed initialization successfully.
     * @event
     */
    static readonly initialized = "initialized";
    /**
     * Fired when the client initialization failed.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the
     * following property:
     *     * Error? `error` - the initialization error if present
     * @event
     */
    static readonly initFailed = "initFailed";
    /**
     * Fired when the connection state of the client has been changed.
     *
     * Parameters:
     * 1. {@link ConnectionState} `state` - the new connection state
     * @event
     */
    static readonly connectionStateChanged = "connectionStateChanged";
    /**
     * Fired when the connection is interrupted for an unexpected reason.
     *
     * Parameters:
     * 1. object `data` - info object provided with the event. It has the
     * following properties:
     *     * boolean `terminal` - Twilsock will stop connection attempts if true
     *     * string `message` - the error message of the root cause
     *     * number? `httpStatusCode` - http status code if available
     *     * number? `errorCode` - Twilio public error code if available
     * @event
     */
    static readonly connectionError = "connectionError";
    /**
     * Current version of the Conversations client.
     */
    static readonly version: string;
    /**
     * Logger instance.
     */
    private static readonly _logger;
    /**
     * Supported push notification channels.
     */
    private static readonly _supportedPushChannels;
    /**
     * Supported push data fields.
     */
    private static readonly _supportedPushDataFields;
    /**
     * Current version of the Conversations client.
     */
    readonly version: string;
    /**
     * Client connection state.
     */
    connectionState: ConnectionState;
    /**
     * Promise that resolves on successful initialization.
     */
    private readonly _ensureReady;
    /**
     * Options passed to the client.
     */
    private readonly _options;
    /**
     * Client service objects.
     */
    private readonly _services;
    /**
     * The user of the client.
     */
    private readonly _myself;
    /**
     * Resolves the {@link Client._ensureReady} promise.
     */
    private _resolveEnsureReady;
    /**
     * Rejects the {@link Client._ensureReady} promise.
     */
    private _rejectEnsureReady;
    /**
     * The current token of the client.
     */
    private _fpaToken;
    /**
     * The constructed configuration object.
     */
    private _configuration;
    /**
     * The Conversations entity.
     */
    private _conversationsEntity;
    /**
     * Promise that resolves when initial conversations are fetched.
     */
    private _conversationsPromise;
    /**
     * Returned Conversations instance is not yet fully initialized. Calling any
     * operations will block until it is. Use connection events to monitor when
     * client becomes fully available (connectionStateChanged with state
     * 'connected') or not available (connectionStateChange with state 'denied',
     * event tokenExpired, event connectionError).
     *
     * @param fpaToken Access token
     * @param options Options to customize the Client
     * @returns A not yet fully-initialized client.
     */
    constructor(fpaToken: string, options?: ClientOptions | null);
    /**
     * Information of the logged-in user. Before client initialization, returns an
     * uninitialized user. Will trigger a {@link Client.userUpdated} event after
     * initialization.
     */
    get user(): User;
    /**
     * Client reachability state. Throws an error if accessed before the client
     * initialization was completed.
     */
    get reachabilityEnabled(): boolean;
    /**
     * @deprecated
     * Current token.
     * @internal
     */
    get token(): string;
    /**
     * @deprecated Call constructor directly.
     *
     * Factory method to create a Conversations client instance.
     *
     * The factory method will automatically trigger connection.
     * Do not use it if you need finer-grained control.
     *
     * Since this method returns an already-initialized client, some of the events
     * will be lost because they happen *before* the initialization. It is
     * recommended that `client.onWithReplay` is used as opposed to `client.on`
     * for subscribing to client events. The `client.onWithReplay` will re-emit
     * the most recent value for a given event if it emitted before the
     * subscription.
     *
     * @param token Access token.
     * @param options Options to customize the client.
     * @returns Returns a fully initialized client.
     */
    static create(token: string, options?: ClientOptions | null): Promise<Client>;
    /**
     * Static method for push notification payload parsing. Returns parsed push as
     * a {@link PushNotification} object.
     * @param notificationPayload Push notification payload.
     */
    static parsePushNotification(notificationPayload: any): PushNotification;
    /**
     * Static method for parsing push notification chat data.
     * @param data Data to parse
     */
    private static _parsePushNotificationChatData;
    /**
     * Populate the client with init registrations.
     * @param reg The init registration to populate.
     */
    static populateInitRegistrations(reg: InitRegistration): void;
    /**
     * Gracefully shut down the client.
     */
    shutdown(): Promise<void>;
    /**
     * Update the token used by the client and re-register with the Conversations services.
     * @param token New access token.
     */
    updateToken(token: string): Promise<Client>;
    /**
     * Get a known conversation by its SID.
     * @param conversationSid Conversation sid
     */
    getConversationBySid(conversationSid: string): Promise<Conversation>;
    /**
     * Peek a conversation by its SID.
     * @param conversationSid Conversation sid
     * @internal
     */
    peekConversationBySid(conversationSid: string): Promise<Conversation>;
    /**
     * Get a known conversation by its unique identifier name.
     * @param uniqueName The unique identifier name of the conversation.
     */
    getConversationByUniqueName(uniqueName: string): Promise<Conversation>;
    /**
     * Get the current list of all the subscribed conversations.
     */
    getSubscribedConversations(): Promise<Paginator<Conversation>>;
    /**
     * Create a conversation on the server and subscribe to its events.
     * The default is a conversation with an empty friendly name.
     * @param options Options for the conversation.
     */
    createConversation(options?: CreateConversationOptions): Promise<Conversation>;
    /**
     * Register for push notifications.
     * @param channelType Channel type.
     * @param registrationId Push notification ID provided by the FCM/APNS service
     * on the platform.
     */
    setPushRegistrationId(channelType: NotificationsChannelType, registrationId: string): Promise<void>;
    /**
     * Unregister from push notifications.
     * @param channelType Channel type.
     * @deprecated Use removePushRegistrations() instead.
     */
    unsetPushRegistrationId(channelType: NotificationsChannelType): Promise<void>;
    /**
     * Clear existing registrations directly using provided device token.
     * This is useful to ensure stopped subscriptions without resubscribing.
     *
     * This function goes completely beside the state machine and removes all
     * registrations.
     * Use with caution: if it races with current state machine operations,
     * madness will ensue.
     *
     * @param channelType Channel type.
     * @param registrationId Push notification ID provided by the FCM/APNS service
     * on the platform.
     */
    removePushRegistrations(channelType: ChannelType, registrationId: string): Promise<void>;
    /**
     * Current version of the Conversations client.
     */
    parsePushNotification: typeof Client.parsePushNotification;
    /**
     * Handle push notification payload parsing and emit the
     * {@link Client.pushNotification} event on this {@link Client} instance.
     * @param notificationPayload Push notification payload
     */
    handlePushNotification(notificationPayload: any): Promise<void>;
    /**
     * Gets a user with the given identity. If it's in the subscribed list, then
     * return the user object from it;
     * if not, then subscribe and add user to the subscribed list.
     * @param identity Identity of the user.
     * @returns A fully initialized user.
     */
    getUser(identity: string): Promise<User>;
    /**
     * Get a list of subscribed user objects.
     */
    getSubscribedUsers(): Promise<Array<User>>;
    /**
     * Get content URLs for all media attachments in the given set of media sids
     * using a single operation.
     * @param mediaSids Set of media sids to query for the content URL.
     */
    getTemporaryContentUrlsForMediaSids(mediaSids: string[]): CancellablePromise<Map<string, string>>;
    /**
     * Get content URLs for all media attachments in the given set using a single
     * operation.
     * @param contentSet Set of media attachments to query content URLs.
     */
    getTemporaryContentUrlsForMedia(contentSet: Media[]): CancellablePromise<Map<string, string>>;
    /**
     * Returns rich content templates belonging to the account. Rich content
     * templates can be created via the Twilio console or the REST API.
     */
    getContentTemplates(): Promise<Readonly<ContentTemplate[]>>;
    /**
     * Initialize the client.
     */
    private _initialize;
    /**
     * Subscribe to push notifications.
     * @param channelType The channel type to subscribe to.
     */
    private _subscribeToPushNotifications;
    /**
     * Unsubscribe from push notifications.
     * @param channelType The channel type to unsubscribe from.
     */
    private _unsubscribeFromPushNotifications;
}
declare class NotificationTypes {
    static readonly TYPING_INDICATOR = "twilio.ipmsg.typing_indicator";
    static readonly NEW_MESSAGE = "twilio.conversations.new_message";
    static readonly ADDED_TO_CONVERSATION = "twilio.conversations.added_to_conversation";
    // static readonly INVITED_TO_CHANNEL = 'twilio.channel.invited_to_channel';
    static readonly REMOVED_FROM_CONVERSATION = "twilio.conversations.removed_from_conversation";
    static readonly CONSUMPTION_UPDATE = "twilio.channel.consumption_update";
}
export { Conversation, ConversationBindings, ConversationEmailBinding, ConversationUpdateReason, ConversationStatus, NotificationLevel, ConversationState, ConversationUpdatedEventArgs, SendMediaOptions, SendEmailOptions, LastMessage, Participant, ParticipantUpdateReason, ParticipantType, ParticipantUpdatedEventArgs, ParticipantBindings, ParticipantEmailBinding, ParticipantEmailLevel, Message, MessageUpdateReason, MessageType, MessageUpdatedEventArgs, Media, MediaCategory$0 as MediaCategory, AggregatedDeliveryReceipt, DeliveryAmount, DetailedDeliveryReceipt, DeliveryStatus, RestPaginator, MessageBuilder, UnsentMessage, Paginator, ParticipantBindingOptions, User, UserUpdateReason, UserUpdatedEventArgs, PushNotification, PushNotificationType, PushNotificationDescriptor, PushNotificationData, NotificationTypes, Client, State, ConnectionState, NotificationsChannelType, ClientOptions, CreateConversationOptions, ConversationLimits, JSONValue, JSONObject, JSONArray, CancellablePromise, ContentDataActionUrl, ContentDataActionPhone, ContentDataActionReply, ContentDataActionOther, ContentDataAction, ContentDataText, ContentDataMedia, ContentDataLocation, ContentDataReply, ContentDataQuickReply, ContentDataCallToAction, ContentDataListPicker, ContentDataListItem, ContentDataCard, ContentDataOther, ContentData, ContentTemplate, ContentTemplateVariable, ChannelMetadata };
